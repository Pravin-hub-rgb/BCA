<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 3</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="" class="link">Next Topic &rarr;</a>
                <a href="../unit2/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Unit 3</h2>
        </div>
    </div>
    <div class="content-box">
        <div class="wh">
            <h2>Line Drawing Algorithm</h2>
            <div class="in">
                <h3>DDA Line Drawing Algorithm</h3>

                <p>The DDA (Digital Differential Analyzer) line drawing algorithm is an efficient method for drawing
                    lines in computer graphics. It uses simple calculations to determine the coordinates of each pixel
                    along a line.</p>

                <h3>Steps to Draw a Line using DDA Algorithm</h3>

                <ul>
                    <li><strong>Step 1: Given Two Points</strong>
                        <p>We are given two points, which define the start and end of the line:</p>
                        <ul>
                            <li><strong>Point 1 (x1, y1)</strong> – Start point of the line.</li>
                            <li><strong>Point 2 (x2, y2)</strong> – End point of the line.</li>
                        </ul>
                        <p>The points (x1, y1) and (x2, y2) will define the start and end of the line.</p>
                    </li>

                    <li><strong>Step 2: Calculate Differences</strong>
                        <p>We calculate the differences in the X and Y coordinates:</p>
                        <p class="ms">
                            \[
                            \Delta X = x2 - x1
                            \]
                        </p>
                        <br>
                        <p class="ms">
                            \[
                            \Delta Y = y2 - y1
                            \]
                        </p>
                        <p>The values of ΔX and ΔY will help in determining the slope and how to increment X or Y.</p>
                    </li>

                    <li><strong>Step 3: Calculate the Slope</strong>
                        <p>The slope (m) of the line is calculated as:</p>
                        <p class="ms">
                            \[
                            m = \frac{\Delta Y}{\Delta X}
                            \]
                        </p>
                        <p>This gives us the direction of the line, which helps in deciding whether to increment X or Y.
                        </p>
                    </li>

                    <li><strong>Step 4: Decide Whether to Increment X or Y</strong>
                        <p>Now, we decide how to move along the line. There are two cases:</p>

                        <ul>
                            <li><strong>Case 1: When ΔX ≥ ΔY (X changes more than Y)</strong>
                                <p>In this case, we increment X by 1 in each step. To find the corresponding Y, we use
                                    the slope:</p>
                                <p class="ms">
                                    \[
                                    \Delta Y = m \times \Delta X
                                    \]
                                </p>
                                <p>Since we are incrementing X by 1 (i.e., ΔX = 1), we substitute this into the
                                    equation:</p>
                                <p class="ms">
                                    \[
                                    y_{i+1} = y_i + m
                                    \]
                                </p>
                                <p>Now, we increment X by 1:</p>
                                <p class="ms">
                                    \[
                                    x_{i+1} = x_i + 1
                                    \]
                                </p>
                            </li>

                            <li><strong>Case 2: When ΔY > ΔX (Y changes more than X)</strong>
                                <p>In this case, we increment Y by 1 in each step. To find the corresponding X, we
                                    rearrange the slope formula:</p>
                                <p class="ms">
                                    \[
                                    \Delta X = \frac{\Delta Y}{m}
                                    \]
                                </p>
                                <p>Since we are incrementing Y by 1 (i.e., ΔY = 1), we substitute this into the
                                    equation:</p>
                                <p class="ms">
                                    \[
                                    x_{i+1} = x_i + \frac{1}{m}
                                    \]
                                </p>
                                <p>Now, we increment Y by 1:</p>
                                <p class="ms">
                                    \[
                                    y_{i+1} = y_i + 1
                                    \]
                                </p>
                            </li>
                        </ul>
                    </li>

                    <li><strong>Step 5: Continue Until the End Point is Reached</strong>
                        <p>Start at (x1, y1) and keep calculating the next coordinates using the steps above until
                            reaching (x2, y2). Round the values to get the closest integer pixel positions.</p>
                    </li>
                </ul>
                <hr>
                <p><strong>Example: Line from (2, 3) to (6, 8)</strong></p>

                <p><strong>Given:</strong></p>
                <ul>
                    <li><strong>Point 1 (x1, y1) = (2, 3)</strong></li>
                    <li><strong>Point 2 (x2, y2) = (6, 8)</strong></li>
                </ul>

                <p>First, calculate the differences:</p>
                <p class="ms">
                    \[
                    \Delta X = 6 - 2 = 4, \quad \Delta Y = 8 - 3 = 5
                    \]
                </p>

                <p>Next, calculate the slope:</p>
                <p class="ms">
                    \[
                    m = \frac{5}{4} = 1.25
                    \]
                </p>

                <p>Since ΔY > ΔX, we increment Y by 1 and calculate X for each step. Here’s the calculation for the
                    points:</p>

                <ul>
                    <li><strong>Start at (2, 3).</strong></li>
                    <li><strong>Next point:</strong> Increment Y by 1, calculate X:</li>
                    <p class="ms">
                        \[
                        X_{\text{next}} = X + \frac{1}{m} = 2 + \frac{1}{1.25} = 2.8
                        \]
                    </p>
                    <li>The next point is (2.8, 4).</li>

                    <li><strong>Next point:</strong> Increment Y by 1, calculate X:</li>
                    <p class="ms">
                        \[
                        X_{\text{next}} = X + \frac{1}{m} = 2.8 + \frac{1}{1.25} = 3.6
                        \]
                    </p>
                    <li>The next point is (3.6, 5).</li>

                    <li><strong>Next point:</strong> Increment Y by 1, calculate X:</li>
                    <p class="ms">
                        \[
                        X_{\text{next}} = X + \frac{1}{m} = 3.6 + \frac{1}{1.25} = 4.4
                        \]
                    </p>
                    <li>The next point is (4.4, 6).</li>

                    <li><strong>Next point:</strong> Increment Y by 1, calculate X:</li>
                    <p class="ms">
                        \[
                        X_{\text{next}} = X + \frac{1}{m} = 4.4 + \frac{1}{1.25} = 5.2
                        \]
                    </p>
                    <li>The next point is (5.2, 7).</li>

                    <li><strong>Final point:</strong> Increment Y by 1, calculate X:</li>
                    <p class="ms">
                        \[
                        X_{\text{next}} = X + \frac{1}{m} = 5.2 + \frac{1}{1.25} = 6
                        \]
                    </p>
                    <li>The next point is (6, 8), which is the end point.</li>
                </ul>

                <p>Here’s the table of values:</p>
                <pre>
                    <code>
  x   |  y
+
  2   |  3
  2.8 |  4
  3.6 |  5
  4.4 |  6
  5.2 |  7
  6   |  8
                    </code>
                </pre>

                <p>This table shows the calculated points from the start to the end point using the DDA algorithm.</p>
                <hr>
                <p><strong>Example: Line from (1, 1) to (4, 3)</strong></p>

                <p><strong>Given:</strong></p>
                <ul>
                    <li><strong>Point 1 (x1, y1) = (1, 1)</strong></li>
                    <li><strong>Point 2 (x2, y2) = (4, 3)</strong></li>
                </ul>

                <p>First, calculate the differences:</p>
                <p class="ms">
                    \[
                    \Delta X = 4 - 1 = 3, \quad \Delta Y = 3 - 1 = 2
                    \]
                </p>

                <p>Next, calculate the slope:</p>
                <p class="ms">
                    \[
                    m = \frac{2}{3} \approx 0.6667
                    \]
                </p>

                <p>Since ΔX > ΔY, we increment X and calculate Y for each step. Here’s the calculation for the points:
                </p>

                <ul>
                    <li><strong>Start at (1, 1).</strong></li>
                    <li><strong>Next point:</strong> Increment X by 1, calculate Y:</li>
                    <p class="ms">
                        \[
                        Y_{\text{next}} = Y + m = 1 + 0.6667 = 1.6667
                        \]
                    </p>
                    <li>The next point is (2, 1.6667).</li>

                    <li><strong>Next point:</strong> Increment X by 1, calculate Y:</li>
                    <p class="ms">
                        \[
                        Y_{\text{next}} = Y + m = 1.6667 + 0.6667 = 2.3333
                        \]
                    </p>
                    <li>The next point is (3, 2.3333).</li>

                    <li><strong>Final point:</strong> Increment X by 1, calculate Y:</li>
                    <p class="ms">
                        \[
                        Y_{\text{next}} = Y + m = 2.3333 + 0.6667 = 3
                        \]
                    </p>
                    <li>The next point is (4, 3), which is the end point.</li>
                </ul>

                <p>Here’s the table of values:</p>
                <pre>
                    <code>
  x  |	y
--+--
  1  |	1
  2  |	1.6667
  3  |	2.3333
  4  |	3
                    </code>
                </pre>


                <p>This table shows the calculated points from the start to the end point using the DDA algorithm.</p>

            </div>
            <div class="in">
                <h3>Bresenham's Line Drawing Algorithm</h3>
                <ul>
                    <li>We are familiar with the DDA (Digital Differential Analyzer) algorithm for line drawing, right?
                        It works by calculating the slope of the line and incrementing the coordinates in steps, using
                        floating-point arithmetic. While DDA provides a simple and straightforward way to draw lines,
                        the main drawback is that it uses floating-point calculations, which can lead to rounding errors
                        and less efficient performance.</li>
                    <li>This is where Bresenham's Line Drawing Algorithm comes in. Unlike DDA, which uses floating-point
                        calculations, Bresenham's algorithm works entirely with integer arithmetic. This means it avoids
                        the use of floating-point numbers, leading to more accurate and efficient calculations. The
                        result is a much faster and more precise way to draw lines on digital screens, without the risk
                        of rounding errors.</li>
                </ul>

                <p><strong>Definition: </strong>The Bresenham's Line Drawing Algorithm is an efficient way to draw a
                    straight line between two points in computer graphics. The algorithm uses integer calculations to
                    avoid the use of floating-point operations, making it faster and suitable for raster display
                    systems.</p>

                <ul>
                    <li><strong>Step 1: Given Two Points</strong>
                        <p>We are given two points <strong>(x1, y1)</strong> and <strong>(x2, y2)</strong>, which define
                            the start and end of the line.</p>
                    </li>

                    <li><strong>Step 2: Calculate Differences</strong>
                        <p>First, we calculate the differences in X and Y:</p>
                        <p class="ms">
                            \[
                            \Delta X = x2 - x1, \quad \Delta Y = y2 - y1
                            \]
                        </p>
                        <p><strong>Important:</strong> These values of <strong>ΔX</strong> and <strong>ΔY</strong> are
                            <strong>calculated once at the beginning</strong> and remain the same throughout the
                            algorithm. When updating the decision parameter <strong>p</strong>, we always use these
                            initial values and do not recalculate them based on the updated <strong>x</strong> and
                            <strong>y</strong>.
                        </p>
                    </li>

                    <li><strong>Step 3: Calculate the Slope</strong>
                        <p>The slope <strong>m</strong> is calculated as:</p>
                        <p class="ms">
                            \[
                            m = \frac{\Delta Y}{\Delta X}
                            \]
                        </p>
                        <p>We use this to determine whether the line is <strong>shallow</strong> or
                            <strong>steep</strong>.
                        </p>
                    </li>

                    <li><strong>Step 4: Initialize the Decision Parameter</strong>
                        <p>The decision parameter <strong>p</strong> is initialized using the fixed values of
                            <strong>ΔX</strong> and <strong>ΔY</strong>:
                        </p>
                        <p class="ms">
                            \[
                            p = 2\Delta Y - \Delta X
                            \]
                        </p>
                        <p><strong>Important:</strong> When updating <strong>p</strong> in later steps, we
                            <strong>always use the original ΔX and ΔY</strong> that were calculated at the beginning.
                        </p>
                    </li>

                    <li><strong>Step 5: Check the Slope</strong>
                        <p>Now, we check whether the slope <strong>m</strong> is less than 1 or greater than or equal to
                            1. The algorithm behaves differently based on this value:</p>

                        <ul>
                            <li><strong>Case 1: When <strong>m &lt; 1</strong> (Shallow Line - More Horizontal)</strong>
                                <p>If <strong>m &lt; 1</strong>, we <strong>always</strong> increment <strong>x</strong>
                                    by 1 and decide whether to increment <strong>y</strong>.</p>
                                <p>Using the fixed values of <strong>ΔX</strong> and <strong>ΔY</strong>, the steps are:
                                </p>

                                <ul>
                                    <li><strong>Start:</strong> Let <strong>x0 = x1</strong> and <strong>y0 =
                                            y1</strong>. We continue until we reach <strong>x2</strong>.</li>
                                    <li>If <strong>p &lt; 0</strong>:
                                        <p class="ms">
                                            \[
                                            x_{i+1} = x_i + 1, \quad y_{i+1} = y_i
                                            \]
                                        </p>
                                        <p>Update <strong>p</strong> using the <strong>fixed</strong>
                                            <strong>ΔX</strong> and <strong>ΔY</strong>:
                                        </p>
                                        <p class="ms">
                                            \[
                                            p = p + 2 \Delta Y
                                            \]
                                        </p>
                                    </li>
                                    <li>If <strong>p &ge; 0</strong>:
                                        <p class="ms">
                                            \[
                                            x_{i+1} = x_i + 1, \quad y_{i+1} = y_i + 1
                                            \]
                                        </p>
                                        <p>Update <strong>p</strong> using the <strong>fixed</strong>
                                            <strong>ΔX</strong> and <strong>ΔY</strong>:
                                        </p>
                                        <p class="ms">
                                            \[
                                            p = p + 2 \Delta Y - 2 \Delta X
                                            \]
                                        </p>
                                    </li>
                                </ul>
                            </li>

                            <li><strong>Case 2: When <strong>m &ge; 1</strong> (Steep Line - More Vertical)</strong>
                                <p>If <strong>m &ge; 1</strong>, we <strong>always</strong> increment <strong>y</strong>
                                    by 1 and decide whether to increment <strong>x</strong>.</p>
                                <p>Using the fixed values of <strong>ΔX</strong> and <strong>ΔY</strong>, the steps are:
                                </p>

                                <ul>
                                    <li><strong>Start:</strong> Let <strong>x0 = x1</strong> and <strong>y0 =
                                            y1</strong>. We continue until we reach <strong>y2</strong>.</li>
                                    <li>If <strong>p &lt; 0</strong>:
                                        <p class="ms">
                                            \[
                                            x_{i+1} = x_i, \quad y_{i+1} = y_i + 1
                                            \]
                                        </p>
                                        <p>Update <strong>p</strong> using the <strong>fixed</strong>
                                            <strong>ΔX</strong> and <strong>ΔY</strong>:
                                        </p>
                                        <p class="ms">
                                            \[
                                            p = p + 2 \Delta X
                                            \]
                                        </p>
                                    </li>
                                    <li>If <strong>p &ge; 0</strong>:
                                        <p class="ms">
                                            \[
                                            x_{i+1} = x_i + 1, \quad y_{i+1} = y_i + 1
                                            \]
                                        </p>
                                        <p>Update <strong>p</strong> using the <strong>fixed</strong>
                                            <strong>ΔX</strong> and <strong>ΔY</strong>:
                                        </p>
                                        <p class="ms">
                                            \[
                                            p = p + 2 \Delta X - 2 \Delta Y
                                            \]
                                        </p>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>

                    <li><strong>Step 6: Continue Until the End Point is Reached</strong>
                        <p>We continue applying the rules above, updating <strong>p</strong> and plotting the points
                            step by step from <strong>(x1, y1)</strong> to <strong>(x2, y2)</strong>.</p>
                        <p><strong>Important:</strong> The values of <strong>ΔX</strong> and <strong>ΔY</strong>
                            <strong>never change</strong> during this process. When updating <strong>p</strong>, we do
                            not recalculate them using the new <strong>x</strong> and <strong>y</strong>. Instead, we
                            always use the original values calculated at the beginning.
                        </p>
                    </li>
                </ul>

                <hr>
                <p><strong>Bresenham's Line Drawing Algorithm: Example</strong></p>

                <p>We will use Bresenham's Line Drawing Algorithm to draw a line between the points (1, 1) and (5, 3).
                </p>

                <h4>Given Two Points:</h4>
                <p>Let the starting point be:</p>
                <p class="ms">
                    \[
                    x_0 = 1, \quad y_0 = 1
                    \]
                </p>
                <p>We continue until we reach:</p>
                <p class="ms">
                    \[
                    x = 5, \quad y = 3
                    \]
                </p>

                <h4>Step 1: Calculate Differences</h4>
                <p>First, we calculate the differences in the x and y coordinates:</p>
                <p class="ms">
                    \[
                    \Delta X = x_2 - x_1 = 5 - 1 = 4, \quad \Delta Y = y_2 - y_1 = 3 - 1 = 2
                    \]
                </p>

                <h4>Step 2: Compute Initial Decision Parameter</h4>
                <p>The decision parameter \( p \) is calculated as:</p>
                <p class="ms">
                    \[
                    p_0 = 2 \Delta Y - \Delta X = 2 \times 2 - 4 = 0
                    \]
                </p>

                <h4>Step 3: Iterating Through Points</h4>
                <p>Since \( m < 1 \), we increment \( x \) by 1 at each step and decide whether to increment \( y \)
                        based on \( p \).</p>

                        <ul>
                            <li><strong>Initially</strong>: \( x_0 = 1, y_0 = 1, p_0 = 0 \).</li>

                            <li><strong>Step 1:</strong> Since \( p_0 \geq 0 \), we increment both \( x \) and \( y \):
                            </li>
                            <p class="ms">
                                \[
                                x_1 = x_0 + 1 = 2, \quad y_1 = y_0 + 1 = 2
                                \]
                            </p>
                            <p>Update \( p \):</p>
                            <p class="ms">
                                \[
                                p_1 = p_0 + 2 \Delta Y - 2 \Delta X = 0 + 2(2) - 2(4) = -4
                                \]
                            </p>

                            <li><strong>Step 2:</strong> Since \( p_1 < 0 \), we only increment \( x \):</li>
                                    <p class="ms">
                                        \[
                                        x_2 = x_1 + 1 = 3, \quad y_2 = y_1 = 2
                                        \]
                                    </p>
                                    <p>Update \( p \):</p>
                                    <p class="ms">
                                        \[
                                        p_2 = p_1 + 2 \Delta Y = -4 + 2(2) = 0
                                        \]
                                    </p>

                            <li><strong>Step 3:</strong> Since \( p_2 \geq 0 \), we increment both \( x \) and \( y \):
                            </li>
                            <p class="ms">
                                \[
                                x_3 = x_2 + 1 = 4, \quad y_3 = y_2 + 1 = 3
                                \]
                            </p>
                            <p>Update \( p \):</p>
                            <p class="ms">
                                \[
                                p_3 = p_2 + 2 \Delta Y - 2 \Delta X = 0 + 2(2) - 2(4) = -4
                                \]
                            </p>

                            <li><strong>Step 4:</strong> Since \( p_3 < 0 \), we only increment \( x \):</li>
                                    <p class="ms">
                                        \[
                                        x_4 = x_3 + 1 = 5, \quad y_4 = y_3 = 3
                                        \]
                                    </p>
                                    <p>Since we have reached \( x = 5, y = 3 \), we stop.</p>
                        </ul>

                        <h4>Table of Calculated Points:</h4>
                        <pre>
    <code>
  X  | Y  | p  | Action
--+-+-+-
  1  | 1  |  0  | Initial point
  2  | 2  | -4  | Increment X, Increment Y (p ≥ 0)
  3  | 2  |  0  | Increment X only (p < 0)
  4  | 3  | -4  | Increment X, Increment Y (p ≥ 0)
  5  | 3  |  -  | Increment X only, reached endpoint
    </code>
</pre>

                        <p>The points (1,1), (2,2), (3,2), (4,3), and (5,3) are plotted following Bresenham's algorithm.
                            The decision parameter is used to determine whether to increment Y in each step while always
                            incrementing X by 1.</p>

            </div>
        </div>
        <div class="wh">
            <h2>Midpoint Circle Drawing Algorithm (Mathematical Approach)</h2>

            <p>The Midpoint Circle Algorithm is an efficient method for drawing circles using only integer calculations.
                It avoids floating-point arithmetic, making it faster for computers.</p>

            <h3>Why Do We Need This Algorithm?</h3>

            <p>A circle is defined by the equation:</p>
            <p class="ms">
                \[
                x^2 + y^2 = r^2
                \]
            </p>
            <p>However, solving for \( y \) requires square roots and floating-point calculations, which are
                inefficient. The Midpoint Circle Algorithm helps determine the next pixel using integer calculations
                only.</p>

            <h3>Steps to Draw a Circle using the Midpoint Algorithm</h3>

            <ul>
                <li><strong>Step 1: Start from (0, r) and Consider the Next Point</strong>
                    <p>We start at \( (0, r) \), the top of the circle (90°), and move towards the 45° line.</p>
                    <p>At each step, we have two possible choices for the next pixel:</p>
                    <ul>
                        <li><strong>Move right → \( (x+1, y) \)</strong></li>
                        <li><strong>Move diagonally down-right → \( (x+1, y-1) \)</strong></li>
                    </ul>
                    <p>We need a way to decide which point is closer to the actual circle.</p>
                </li>

                <li><strong>Step 2: Define the Midpoint Decision Parameter</strong>
                    <p>To make this decision, we use the midpoint between the two possible points:</p>
                    <p class="ms">
                        \[
                        \text{Midpoint} = (x+1, y - \frac{1}{2})
                        \]
                    </p>
                    <p>We check whether this midpoint is inside or outside the circle to decide the next point.</p>
                </li>

                <li><strong>Step 3: Using the Circle Equation to Check the Midpoint</strong>
                    <p>The equation of a circle is:</p>
                    <p class="ms">
                        \[
                        x^2 + y^2 - r^2 = 0
                        \]
                    </p>
                    <p>For the midpoint, we define the decision parameter:</p>
                    <p class="ms">
                        \[
                        p = f(x+1, y - \frac{1}{2}) = (x+1)^2 + (y - \frac{1}{2})^2 - r^2
                        \]
                    </p>
                    <p>To avoid fractions, we multiply everything by 2 and simplify. The initial decision parameter at
                        \( (0, r) \) is:</p>
                    <p class="ms">
                        \[
                        p = 1 - r
                        \]
                    </p>
                </li>

                <li><strong>Step 4: Decision Making and Updating \( p \)</strong>
                    <p>At each step, we check the midpoint \( (x+1, y - \frac{1}{2}) \) using the decision parameter \(
                        p \).</p>

                    <ul>
                        <li><strong>Case 1: If \( p < 0 \) (Midpoint is inside the circle) → Move Right</strong>
                                    <p>Since the midpoint is inside the circle, the actual circle passes above it, so we
                                        move right to \( (x+1, y) \).</p>
                                    <p>We update the decision parameter:</p>
                                    <p class="ms">
                                        \[
                                        p_{\text{new}} = p + 2x + 3
                                        \]
                                    </p>
                        </li>

                        <li><strong>Case 2: If \( p \geq 0 \) (Midpoint is outside or on the circle) → Move Diagonally
                                Down-Right</strong>
                            <p>Since the midpoint is outside the circle, the actual circle passes below it, so we move
                                diagonally to \( (x+1, y-1) \).</p>
                            <p>We update the decision parameter:</p>
                            <p class="ms">
                                \[
                                p_{\text{new}} = p + 2x - 2y + 5
                                \]
                            </p>
                        </li>
                    </ul>
                </li>

                <li><strong>Step 5: Stopping Condition – When Do We Stop?</strong>
                    <p>We start at \( (0, r) \) (top of the circle at 90°) and move downward until we reach the 45°
                        line.</p>
                    <p>We stop when:</p>
                    <p class="ms">
                        \[
                        x \geq y
                        \]
                    </p>
                    <p>This happens because:</p>
                    <ul>
                        <li>At \( x = 0, y = r \), the point is at the top of the circle.</li>
                        <li>As \( x \) increases and \( y \) decreases, the points curve toward the right.</li>
                        <li>When \( x = y \), we reach exactly 45° (the diagonal line).</li>
                        <li>Beyond this point, values will mirror the already-calculated points.</li>
                    </ul>
                </li>

                <li><strong>Why Are We Calculating Only 1/8th of the Circle?</strong>
                    <p>We calculate only 1/8th of the circle because:</p>
                    <ul>
                        <li>We start at \( (0, r) \), which is at 90° (topmost point).</li>
                        <li>We compute points until \( x = y \), which is exactly 45°.</li>
                        <li>The rest of the circle is drawn using symmetry.</li>
                    </ul>
                    <p>By using symmetry, we save computation time and ensure efficient drawing of the full circle.</p>
                </li>
            </ul>

            <div class="in">
                <h3>Example: Draw a Circle with Center (0,0) and Radius 5</h3>

                <h3>Step 1: Given Information</h3>
                <ul>
                    <li><strong>Center of the Circle:</strong> \( (0,0) \)</li>
                    <li><strong>Radius:</strong> \( r = 5 \)</li>
                </ul>

                <h3>Step 2: Initial Setup</h3>
                <p>We start from the topmost point of the circle at \( (0,5) \).
                    The decision parameter helps us determine the next point.</p>

                <h3>Step 3: Compute Initial Decision Parameter</h3>
                <p>The initial decision parameter is given by:</p>
                <p class="ms">
                    \[
                    p_0 = 1 - r
                    \]
                </p>
                <p>Substituting \( r = 5 \):</p>
                <p class="ms">
                    \[
                    p_0 = 1 - 5 = -4
                    \]
                </p>

                <h3>Step 4: Compute Points Step by Step</h3>
                <p>We use the decision rule:</p>
                <ul>
                    <li><strong>If \( p_k < 0 \):</strong> Next point is \( (x+1, y) \), update \( p \) using:
                                <p class="ms">
                                    \[
                                    p_{\text{new}} = p + 2x + 3
                                    \]
                                </p>
                    </li>
                    <li><strong>If \( p_k \geq 0 \):</strong> Next point is \( (x+1, y-1) \), update \( p \) using:
                        <p class="ms">
                            \[
                            p_{\text{new}} = p + 2x - 2y + 5
                            \]
                        </p>
                    </li>
                </ul>

                <h3>Step-by-Step Calculations</h3>
                <p>Starting from \( (0,5) \):</p>

                <ul>
                    <li><strong>Step 1:</strong> We start with \( p_0 = -4 \), which is calculated using the formula \(
                        p_0 = 1 - r \) where \( r = 5 \).
                        <p>At this point, the current values of \( x = 0 \) and \( y = 5 \). Since \( p_0 < 0 \), we
                                move horizontally to the right, meaning the next point will be \( (x+1, y)=(1, 5) \),
                                and we update the decision parameter:</p>
                                <p class="ms">\( p_1 = p_0 + 2x + 3 = -4 + 2(0) + 3 = -1 \)</p>
                    </li>

                    <li><strong>Step 2:</strong> Now we have \( p_1 = -1 \), and the current values of \( x = 1 \) and
                        \( y = 5 \). Since \( p_1 < 0 \), we again move horizontally to the right, meaning the next
                            point will be \( (x+1, y)=(2, 5) \). We update the decision parameter:</p>
                            <p class="ms">\( p_2 = p_1 + 2x + 3 = -1 + 2(1) + 3 = 4 \)</p>
                    </li>

                    <li><strong>Step 3:</strong> Now we have \( p_2 = 4 \), and the current values of \( x = 2 \) and \(
                        y = 5 \). Since \( p_2 \geq 0 \), we move diagonally, meaning the next point will be \( (x+1,
                        y-1) = (3, 4) \). We then update the decision parameter:</p>
                        <p class="ms">\( p_3 = p_2 + 2x - 2y + 5 = 4 + 2(2) - 2(5) + 5 = 3 \)</p>
                    </li>

                    <li><strong>Step 4:</strong> Now we have \( p_3 = 3 \), and the current values of \( x = 3 \) and \(
                        y = 4 \). Since \( p_3 \geq 0 \), we again move diagonally, meaning the next point will be \(
                        (x+1, y-1) = (4, 3) \). However, since \( x = 4 \) and \( y = 3 \), we stop the algorithm here
                        as the condition \( x \geq y \) is satisfied (we have completed one-eighth of the circle). </p>
                    </li>
                </ul>


                <h3>Final Points</h3>
                <pre>
                    <code>
  x  |  y
--+--
  0  |  5
  1  |  5
  2  |  5
  3  |  4
  4  |  3
                    </code>
                </pre>

                <p>These points are calculated for one-eighth of the circle.</p>
            </div>

        </div>
        <div class="wh">
            <h2>Clipping</h2>
            <ul>
                <li>
                    Clipping is a process used in computer graphics to display only the portion of an object that lies
                    within a defined region known as the <strong>clipping window</strong>. The clipping window is
                    typically a rectangle on the XY-plane. Any part of the object (such as lines, shapes, or diagrams)
                    that lies outside this window is discarded and not displayed. This process helps in rendering only
                    the visible content, improving performance and visual clarity.
                </li>
            </ul>
            <img class="wb" src="../../images/cg7.svg" alt="Clipping concept illustration">

            <div class="in">
                <h3>Point Clipping</h3>
                <ul>
                    <li>In point clipping, we work specifically with individual points rather than lines or shapes.</li>
                    <li>We determine whether a given point lies inside or outside the clipping window.</li>
                    <li>
                        For example, consider two points: P1 (x₁, y₁) and P2 (x₂, y₂). If P1 is outside the clipping
                        window and P2 is inside, we need a method to confirm this based on their coordinates.
                    </li>
                </ul>
                <img src="../../images/cg8.svg" alt="Point clipping example" class="wb">

                <ul>
                    <li>
                        To determine if a point lies inside the rectangular window, we use the boundary values:
                        <strong>x<sub>min</sub>, x<sub>max</sub>, y<sub>min</sub>, and y<sub>max</sub></strong>.
                    </li>
                </ul>
                <img src="../../images/cg9.svg" alt="Window boundaries for clipping" class="wb">

                <ul>
                    <li>
                        If a point satisfies all four boundary conditions, it is considered inside the window.
                        Otherwise, it is outside. Let the point be P(x, y). The conditions are:
                        <ol>
                            <li>x ≥ x<sub>min</sub></li>
                            <li>x ≤ x<sub>max</sub></li>
                            <li>y ≥ y<sub>min</sub></li>
                            <li>y ≤ y<sub>max</sub></li>
                        </ol>
                    </li>
                </ul>

                <p><strong>Numerical:</strong> Consider two points: P1 (5, 1) and P2 (6, 9), and a clipping window with
                    the following boundaries:</p>
                <ul>
                    <li>x<sub>min</sub> = 2</li>
                    <li>x<sub>max</sub> = 9</li>
                    <li>y<sub>min</sub> = 3</li>
                    <li>y<sub>max</sub> = 11</li>
                </ul>
                <img src="../../images/cg10.svg" alt="Numerical example for point clipping" class="wb">

                <p><strong>Solution:</strong> Evaluate point P1 (5, 1):</p>
                <ol>
                    <li>5 ≥ 2 → True</li>
                    <li>5 ≤ 9 → True</li>
                    <li>1 ≥ 3 → False</li>
                </ol>
                <p>Since one condition is false, P1 is outside the clipping window.</p>

                <p>Now evaluate point P2 (6, 9):</p>
                <ol>
                    <li>6 ≥ 2 → True</li>
                    <li>6 ≤ 9 → True</li>
                    <li>9 ≥ 3 → True</li>
                    <li>9 ≤ 11 → True</li>
                </ol>
                <p>All conditions are satisfied, so P2 lies inside the clipping window.</p>
            </div>
            <div class="in">
                <h3>Line Clipping (Cohen–Sutherland Algorithm)</h3>
                <ul>
                    <li>The Cohen–Sutherland algorithm is used to clip lines to a rectangular clipping window. The goal
                        is to identify which portion of a line lies within the window and discard the portion that lies
                        outside.</li>
                </ul>
                <img class="wb" src="../../images/cg13.svg" alt="Basic concept of line clipping">

                <ul>
                    <li>To determine which part of the line is inside the clipping window, we use a 4-bit region code,
                        also known as the TBRL code — representing Top, Bottom, Right, and Left. Each bit indicates
                        whether the point lies outside the respective boundary.</li>
                    <li>In the diagram below, the entire 2D plane is divided into 9 regions. The central region (region
                        6) represents the clipping window.</li>
                </ul>
                <img src="../../images/cg11.svg" alt="9-region code layout for clipping" class="wb">

                <ul>
                    <li>
                        Each region is assigned a unique 4-bit code based on its position relative to the clipping
                        window. The code for the center region (inside the window) is <code>0000</code>, meaning the
                        point lies within all four boundaries.
                    </li>
                </ul>
                <img class="wb" src="../../images/cg12.svg" alt="Region codes with respect to center window">

                <ul>
                    <li>
                        There are three possible cases for any line segment:
                        <ol>
                            <li>
                                <strong>Completely Inside:</strong> A line with both endpoints having the region code
                                <code>0000</code> lies entirely within the clipping window. No clipping is needed.
                                <br>
                                <img class="wb" src="../../images/cg14.svg" alt="Line completely inside">
                            </li>
                            <li>
                                <strong>Completely Outside:</strong> If both endpoints of the line lie in the same
                                region outside the window and share a common set bit in their region codes, the result
                                of the bitwise AND operation is non-zero. This means the line is completely outside and
                                can be rejected.
                                <pre>
<code>
  0001
& 0001
-
  0001
</code>
                </pre>
                                <img src="../../images/cg15.svg" class="wb" alt="Line completely outside">
                            </li>
                            <li>
                                <strong>Partially Inside (Intersecting):</strong> One endpoint lies inside the clipping
                                window (region code <code>0000</code>), and the other lies outside (non-zero region
                                code). In this case, the line intersects the boundary of the window, and clipping must
                                be performed. <br>
                                <img src="../../images/cg16.svg" class="wb" alt="Partially inside or outside">
                            </li>
                        </ol>
                    </li>

                    <li>
                        While the completely inside and completely outside cases are straightforward, the partially
                        inside case requires more work. You must calculate the intersection point of the line with the
                        clipping window boundary. This intersection point is used to trim the portion of the line that
                        lies outside the window.
                        <br>
                        Based on the diagram below, we retain the line from the intersection point (x′, y′) to the
                        endpoint inside the window and discard the portion from the external point to (x′, y′).
                        <br>
                        <img src="../../images/cg17.svg" alt="Finding intersection points" class="wb">
                    </li>
                </ul>
                <h3>Numerical Example: Line Clipping Through Three Regions (Left → Inside → Top)</h3>

                <ul>
                    <li><strong>Clipping Window Boundaries:</strong></li>
                    <ul>
                        <li>\( x_{\min} = 2 \)</li>
                        <li>\( x_{\max} = 8 \)</li>
                        <li>\( y_{\min} = 2 \)</li>
                        <li>\( y_{\max} = 6 \)</li>
                    </ul>

                    <li><strong>Given Line Endpoints:</strong></li>
                    <ul>
                        <li>Point A: \( (0, 3) \) → Region code: <code>0001</code> (Left)</li>
                        <li>Point B: \( (7, 7) \) → Region code: <code>1000</code> (Top)</li>
                    </ul>
                </ul>
                <img src="../../images/cg18.svg" alt="" class="wb">

                <h4>Step 1: Calculate the slope of the line (m)</h4>
                <p>
                    \[
                    m = \frac{y_2 - y_1}{x_2 - x_1} = \frac{7 - 3}{7 - 0} = \frac{4}{7}
                    \]
                </p>



                <h4>Step 2: Clip Point A (Left Region: <strong>0001</strong>) against Left Boundary \( x = 2 \)</h4>
                <p>We use the vertical clipping formula to find the new y-coordinate:</p>
                <p>
                    \[
                    y' = y_1 + m \cdot (x_{\text{clip}} - x_1)
                    \]
                    \[
                    y' = 3 + \frac{4}{7} \cdot (2 - 0) = 3 + \frac{8}{7} = \frac{29}{7} \approx 4.14
                    \]
                </p>
                <p>New intersection point A′ is: \( (2, 4.14) \)</p>



                <h4>Step 3: Clip Point B (Top Region: <code>1000</code>) against Top Boundary \( y = 6 \)</h4>
                <p>Now use the horizontal clipping formula to find the new x-coordinate:</p>
                <p>
                    \[
                    x' = x_2 + \frac{1}{m} \cdot (y_{\text{clip}} - y_2)
                    \]
                    \[
                    x' = 7 + \frac{1}{\frac{4}{7}} \cdot (6 - 7) = 7 - \frac{7}{4} = \frac{21}{4} = 5.25
                    \]
                </p>
                <p>New intersection point B′ is: \( (5.25, 6) \)</p>



                <h4>Final Clipped Line Segment</h4>
                <ul>
                    <li>Start: \( A′ = (2, 4.14) \)</li>
                    <li>End: \( B′ = (5.25, 6) \)</li>
                </ul>
                <p>This visible segment lies entirely within the clipping window. The original segment went through:</p>
                <ol>
                    <li><strong>Left</strong> — point A was outside on the left</li>
                    <li><strong>Inside</strong> — clipped segment \( A′ \to B′ \)</li>
                    <li><strong>Top</strong> — point B was outside the top boundary</li>
                </ol>

            </div>
            <div class="in">
                <h3>Polygon Clipping</h3>

                <ul>
                    <li>
                        <strong>Polygon clipping</strong> refers to the process of removing (or "clipping") the parts of
                        a polygon that lie outside a defined clipping window, typically a rectangular region.
                    </li>
                </ul>

                <img src="../../images/cg19.svg" class="wb" alt="Left, Right, Top, Bottom Clipping Diagram">

                <ul>
                    <li>
                        In the above diagram, polygon clipping is performed sequentially — we apply clipping against one
                        boundary at a time: Left, Right, Top, and Bottom.
                    </li>
                    <li>
                        Let's begin with <strong>left clipping</strong>. We conceptually draw a vertical boundary line
                        at \( x = x_{\min} \). Everything to the left of this boundary is considered
                        <strong>outside</strong> the window and is discarded. Everything to the right is
                        <strong>inside</strong> and is retained.
                    </li>
                    <li>
                        We repeat this process for the remaining boundaries:
                        <ul>
                            <li><strong>Right Clipping</strong>: Remove parts of the polygon where \( x > x_{\max} \)
                            </li>
                            <li><strong>Top Clipping</strong>: Remove parts where \( y > y_{\max} \)</li>
                            <li><strong>Bottom Clipping</strong>: Remove parts where \( y < y_{\min} \)</li>
                        </ul>
                    </li>
                    <li>
                        After clipping against all four sides, the final result is the portion of the polygon that lies
                        entirely within the rectangular window.
                    </li>
                </ul>

                <ul>
                    <li>
                        During the clipping process, whenever a polygon edge crosses a window boundary, an
                        <strong>intersection point</strong> is calculated. These intersection points become new vertices
                        of the clipped polygon.
                    </li>
                    <li>
                        The algorithm most commonly used for polygon clipping is the <strong>Sutherland–Hodgman polygon
                            clipping algorithm</strong>, which works by processing one window edge at a time and
                        outputting the resulting polygon step-by-step.
                    </li>
                </ul>

                <img src="../../images/cg20.svg" alt="Polygon Clipping Example Output" class="wb">
                <p>
                    In the process of polygon clipping, we evaluate each edge (line segment) of the polygon based on how its two endpoints — vertex \( v_1 \) and vertex \( v_2 \) — relate to the current clipping boundary.
                    Each edge can fall into one of four possible cases:
                </p>
                
                <ol>
                    <li>
                        <strong>Case 1: Outside to Inside (v₁ is outside, v₂ is inside)</strong><br>
                        The line segment enters the clipping window. In this case, we calculate the <strong>intersection point \( v_1' \)</strong> with the clipping boundary and also include \( v_2 \) (since it's inside).<br>
                        <strong>Output:</strong> \( v_1', v_2 \)
                    </li>
                
                    <li>
                        <strong>Case 2: Inside to Outside (v₁ is inside, v₂ is outside)</strong><br>
                        The line segment exits the clipping window. We compute the <strong>intersection point \( v_2' \)</strong>, but we do not include \( v_2 \) (since it’s outside).<br>
                        <strong>Output:</strong> \( v_2' \)
                    </li>
                
                    <li>
                        <strong>Case 3: Inside to Inside (both v₁ and v₂ are inside)</strong><br>
                        The entire edge is within the clipping window, so we keep the second vertex \( v_2 \) as part of the output polygon.<br>
                        <strong>Output:</strong> \( v_2 \)
                    </li>
                
                    <li>
                        <strong>Case 4: Outside to Outside (both v₁ and v₂ are outside)</strong><br>
                        The edge lies completely outside the clipping boundary, so it does not contribute to the output polygon.<br>
                        <strong>Output:</strong> Nothing
                    </li>
                </ol>
                
                <p>
                    This case-by-case approach is applied repeatedly for each edge of the polygon as it is clipped against each boundary (Left, Right, Top, Bottom).
                    The output polygon at each stage becomes the input for the next boundary.
                </p>
                
            </div>
        </div>

    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://youtu.be/0PgMv8sdXtg?si=VlsQV54bnHx0upso" target="_blank">3.4- DDA Line Drawing
                    Algorithm In Computer Graphics Hindi | Digital Differential Analyzer Youtube Lecture &neArr;</a>
            </li>
            <li><a href="https://www.youtube.com/watch?v=Sm7oUNq2rSM" target="_blank">Mid Point Circle Drawing Youtube
                    Video Lecture &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=J7OS_nI4W7Y" target="_blank">Point Clipping Explained in Hindi
                    l Computer Graphics Video Lecture &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=MkMK8LvLOjs" target="_blank">Cohen Sutherland Line Clipping
                    Algorithm Video Lecture &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=2Egy6PFehtU" target="_blank">Sutherland Hodgeman Polygon
                    Clipping Algorithm Video Lecture &neArr;</a></li>
        </ul>
    </div>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="module" src="../../../../public/main.js"></script>
</body>

</html>
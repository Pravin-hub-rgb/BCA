<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Graphics Programs Basics</title>
    <link rel="icon" href="../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" href="../../../public/style.css">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body>
    <div id="navbar" class="grad">
        <div class="back">
            <a href="./index.html"><img src="../../../public/back.svg" alt=""></a>
        </div>
        <div>
            <h2>Computer Graphics Program Basics</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Computer Graphics Program Basics</h1>
        <div class="wh">
            <h3>Setting Up a Basic Graphics Environment:</h3>
            <ul>
                <li>
                    First, we need to include the <strong>graphics.h</strong> header file. It is an old graphics library
                    used in C programming,
                    especially in older compilers like Turbo C. This library provides functions that let you draw things
                    like points, lines, circles,
                    and shapes directly on the screen.
                </li>
                <li>Before we start drawing anything, we need to set up a basic environment where we can render
                    graphics.</li>
                <li>
                    <strong>Initialize the Graphics Mode:</strong> To open a graphics window and start drawing, we use
                    the <strong>initgraph()</strong> function.
                    <pre>
                        <code>
int gd = DETECT, gm;
initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");
                        </code>
                    </pre>
                    This will set up a graphics window for you to draw in.
                    <ul>
                        <li>Here, <strong>gd</strong> stands for graphics driver, and <strong>gm</strong> stands for
                            graphics mode.</li>
                        <li><strong>DETECT</strong> is a macro defined in the <strong>graphics.h</strong> library. It is
                            not a keyword in the C language itself
                            but a constant used by the graphics system.</li>
                        <li><strong>DETECT</strong> automatically detects the graphics driver on your system, so you
                            don’t have to manually specify one.
                            This makes it easier for the program to run on different systems.</li>
                        <li><strong>gm</strong> will store the mode of the graphics system once it's initialized. It
                            doesn't require a specific value;
                            it gets set by the <strong>initgraph()</strong> function.</li>
                        <li>When passed to <strong>initgraph()</strong>, <strong>DETECT</strong> tells the program to
                            automatically detect the graphics driver
                            based on your system’s configuration. This eliminates the need for you to manually specify
                            the graphics driver.</li>
                    </ul>
                </li>
                <li>
                    <strong>Setting Up Graphics in Turbo C3:</strong>
                    <ul>
                        <li>If you are using <strong>Turbo C3</strong>, ensure that the <strong>BGI (Borland Graphics
                                Interface) files</strong> are present in the correct directory.</li>
                        <li>The default path in Turbo C3 is: <code>"C:\\TURBOC3\\BGI"</code>.</li>
                        <li>If the path is incorrect, Turbo C3 may throw an error when initializing graphics.</li>
                    </ul>
                </li>
                <li>
                    <strong>Common Errors and Fixes in Turbo C3:</strong>
                    <ul>
                        <li><strong>BGI Error: "Graphics not initialized"</strong>
                            <ul>
                                <li>Ensure that the BGI files exist in the specified path.</li>
                                <li>Try providing the full path explicitly instead of an empty string.</li>
                            </ul>
                        </li>
                        <li><strong>Error: "Cannot run in full-screen mode" (on modern systems)</strong>
                            <ul>
                                <li>Turbo C3 is a DOS-based compiler and does not support full-screen graphics in modern
                                    Windows versions.</li>
                                <li>Use <strong>DOSBox</strong> to run Turbo C3 properly.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Exiting Graphics Mode Properly in Turbo C3:</strong>
                    <pre>
                        <code>
closegraph();
                        </code>
                    </pre>
                    <ul>
                        <li>Always call <strong>closegraph();</strong> at the end of your program to properly exit
                            graphics mode and return to text mode.</li>
                        <li>Failing to do this may leave your system screen in an unstable state.</li>
                    </ul>
                </li>

                <li>
                    <strong>Closing the Graphics Mode:</strong> Once you are done with drawing, you should close the
                    graphics mode using the
                    <strong>closegraph()</strong> function.
                    <pre>
                        <code>
closegraph();
                        </code>
                    </pre>
                    <ul>
                        <li><strong>closegraph()</strong> shuts down the graphics system and deallocates any memory used
                            for graphics.</li>
                        <li>It ensures that the system returns to text mode properly after graphics operations are
                            completed.</li>
                        <li>Failing to call <strong>closegraph()</strong> may leave the screen in an unpredictable
                            state, especially in older systems.</li>
                    </ul>
                </li>
            </ul>
            <h3>Program to draw a pixel</h3>
            <p>Now that we understand the basics of graphics in C, we will start by drawing a point on the screen.
                The following program demonstrates how to draw a pixel.</p>
            <pre>
                <code>
#include &lt;graphics.h&gt;  // Graphics library for drawing
#include &lt;conio.h&gt;     // Console input-output library for getch()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and store graphics mode

    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");  // Initialize graphics system

    putpixel(200, 200, WHITE);  // Draw a white pixel at (200, 200)

    getch();  // Wait for user input before closing
    closegraph();  // Close the graphics window

    return 0;  // Return success
}
                </code>
            </pre>
            <p>Explanation of the code:</p>
            <ul>
                <li>#include &lt;graphics.h&gt;
                    <ul>
                        <li>This is a special graphics library that allows us to draw points, lines, shapes, and colors
                            in C.</li>
                        <li>It’s not a standard C library—you need to install it separately if you're using GCC on
                            Linux or other non-Turbo C compilers.</li>
                        <li>Functions like initgraph(), putpixel(), and closegraph() come from this library.</li>
                    </ul>
                </li>
                <li>#include &lt;conio.h&gt;
                    <ul>
                        <li>This is the console input-output library in C.</li>
                        <li>We included this because we need to use getch(), which waits for user input before closing
                            the graphics window.</li>
                        <li>It replaces stdio.h for functions like getch() that are specific to console-based
                            operations.</li>
                    </ul>
                </li>
                <li>int gd = DETECT, gm; (Variables for Graphic Mode)
                    <ul>
                        <li>gd stands for Graphics Driver.</li>
                        <li>gm stands for Graphics Mode.</li>
                        <li>DETECT is a macro (predefined constant) in graphics.h that tells the compiler to
                            automatically detect the best graphics driver available.</li>
                        <li>gm is an integer variable that will store the graphics mode (like resolution or color
                            depth).</li>
                    </ul>
                </li>
                <li>initgraph(&gd, &gm, "C:\\TURBOC3\\BGI"); (Initializing the Graphics System)
                    <ul>
                        <li>initgraph() is the function that starts the graphics mode.</li>
                        <li>It takes three arguments:
                            <ol>
                                <li>&gd → The address of the gd variable (so it can store the detected graphics driver).
                                </li>
                                <li>&gm → The address of the gm variable (so it can store the detected graphics mode).
                                </li>
                                <li>"C:\\TURBOC3\\BGI" → This is the path to the graphics driver files used by Turbo C3.
                                    On older systems, this path is required to locate the graphics drivers. On modern
                                    systems, however, this path may not be needed if you're using an emulator or a
                                    different graphics setup.</li>
                            </ol>
                        </li>
                        <li>What happens after calling initgraph()?
                            <ul>
                                <li>The system enters graphics mode.</li>
                                <li>A new graphics window opens where we can start drawing.</li>
                                <li>The graphics driver and mode are selected based on the provided path and system
                                    configuration.</li>
                            </ul>
                        </li>
                    </ul>
                </li>

                <li>putpixel(200, 200, WHITE); (Drawing a Pixel)
                    <ul>
                        <li>putpixel(x, y, color) is a function that draws a single pixel on the screen.</li>
                        <li>Arguments:
                            <ul>
                                <li>x = 200 → The horizontal position (200 pixels from the left).</li>
                                <li>y = 200 → The vertical position (200 pixels from the top).</li>
                                <li>WHITE → This is a predefined color constant in graphics.h.</li>
                            </ul>
                        </li>
                        <li>How does the coordinate system work?
                            <ul>
                                <li>The top-left corner of the screen is (0,0).</li>
                                <li>The x-axis increases to the right, and the y-axis increases downward.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>getch(); (Waiting for User Input)
                    <ul>
                        <li>When the program finishes running, the graphics window will close immediately unless we
                            pause it.</li>
                        <li>getch(); waits for the user to press any key, keeping the graphics window open.</li>
                        <li>This is a function from conio.h, commonly used in Turbo C. It allows pausing the program
                            until
                            a key is pressed. (Alternately, you can use getchar() in place of getch()).</li>
                    </ul>
                </li>
                <li>closegraph();
                    <ul>
                        <li>It closes the graphics window and returns to normal text mode.</li>
                        <li>Without this function, the program might leave the system in an unstable graphics state.
                        </li>
                    </ul>
                </li>
            </ul>

            <h3>Drawing a Horizontal Line</h3>
            <p>Now that we understand how to display a single pixel, let’s move to the next step: drawing a
                horizontal
                line.</p>
            <p><strong>Concept of Drawing a Horizontal Line</strong></p>
            <ul>
                <li>A horizontal line means all the y-coordinates remain the same, while the x-coordinates change
                    from a
                    starting point to an ending point.</li>
                <li>For example:
                    <ul>
                        <li>If we want a line from (100, 200) to (300, 200):
                            <ul>
                                <li>y = 200 remains constant.</li>
                                <li>x changes from 100 to 300.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <p><strong>Program to Draw a Horizontal Line</strong></p>
            <pre>
                <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x1 = 100, x2 = 300, y = 200;  // Start and end points of the line

    for (int x = x1; x <= x2; x++) {
        putpixel(x, y, WHITE);  // Draw white pixels along the x-axis
    }

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                </code>
            </pre>
            <p>output:</p>
            <img src="../images/cg3.png" alt="">
            <p><strong>Program to Draw a Vertical Line</strong>: Here the x coordinate will remain same while y
                coordinate will change.</p>
            <pre>
                <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x = 200, y1 = 100, y2 = 300;  // Starting and ending y-coordinates

    for (int y = y1; y <= y2; y++) {
        putpixel(x, y, WHITE);  // Draw white pixels along the y-axis
    }

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                </code>
            </pre>
            <p>Output:</p>
            <img src="../images/cg4.png" alt="">
            <h3>Drawing line using line() function</h3>
            <p><strong>The line() Function</strong></p>
<p>The line() function is part of the graphics.h library and allows you to draw a straight line between two points by specifying their coordinates.</p>

<p>Syntax of line()</p>
<pre>
    <code>
line(int x1, int y1, int x2, int y2);
    </code>
</pre>

<p>Where:
<ul>
    <li>(x1, y1) is the starting point of the line.</li>
    <li>(x2, y2) is the ending point of the line.</li>
</ul>
</p>

<p>How It Works:</p>
<ul>
    <li>You don’t need to manually plot each point to draw a line.</li>
    <li>Simply call line() with the starting and ending coordinates, and the function will automatically draw the line.</li>
</ul>

<div class="code">
    <div class="dotc"></div>
    <button class="ac">
        Example Program to Draw a Line Using line()
    </button>
    <div class="panel">
        <pre>
        <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x1 = 100, y1 = 100;  // Starting point of the line
    int x2 = 300, y2 = 300;  // Ending point of the line

    line(x1, y1, x2, y2);  // Draw the line

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
        </code>
        </pre>
    </div>
</div>

            <h3>Program to Draw a Square</h3>
            <div class="code">
                <div class="dotc"></div>
                <button class="ac">Using Putpixel function</button>
                <div class="panel">
                    <pre>
                        <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x1 = 100, y1 = 100;   // Top-left corner of the square
    int side_length = 200;     // Length of the side of the square

    // Draw top side (horizontal line)
    for (int x = x1; x <= x1 + side_length; x++) {
        putpixel(x, y1, WHITE);  // Draw white pixels
    }

    // Draw right side (vertical line)
    for (int y = y1; y <= y1 + side_length; y++) {
        putpixel(x1 + side_length, y, WHITE);  // Draw white pixels
    }

    // Draw bottom side (horizontal line)
    for (int x = x1; x <= x1 + side_length; x++) {
        putpixel(x, y1 + side_length, WHITE);  // Draw white pixels
    }

    // Draw left side (vertical line)
    for (int y = y1; y <= y1 + side_length; y++) {
        putpixel(x1, y, WHITE);  // Draw white pixels
    }

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                        </code>
                    </pre>
                </div>
            </div>

            <p> In graphics.h, there is a built-in function to draw rectangles directly, which makes things a lot
                simpler
                compared to manually drawing each side using loops.</p>
            <p><strong>The rectangle() Function</strong></p>
            <p>The rectangle() function is part of the graphics.h library and allows you to easily draw a rectangle
                by
                just
                specifying two opposite corners (top-left and bottom-right).</p>
            <p>Syntax of rectangle()</p>
            <pre>
                <code>
rectangle(int x1, int y1, int x2, int y2);
                </code>
            </pre>
            <p>Where:
            <ul>
                <li>(x1, y1) is the top-left corner of the rectangle.</li>
                <li>(x2, y2) is the bottom-right corner of the rectangle.</li>
            </ul>
            </p>
            <p>How It Works:</p>
            <ul>
                <li>You don’t need to manually draw the four sides of the rectangle using loops.</li>
                <li>Simply call rectangle() with the two corner coordinates, and the function will automatically
                    draw
                    the
                    rectangle for you.</li>
            </ul>
            <div class="code">
                <div class="dotc"></div>
                <button class="ac">
                    Example Program to Draw a Square Using rectangle()
                </button>
                <div class="panel">
                    <pre>
                    <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x1 = 100, y1 = 100;  // Top-left corner of the square
    int side_length = 200;    // Length of the side of the square

    // Bottom-right corner will be (x1 + side_length, y1 + side_length)
    rectangle(x1, y1, x1 + side_length, y1 + side_length);  // Draw the square

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                    </code>
                </pre>
                </div>
            </div>
            <p><strong>The circle() Function</strong></p>
            <p>The <strong>circle()</strong> function is part of the <strong>graphics.h</strong> library and allows
                you
                to
                easily draw a circle by just specifying the center and radius.</p>

            <p>Syntax of circle()</p>
            <pre>
                <code>
circle(int x, int y, int radius);
                </code>
            </pre>
            <p>Where:</p>
            <ul>
                <li>(x, y) is the center of the circle.</li>
                <li><code>radius</code> is the distance from the center to the edge of the circle.</li>
            </ul>

            <p>How It Works:</p>
            <ul>
                <li>You don’t need to manually calculate points on the circle.</li>
                <li>Simply call <code>circle()</code> with the center coordinates and radius, and the function will
                    automatically draw the circle for you.</li>
            </ul>

            <div class="code">
                <div class="dotc"></div>
                <button class="ac">
                    Example Program to Draw a Circle Using circle()
                </button>
                <div class="panel">
                    <pre>
                    <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x = 200, y = 200;  // Center of the circle
    int radius = 100;      // Radius of the circle

    circle(x, y, radius);  // Draw the circle

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                    </code>
                </pre>
                </div>
            </div>
            <p><strong>The ellipse() Function</strong></p>
            <p>The <strong>ellipse()</strong> function is part of the <strong>graphics.h</strong> library and allows
                you
                to
                easily draw an ellipse by specifying the center, axes, and angle.</p>

            <p>Syntax of ellipse()</p>
            <pre>
            <code>
ellipse(int x, int y, int startAngle, int endAngle, int xRadius, int yRadius);
            </code>
        </pre>

            <p>Where:</p>
            <ul>
                <li>(x, y) is the center of the ellipse.</li>
                <li><strong>startAngle</strong> is the starting angle (in degrees) where drawing begins.</li>
                <li><strong>endAngle</strong> is the ending angle (in degrees) where drawing stops.</li>
                <li><strong>xRadius</strong> is the horizontal radius (width of the ellipse).</li>
                <li><strong>yRadius</strong> is the vertical radius (height of the ellipse).</li>
            </ul>

            <p>How It Works:</p>
            <ul>
                <li>If you want a full ellipse, set <strong>startAngle = 0</strong> and <strong>endAngle =
                        360</strong>.
                </li>
                <li>You can use different values for <strong>xRadius</strong> and <strong>yRadius</strong> to create
                    stretched
                    or squished ellipses.</li>
                <li>The function automatically handles the calculations, so you just need to specify the parameters.
                </li>
            </ul>

            <div class="code">
                <div class="dotc"></div>
                <button class="ac">
                    Example Program to Draw an Ellipse Using ellipse()
                </button>
                <div class="panel">
                    <pre>
                    <code>
#include &lt;graphics.h>  // Graphics library for drawing
#include &lt;conio.h>     // For getchar()

int main() {
    int gd = DETECT, gm;  // Detect graphics driver and mode

    initgraph(&gd, &gm, "");  // Initialize graphics mode

    int x = 250, y = 250;  // Center of the ellipse
    int xRadius = 150, yRadius = 100;  // Horizontal and vertical radius

    ellipse(x, y, 0, 360, xRadius, yRadius);  // Draw a full ellipse

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
                    </code>
                </pre>
                </div>
            </div>

        </div>
        <div class="wh">
            <h2>Line Drawing</h2>
            <div class="in">
                <h3>DDA (Digital Differential Analyzer)</h3>
                <p>
                    The <strong>Digital Differential Analyzer (DDA) Algorithm</strong> gets its name from its underlying
                    principles. The term <strong>"Digital"</strong> refers to the fact that this algorithm operates in a
                    discrete digital space, meaning it works with pixel positions rather than continuous mathematical
                    functions. The term <strong>"Differential"</strong> comes from the way the algorithm incrementally
                    calculates the next point in the line using small differences (\( dx \) and \( dy \)) rather than
                    solving an equation directly. Finally, <strong>"Analyzer"</strong> is derived from early analog
                    computing methods, where a <strong>Differential Analyzer</strong> was a mechanical device used for
                    solving differential equations. The DDA algorithm follows a similar approach but in a digital
                    manner, analyzing and computing the next pixel position step by step. This makes it an efficient and
                    systematic way to draw lines in computer graphics.
                </p>

                <div class="wh compact-extended">
                    <div class="compact">
                        <p><strong>Step-by-Step Algorithm:</strong></p>
                        <ul>


                            <li><strong>Take Input:</strong></li>
                            <ul>
                                <li>Read the starting point \( (x_1, y_1) \) and the ending point \( (x_2, y_2) \).</li>
                            </ul>

                            <li><strong>Calculate the Differences:</strong></li>
                            <ul>
                                <li>Compute the change in \( x \) and \( y \):</li>
                                <ul>
                                    <li>\( dx = x_2 - x_1 \)</li>
                                    <li>\( dy = y_2 - y_1 \)</li>
                                </ul>
                            </ul>

                            <li><strong>Determine the Number of Steps:</strong></li>
                            <ul>
                                <li>The number of steps is the maximum of \( |dx| \) and \( |dy| \), which ensures
                                    smooth pixel plotting:</li>
                                <ul>
                                    <li>\( \text{steps} = \max(|dx|, |dy|) \)</li>
                                </ul>
                            </ul>

                            <li><strong>Compute the Increment Values:</strong></li>
                            <ul>
                                <li>Compute the increments for \( x \) and \( y \) to move step by step:</li>
                                <ul>
                                    <li>\( x_{\text{inc}} = \frac{dx}{\text{steps}} \)</li>
                                    <li>\( y_{\text{inc}} = \frac{dy}{\text{steps}} \)</li>
                                </ul>
                            </ul>

                            <li><strong>Initialize Starting Position:</strong></li>
                            <ul>
                                <li>Set the starting point:</li>
                                <ul>
                                    <li>\( x = x_1, y = y_1 \)</li>
                                </ul>
                            </ul>

                            <li><strong>Plot the Pixels:</strong></li>
                            <ul>
                                <li>Repeat for \( \text{steps} \) iterations:</li>
                                <ul>
                                    <li>Plot the pixel at the current \( (x, y) \) position using:</li>
                                    <ul>
                                        <li>\( \text{putpixel}(\text{round}(x), \text{round}(y), \text{WHITE}) \)</li>
                                    </ul>
                                    <li>Update \( x \) and \( y \):</li>
                                    <ul>
                                        <li>\( x = x + x_{\text{inc}} \)</li>
                                        <li>\( y = y + y_{\text{inc}} \)</li>
                                    </ul>
                                </ul>
                            </ul>

                            <li><strong>End of Algorithm:</strong></li>
                            <ul>
                                <li>The loop completes, and the full line is drawn from \( (x_1, y_1) \) to \( (x_2,
                                    y_2) \).</li>
                            </ul>
                        </ul>
                    </div>
                    <div class="extended">
                        <p><strong>Step-by-Step Algorithm:</strong></p>
                        <ul>
                            <li><strong>Step 1: Understand the Goal</strong></li>
                            <ul>
                                <li>You want to draw a line between two points on the screen, for example, from point
                                    (x1, y1)
                                    to (x2, y2). Imagine a grid of squares (like pixels on the screen), and your job is
                                    to
                                    calculate which squares (pixels) to color so that they form a straight line between
                                    the two
                                    points.</li>
                            </ul>

                            <li><strong>Step 2: Calculate the differences (dx and dy)</strong></li>
                            <ul>
                                <li>First, you need to know how far the line goes in both the x direction (left to
                                    right) and
                                    the y direction (up to down). You calculate the differences as follows:</li>
                                <ul>
                                    <li>dx = x2 - x1 (the horizontal difference)</li>
                                    <li>dy = y2 - y1 (the vertical difference)</li>
                                </ul>
                                <li>These values tell you how much the line moves horizontally and vertically.</li>
                            </ul>

                            <li><strong>Step 3: Determine the number of steps</strong></li>
                            <ul>
                                <li>Now, the next thing you need to figure out is how many steps it will take to draw
                                    the line
                                    from the start to the end point. This depends on which direction the line moves
                                    more—horizontal or vertical. In other words, the line might be steeper (more
                                    vertical) or
                                    flatter (more horizontal).</li>
                                <li>To figure out how many steps, you take the larger of the two differences (dx and
                                    dy):</li>
                                <ul>
                                    <li>Steps = max(dx, dy)</li>
                                </ul>
                                <li>This ensures that you take enough steps to cover the longest direction, whether it's
                                    horizontal or vertical.</li>
                            </ul>

                            <li><strong>Step 4: Calculate the increment for each step</strong></li>
                            <ul>
                                <li>Now that you know how many steps you need, you need to figure out how much to move
                                    horizontally (x) and vertically (y) at each step. You calculate the increments like
                                    this:
                                </li>
                                <ul>
                                    <li>x increment = dx / steps</li>
                                    <li>y increment = dy / steps</li>
                                </ul>
                                <li>These increments tell you how much you should increase x and y by for each step you
                                    take.
                                    For example, if dx is 4 and dy is 2, and you decide to take 4 steps, the x increment
                                    would
                                    be 1 (4 / 4), and the y increment would be 0.5 (2 / 4). This means, with each step,
                                    you
                                    increase x by 1 and y by 0.5.</li>
                            </ul>

                            <li><strong>Step 5: Start plotting the points</strong></li>
                            <ul>
                                <li>Now you can start plotting the points. You begin at the starting point (x1, y1).
                                    From there,
                                    you add the increments to the current x and y values at each step, one step at a
                                    time.</li>
                                <li>For example, if you’re at point (x1, y1), then after the first step, you’ll have:
                                </li>
                                <ul>
                                    <li>new x = x1 + x increment</li>
                                    <li>new y = y1 + y increment</li>
                                </ul>
                                <li>You repeat this process for each step until you reach the end point (x2, y2).</li>
                            </ul>

                            <li><strong>Step 6: Round the values to integers</strong></li>
                            <ul>
                                <li>Since pixels on the screen can only have integer values (you can’t have a "half"
                                    pixel), you
                                    need to round the new x and y values to the nearest whole numbers.</li>
                                <li>This rounding is what makes the line look like it’s following a continuous path but
                                    is
                                    actually drawn pixel by pixel.</li>
                            </ul>

                            <li><strong>Step 7: Plot the pixel</strong></li>
                            <ul>
                                <li>After rounding, you plot the pixel at the new coordinates (x, y) and move to the
                                    next step.
                                </li>
                                <li>Repeat this process until you have plotted all the necessary pixels, and you’ll have
                                    a
                                    straight line from (x1, y1) to (x2, y2)!</li>
                            </ul>
                        </ul>
                    </div>
                </div>

                <h3>How does the DDA algorithm in computer graphics differ from the mathematical DDA approach?</h3>
                <ul>
                    <li>In the mathematical DDA approach, we deal with real numbers and continuous values, which allows
                        for precise calculations of points along a line using the slope equation. This method is ideal
                        for theoretical calculations, where fractional or decimal values are acceptable and represent
                        continuous motion or changes. However, in computer graphics, the situation is different. Since a
                        pixel on a screen can only represent discrete integer coordinates, fractional or decimal values
                        are not possible. Therefore, in the computer graphics version of DDA, we must approximate the
                        line by using integer pixel values, rounding the computed coordinates to the nearest whole
                        number. This ensures that the line is drawn using valid pixel positions on the screen, which can
                        only accept discrete values rather than continuous ones. This adjustment is the main reason why
                        the mathematical approach and the computer graphics approach to DDA differ, despite both being
                        based on the same fundamental concept.</li>
                </ul>
                <p>The <strong>Digital Differential Analyzer (DDA) algorithm</strong> exists in both
                    <strong>mathematical theory</strong> and <strong>computer graphics</strong>, but their
                    implementation and purpose differ. The key difference comes from how they handle <strong>continuous
                        vs. discrete values</strong>.
                </p>

                <h3>1. Mathematical DDA Approach</h3>

                <p>This version of DDA is based on <strong>numerical methods</strong> and is often used in
                    <strong>mathematical analysis and analog computations</strong>. The main idea is to compute
                    <strong>small incremental changes</strong> to approximate a curve or a function over time.
                </p>

                <strong>How It Works:</strong>
                <ul>
                    <li>Uses the <strong>slope equation</strong> of a line:
                        \[
                        y = mx + c
                        \]
                    </li>
                    <li>Takes <strong>small continuous steps</strong> along the x-axis to compute corresponding
                        y-values.</li>
                    <li>Works in <strong>real numbers</strong> (e.g., 2.5, 3.8) without worrying about integer
                        constraints.</li>
                    <li>Used in applications like solving <strong>differential equations</strong> or <strong>simulating
                            motion</strong>.</li>
                </ul>

                <strong>Example:</strong>
                <p>If we need to draw a line from (2,3) to (6,7), the slope is:</p>

                \[
                m = \frac{(y_2 - y_1)}{(x_2 - x_1)} = \frac{7 - 3}{6 - 2} = 1
                \]

                <p>Then, by incrementing <strong>x by small steps</strong> (like 0.1), we calculate y-values
                    accordingly.</p>

                <p><strong>Problem in Computer Graphics:</strong> The output might be (2,3), (2.1,3.1), (2.2,3.2), etc.
                    <strong>But pixels can’t be placed at fractional coordinates!</strong>
                </p>

                <h3>2. Computer Graphics DDA Algorithm</h3>

                <p>Since computer screens use <strong>pixels</strong>, the DDA algorithm must ensure that a line is
                    drawn using <strong>only integer coordinates</strong>.</p>

                <strong>How It Works:</strong>
                <ul>
                    <li>Instead of using the slope equation directly, it finds the <strong>number of steps</strong>
                        required to move from the start to the endpoint.</li>
                    <li>Uses <strong>incremental steps</strong> in either <strong>x or y</strong>, ensuring only
                        <strong>integer coordinates</strong> are chosen.
                    </li>
                    <li>Uses <strong>rounding</strong> to pick the closest pixel to represent the actual line.</li>
                </ul>

                <strong>Algorithm Steps:</strong>
                <ul>
                    <li>Calculate <strong>\( dx = x_2 - x_1 \)</strong> and <strong>\( dy = y_2 - y_1 \)</strong>.</li>
                    <li>Determine the <strong>number of steps</strong> based on the greater of \( dx \) or \( dy \).
                    </li>
                    <li>Compute the <strong>incremental change</strong> in x and y per step:
                        \[
                        x_{\text{inc}} = \frac{dx}{\text{steps}}, \quad y_{\text{inc}} = \frac{dy}{\text{steps}}
                        \]
                    </li>
                    <li>Start from \( (x_1, y_1) \) and <strong>round the values to nearest integer pixels</strong>.
                    </li>
                    <li>Repeat until reaching \( (x_2, y_2) \).</li>
                </ul>

                <strong>Example:</strong>
                <p>If we need to draw a line from (2,3) to (6,7):</p>

                <ul>
                    <li>\( dx = 4, dy = 4 \)</li>
                    <li>Steps = max(4,4) = <strong>4</strong></li>
                    <li>x increment = \( dx/steps = 1 \)</li>
                    <li>y increment = \( dy/steps = 1 \)</li>
                </ul>

                <p>Thus, the pixel points would be:</p>

                <ul>
                    <li>(2,3)</li>
                    <li>(3,4)</li>
                    <li>(4,5)</li>
                    <li>(5,6)</li>
                    <li>(6,7)</li>
                </ul>

                <p><strong>All integer coordinates, perfect for a screen.</strong></p>
            </div>
            <div class="in">
                <h3>Bresenham's Line Drawing Algorithm</h3>
                <p>Bresenham's Line Drawing Algorithm is another popular technique for drawing straight lines in
                    computer graphics. It is known for being more efficient than the DDA algorithm because it uses only
                    integer arithmetic, avoiding the floating-point calculations that DDA uses. The algorithm makes
                    decisions on whether to move horizontally or diagonally based on the error (decision parameter),
                    which ensures that the line drawn appears continuous and smooth on pixel grids. Bresenham’s
                    algorithm is especially efficient for raster displays where pixel placement is crucial.</p>
                <p><strong>Goal of the algorithm</strong></p>
                <ul>
                    <li>You want to draw a straight line between two points \( (x_1, y_1) \) and \( (x_2, y_2) \). The
                        algorithm helps determine which pixels to color to form a straight line. It avoids using
                        floating-point numbers, relying only on integer arithmetic, making it faster and more efficient
                        for drawing lines on pixel grids (like on a computer screen).</li>
                </ul>
                <div class="wh compact-extended">
                    <div class="compact">
                        <p><strong>Step-by-Step Algorithm:</strong></p>
                        <ul>
                            <li><strong>Take Input:</strong></li>
                            <ul>
                                <li>Read the starting point \( (x_1, y_1) \) and the ending point \( (x_2, y_2) \).</li>
                            </ul>

                            <li><strong>Calculate the Differences (dx and dy):</strong></li>
                            <ul>
                                <li>Compute the change in \( x \) and \( y \):</li>
                                <ul>
                                    <li>\( dx = x_2 - x_1 \)</li>
                                    <li>\( dy = y_2 - y_1 \)</li>
                                </ul>
                            </ul>

                            <li><strong>Initialize the Decision Parameter (p):</strong></li>
                            <ul>
                                <li>Calculate the initial value of \( p \):</li>
                                <ul>
                                    <li>\( p = 2 \cdot dy - dx \)</li>
                                </ul>
                            </ul>

                            <li><strong>Start Plotting the Line:</strong></li>
                            <ul>
                                <li>Set the starting point \( (x, y) = (x_1, y_1) \).</li>
                                <li>Plot the first pixel at \( (x_1, y_1) \).</li>
                            </ul>

                            <li><strong>Loop to Plot the Remaining Points:</strong></li>
                            <ul>
                                <li>While \( x < x_2 \) (or until the end point is reached), repeat:</li>
                                        <ul>
                                            <li>If \( p < 0 \), move horizontally:</li>
                                                    <ul>
                                                        <li>Increment \( x \) by 1, keep \( y \) the same.</li>
                                                        <li>Update \( p \) using: \( p = p + 2 \cdot dy \).</li>
                                                    </ul>
                                            <li>If \( p \geq 0 \), move diagonally:</li>
                                            <ul>
                                                <li>Increment both \( x \) and \( y \) by 1.</li>
                                                <li>Update \( p \) using: \( p = p + 2 \cdot dy - 2 \cdot dx \).</li>
                                            </ul>
                                            <li>Plot the new pixel at the updated \( (x, y) \) position.</li>
                                        </ul>
                            </ul>

                            <li><strong>End of Algorithm:</strong></li>
                            <ul>
                                <li>The loop completes, and the full line is drawn from \( (x_1, y_1) \) to \( (x_2,
                                    y_2) \).</li>
                            </ul>
                        </ul>
                    </div>

                    <div class="extended">
                        <p><strong>Step-by-Step Algorithm</strong></p>
                        <ul>
                            <li><strong>Step 1: Understand the Problem</strong></li>
                            <ul>
                                <li>Imagine you have a grid (the screen or canvas) made of pixels. You need to draw a
                                    line
                                    from one point to another. The problem is that the line may not always align exactly
                                    with the pixel grid, so we have to figure out the best way to choose the pixels that
                                    form a straight line between the two points.</li>
                            </ul>

                            <li><strong>Step 2: Calculate the Differences (dx and dy)</strong></li>
                            <ul>
                                <li>You need to know how far the line will move in both the \( x \) and \( y \)
                                    directions.
                                    This tells you how much you need to adjust the \( x \) and \( y \) coordinates as
                                    you
                                    move along the line.</li>
                                <ul>
                                    <li>\( dx = x_2 - x_1 \) (the difference in the \( x \)-coordinates, or how much the
                                        line moves horizontally).</li>
                                    <li>\( dy = y_2 - y_1 \) (the difference in the \( y \)-coordinates, or how much the
                                        line moves vertically).</li>
                                </ul>
                                <li>These values are key to determining how the line is drawn.</li>
                            </ul>

                            <li><strong>Step 3: Initialize the Decision Parameter (p)</strong></li>
                            <ul>
                                <li>Bresenham’s algorithm uses a decision parameter \( p \) to help decide whether to
                                    move
                                    horizontally or diagonally at each step. This parameter helps us determine if the
                                    line
                                    should go straight to the right or slightly up (diagonally).</li>
                                <ul>
                                    <li>The initial value of \( p \) is calculated using:</li>
                                    <ul>
                                        <li>\( p = 2 \times dy - dx \)</li>
                                    </ul>
                                    <li>This helps determine whether you should move just horizontally or diagonally.
                                    </li>
                                </ul>
                            </ul>

                            <li><strong>Step 4: Start Plotting the Line</strong></li>
                            <ul>
                                <li>Now that you know the starting point \( (x_1, y_1) \), the first step is to plot the
                                    first pixel \( (x_1, y_1) \).</li>
                                <ul>
                                    <li>Start with the current coordinates \( (x, y) = (x_1, y_1) \).</li>
                                    <li>Plot the first pixel using \( \text{putpixel}(x, y, \text{color}) \) where \( x
                                        \)
                                        and \( y \) are the coordinates of the starting point.</li>
                                </ul>
                            </ul>

                            <li><strong>Step 5: Loop to Plot the Remaining Points</strong></li>
                            <ul>
                                <li>Now that the first pixel is plotted, you need to move along the line and plot the
                                    rest
                                    of the pixels. This is where the decision parameter \( p \) helps you decide if the
                                    next
                                    point should be directly to the right or diagonally up.</li>
                                <li><strong>While Loop Condition:</strong> You will continue plotting until \( x \)
                                    reaches
                                    \( x_2 \), meaning the line has reached the end point.</li>
                                <ul>
                                    <li>If \( p < 0 \):</li>
                                            <ul>
                                                <li>This means that moving horizontally is the best choice.</li>
                                                <li>You increase \( x \) by 1 (move to the right), but \( y \) stays the
                                                    same.</li>
                                                <li>Update \( p \) using the formula: \( p = p + 2 \times dy \) (we add
                                                    \( 2
                                                    \times dy \) to the current value of \( p \)).</li>
                                            </ul>

                                    <li>If \( p \geq 0 \):</li>
                                    <ul>
                                        <li>This means that moving diagonally (both \( x \) and \( y \)) will get you
                                            closer
                                            to the line.</li>
                                        <li>You increase \( x \) by 1 (move to the right), and also increase \( y \) by
                                            1
                                            (move up).</li>
                                        <li>Update \( p \) using the formula: \( p = p + 2 \times dy - 2 \times dx \)
                                            (we
                                            add \( 2 \times dy \) and subtract \( 2 \times dx \) from the current value
                                            of
                                            \( p \)).</li>
                                    </ul>

                                    <li>Plot the Pixel: After updating \( p \), plot the pixel at the new coordinates \(
                                        (x,
                                        y) \).</li>
                                </ul>
                            </ul>

                            <li><strong>Step 6: Continue Until You Reach the End Point</strong></li>
                            <ul>
                                <li>You keep repeating the steps until \( x \) equals \( x_2 \), meaning you've reached
                                    the
                                    end of the line. At each step, you either move horizontally or diagonally based on
                                    the
                                    decision parameter \( p \). As you plot each pixel, the line will start to form.
                                </li>
                            </ul>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="wh">
            <h2>Making Different shapes like Traffic Light,
                Smiley Face,
                Moving Car Animation,
                Hut Drawing with Colors,
                Bar Graph,
                Arc Animation with Circles,
                Basic Circle Drawing with Color Filling</h2>
            <div class="in">
    <h3>Traffic Light</h3>
    <p>This program draws a simple traffic light with three circles inside a rectangular box.</p>

    <ul>
        <li><strong>Defining Dimensions</strong></li>
        <p>We define the width and height of the rectangle and the radius of the circles.</p>
        <pre>
            <code>
int rectWidth = 60, rectHeight = 160;
int radius = 22;
            </code>
        </pre>

        <li><strong>Midpoint Calculation</strong></li>
        <p>We calculate the center of the screen to position the traffic light properly.</p>
        <pre>
            <code>
midx = getmaxx() / 2;
midy = getmaxy() / 2;
            </code>
        </pre>

        <li><strong>Drawing the Traffic Light</strong></li>
        <p>We draw a white rectangle as the traffic light body and three circles inside it.  
           The circles are placed at fixed positions.</p>
        <pre>
            <code>
setcolor(WHITE);
rectangle(midx - rectWidth / 2, midy - rectHeight / 2, midx + rectWidth / 2, midy + rectHeight / 2);

setfillstyle(SOLID_FILL, RED);
circle(midx, midy - 50, radius);
floodfill(midx, midy - 50, WHITE); // Red light

setfillstyle(SOLID_FILL, YELLOW);
circle(midx, midy, radius);
floodfill(midx, midy, WHITE); // Yellow light

setfillstyle(SOLID_FILL, GREEN);
circle(midx, midy + 50, radius);
floodfill(midx, midy + 50, WHITE); // Green light
            </code>
        </pre>

        <li><strong>Understanding Circle Placement</strong></li>
        <p>
            The middle circle is placed at <strong>midy</strong> (center of rectangle).  
            The top and bottom circles are placed at fixed offsets:
        </p>
        <ul>
            <li><strong>Top Circle:</strong> Moved up by <code>50</code> → <code>midy - 50</code></li>
            <li><strong>Middle Circle:</strong> Placed at center → <code>midy</code></li>
            <li><strong>Bottom Circle:</strong> Moved down by <code>50</code> → <code>midy + 50</code></li>
        </ul>

        <li><strong>Final Step</strong></li>
        <p>The program waits for user input before closing.</p>
        <pre>
            <code>
getch();
closegraph();
            </code>
        </pre>
    </ul>
</div>



            <!-- <div class="in">
                <h3>Traffic light</h3>
                <p>We want to simulate a traffic light system using graphics. The traffic light will change colors, and
                    we’ll display "STOP", "READY", and "GO" at the appropriate times. It's a simple simulation where
                    each color appears on the screen for a short time.</p>
                <ul>
                    <li><strong>Midpoint Calculation (midx, midy)</strong></li>
                    <pre>
                            <code>
midx = getmaxx() / 2;
midy = getmaxy() / 2;
                            </code>
                        </pre>
                    <ul>
                        <li>getmaxx() and getmaxy() give the maximum screen width and height in pixels, respectively. So
                            getmaxx()/2 and getmaxy()/2 calculate the center of the screen.</li>
                        <li>Why the center? Because we want the traffic light to be displayed in the middle of the
                            screen, so the midpoint helps position everything neatly.</li>
                    </ul>

                    <li><strong>Displaying the Introductory Text</strong></li>
                    <ul>
                        <li>Next, we display a welcome message and prompt the user to press any key to start the
                            simulation.</li>
                    </ul>
                    <pre>
                        <code>
setcolor(RED);
settextstyle(SCRIPT_FONT, HORIZ_DIR, 3);
settextjustify(CENTER_TEXT, CENTER_TEXT);
outtextxy(midx, midy-10, "Traffic Light Simulation");
outtextxy(midx, midy+10, "Press any key to start");
getch();
                        </code>
                    </pre>
                    <ul>
                        <li>setcolor(RED);: This sets the color that we'll use for drawing. Here, we set it to red, so
                            everything we draw will be red unless we change it later.</li>
                        <li>settextstyle(SCRIPT_FONT, HORIZ_DIR, 3): Configures the text style. We use a script font
                            (for a stylish look) and set the size to 3 (large size).</li>
                        <li>settextjustify(CENTER_TEXT, CENTER_TEXT);: This is important! This function determines how
                            the text will be aligned when we draw it. By setting both horizontal and vertical alignment
                            to CENTER_TEXT, we’re saying:
                            <ul>
                                <li>"Center the text both horizontally and vertically at the point we specify later."
                                </li>
                            </ul>
                        </li>
                        <li>outtextxy(midx, midy-10, "Traffic Light Simulation"): Displays the text "Traffic Light
                            Simulation" slightly above the center of the screen.</li>
                        <li>outtextxy(midx, midy+10, "Press any key to start"): Displays the prompt "Press any key to
                            start" just below the first text.</li>
                        <li>getch(): Pauses the program and waits for the user to press any key before moving on.</li>
                        <li>After the user presses a key, we clear the screen to prepare for the next stage of the
                            simulation.</li>
                    </ul>
                    <pre>
                        <code>
cleardevice();
                        </code>
                    </pre>
                    <ul>
                        <li>cleardevice(): Clears the screen of any previously drawn graphics or text. This ensures we
                            start with a clean canvas before drawing the traffic light.</li>
                    </ul>
                    <li><strong>Drawing the Traffic Light Border and STOP Light</strong></li>
                    <ul>
                        <li>Now, let’s get into the main part of the program where we draw the traffic light.</li>
                    </ul>
                    <pre>
                        <code>
setcolor(WHITE);
settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);
rectangle(midx-30, midy-80, midx+30, midy+80);
                        </code>
                    </pre>
                    <ul>
                        <li>setcolor(WHITE);: We set the color to white here because the traffic light border is drawn
                            in white.</li>
                        <li>settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);: This resets the text style to default after we've
                            finished setting up the title text.</li>
                        <li>rectangle(midx-30, midy-80, midx+30, midy+80);: This draws the outer rectangle for the
                            traffic light, with the coordinates defined relative to the center point (midx, midy). The
                            rectangle is 60 pixels wide and 160 pixels tall.</li>
                    </ul>
                    <li><strong>Drawing the STOP Light (Red)</strong></li>
                    <pre>
                        <code>
circle(midx, midy-50, 22);
setfillstyle(SOLID_FILL, RED);
floodfill(midx, midy-50, WHITE);
setcolor(BLUE);
outtextxy(midx, midy-50, "STOP");
                        </code>
                    </pre>
                    <ul>
                        <li>circle(midx, midy-50, 22);: This draws a circle above the center of the rectangle to
                            represent the STOP light. The circle is 22 pixels in radius and is positioned 50 pixels
                            above the center.</li>
                        <li>setfillstyle(SOLID_FILL, RED);: This sets the fill color to red for the circle.</li>
                        <li>floodfill(midx, midy-50, WHITE);: This function fills the inside of the circle with red. It
                            starts from the center of the circle and fills everything enclosed by the white color (the
                            background).</li>
                        <li>setcolor(BLUE);: This sets the color for the text to blue.</li>
                        <li>outtextxy(midx, midy-50, "STOP");: This places the word "STOP" at the center of the red
                            circle.</li>
                    </ul>
                    <li><strong>Pausing Before Switching to the Next Signal</strong></li>
                    <pre>
                        <code>
usleep(2000000);
                        </code>
                    </pre>
                    <ul>
                        <li>usleep(2000000);: This pauses the program for 2 seconds (2,000,000 microseconds) so the
                            "STOP" light stays on the screen for a while before switching to the next signal.</li>
                    </ul>
                    <li><strong>Ready and Go Signals (Same as STOP but with Changes)</strong></li>
                    <pre>
                        <code>
graphdefaults();
cleardevice();
setcolor(WHITE);
rectangle(midx-30, midy-80, midx+30, midy+80);
circle(midx, midy, 20);
setfillstyle(SOLID_FILL, YELLOW);
floodfill(midx, midy, WHITE);
setcolor(BLUE);
outtextxy(midx-18, midy-3, "READY");

cleardevice();
setcolor(WHITE);
rectangle(midx-30, midy-80, midx+30, midy+80);
circle(midx, midy+50, 22);
setfillstyle(SOLID_FILL, GREEN);
floodfill(midx, midy+50, WHITE);
setcolor(BLUE);
outtextxy(midx-7, midy+48, "GO");

                        </code>
                    </pre>

                    <li><strong>Final Step: Waiting for Exit</strong></li>
                    <pre>
                        <code>
setcolor(RED);
settextstyle(SCRIPT_FONT, HORIZ_DIR, 4);
outtextxy(midx-150, midy+100, "Press any key to exit...");
getch(); // Wait for user input before exiting
closegraph();
                        </code>
                    </pre>
                    <ul>
                        <li>After showing the "GO" signal, we display a message to let the user know they can exit the
                            program.</li>
                    </ul>
                </ul>
            </div> -->
            <div class="in">
    <h3>Smiley Face</h3>
    <p><strong>Understanding the arc() Function for Drawing a Smiley Face</strong></p>
    <p>To draw a smiley face, we need a curved line for the mouth. This curved line is called an arc.</p>
    <p><strong>What is an Arc?</strong></p>
    <ul>
        <li>Think of an arc as a part of a circle. If a full circle is like a pizza, then an arc is like one
            slice or a curved section of the crust.</li>
        <li>When drawing a smiley face, we need an arc for the mouth. This arc is a small portion of a
            bigger invisible circle.</li>
    </ul>

    <p><strong>The arc(x, y, startAngle, endAngle, radius) Function</strong></p>
    <p>This function helps us draw an arc on the screen. Let’s break down its parameters in simple terms:</p>
    <ol>
        <li><strong>x, y (Center of the Arc)</strong></li>
        <ul>
            <li>These two numbers tell the program where the arc is centered.</li>
            <li>Example: arc(300, 340, 20, 160, 50); → Here, (300, 340) is the center of the invisible full
                circle that contains the arc.</li>
        </ul>
        <li><strong>startAngle (Where the Arc Begins)</strong></li>
        <ul>
            <li>This is the starting point of the arc, measured in degrees.</li>
            <li>Imagine a clock:
                <ul>
                    <li>0° → Right side (3 o’clock).</li>
                    <li>90° → Top (12 o’clock).</li>
                    <li>180° → Left side (9 o’clock).</li>
                    <li>270° → Bottom (6 o’clock).</li>
                </ul>
            </li>
            <li>If we start at 20°, it means we begin a little above the right side.</li>
        </ul>
        <li><strong>endAngle (Where the Arc Ends)</strong></li>
        <ul>
            <li>This is the finishing point of the arc, also in degrees.</li>
            <li>If we set endAngle = 160°, the arc stops near the left side.</li>
            <li>The arc is drawn from startAngle to endAngle in a counterclockwise direction.</li>
        </ul>
        <li><strong>radius (Size of the Arc)</strong></li>
        <ul>
            <li>This tells how big the arc should be.</li>
            <li>A larger radius makes a wider arc.</li>
            <li>A smaller radius makes a tighter curve.</li>
            <li>Example: radius = 50 → The arc will be a part of an invisible circle with a radius of 50
                pixels.</li>
        </ul>
    </ol>

    <p><strong>Example: Drawing a Smiley Mouth</strong></p>
    <pre>
        <code>
arc(300, 340, 200, 340, 50); 
        </code>
    </pre>
    <p><strong>Flip the Smile (Make it a Sad Face)</strong></p>
    <pre>
        <code>
arc(300, 340, 20, 160, 50); 
        </code>
    </pre>
    <p>Here, 200° to 340° creates a downward arc, forming a smile (a U shape). 20° to 160° creates an upward arc, forming a sad face.</p>
    <ul>
        <li>"The arc() function draws an arc based on the center point, start angle, end angle, and radius. The angles are measured counterclockwise starting from the 3 o'clock position (0°).
            <ul>
                <li>Third Quadrant (240°): This is a point in the third quadrant (left bottom) of the circle, where the angle is between 180° and 270°. From this point, the arc will start to curve downward, creating the bottom part of the smile.</li>
                <li>Fourth Quadrant (340°): This is in the fourth quadrant (right bottom) of the circle, where the angle is between 270° and 360°.</li>
            </ul>
            When we start at 240° (third quadrant) and move counterclockwise to 340° (fourth quadrant), the arc will open upward like the top of a "U," with the curve bending downward to form the shape of a smile."
        </li>
    </ul>

    <p>Now that we understand how to draw the mouth with the arc, we can draw the full smiley face.</p>

    <h4>Smiley Face Program Code:</h4>
    <pre>
        <code>
#include &lt;graphics.h>
#include &lt;conio.h>

void main()
{
    int gd = DETECT, gm, midx, midy;

    initgraph(&gd, &gm, "");

    midx = getmaxx() / 2;  // X center of the screen
    midy = getmaxy() / 2;  // Y center of the screen

    int faceRadius = 100;  // Face size
    int eyeRadius = 15;    // Eye size
    int mouthRadius = 50;  // Mouth arc size

    // Draw Face (Big Circle, just border)
    setcolor(WHITE);
    circle(midx, midy, faceRadius);  // Face border

    // Draw Left Eye (Just border)
    circle(midx - 35, midy - 30, eyeRadius);  // Left eye border

    // Draw Right Eye (Just border)
    circle(midx + 35, midy - 30, eyeRadius);  // Right eye border

    // Draw Smile (Arc) - Happy face
    arc(midx, midy + 10, 200, 340, mouthRadius);  // Smile arc

    // To make a sad face, use the following line instead of the smile arc:
    // arc(midx, midy + 40, 20, 160, mouthRadius);  // Sad arc

    getch();
    closegraph();
}
        </code>
    </pre>
    <p><strong>Explanation:</strong></p>
    <ul>
        <li><strong>Face:</strong> The face is drawn as a large circle with a radius of 100, centered at `(midx, midy)`.</li>
        <li><strong>Eyes:</strong> Two smaller circles (radius 15) are drawn for the eyes. The left eye is placed at `(midx - 35, midy - 30)` and the right eye at `(midx + 35, midy - 30)`. This keeps the eyes symmetrical and positioned on the upper part of the face.</li>
        <li><strong>Mouth:</strong> The mouth is drawn as an arc. The `arc()` function is used with the center of the mouth at `(midx, midy + 10)`. The arc spans from 200° to 340° for a smile, and you can flip it for a sad face by changing the angles to 20° to 160°.</li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script type="module" src="../../../public/main.js"></script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Analysis and ML with Python</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit5/index.html" class="link">Next Topic &rarr;</a>
                <a href="../unit3/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Data Analysis and ML with Python</h2>
        </div>
    </div>
    <div class="content-box">
        <pre>
            <code>
Data Analysis and ML with Python
|
├── 1. Key Python Libraries for ML & Data Analysis
│   ├── NumPy, SciPy, Matplotlib, Pandas, Scikit-Learn
│
├── 2. NumPy Basics
│   ├── Multidimensional Arrays (ndarrays)
│   ├── Creating ndarrays
│   ├── Data Types for ndarrays
│   └── Basic Indexing and Slicing
│
├── 3. Getting Started with Pandas
│   ├── Series, DataFrames, and Index Objects
│   ├── Re-indexing
│   ├── Indexing, Selection, and Filtering
│   ├── Sorting and Ranking
│   └── Loading Data (CSV and other structured formats)
│
├── 4. Data Preprocessing and Handling
│   ├── Normalizing Data
│   ├── Dealing with Missing Data
│   ├── Data Manipulation
│   │   ├── Alignment, Aggregation, Summarization
│   ├── Group-based Operations (Split-Apply-Combine)
│
├── 5. Statistical and Time Series Analysis
│   ├── Statistical Analysis with Pandas, Date and Time Series Analysis
│
└── 6. Data Visualization
    └── Visualizing Data using Matplotlib and Pandas
            </code>
        </pre>
        <ul>
            <li>Before we dive deep into machine learning algorithms, it’s essential to get comfortable with handling,
                analyzing, and visualizing data — and Python makes this incredibly powerful (and fun!) with its rich
                ecosystem of libraries.</li>
            <li>This unit introduces you to the core Python tools used in data analysis and machine learning, like
                NumPy, Pandas, Matplotlib, and Scikit-Learn. We start with NumPy, which gives us high-performance tools
                to work with arrays — the backbone of data in ML. You'll learn how to create arrays, slice and index
                them, and understand how data types work behind the scenes.</li>
            <li>Then we move on to Pandas, your go-to library for dealing with real-world datasets. You’ll learn how to
                use Series and DataFrames, reindex data, filter and sort it, and load datasets from files like CSVs. It
                also covers cleaning data, handling missing values, and performing advanced operations like grouping,
                aggregating, and normalizing data.</li>
            <li>You’ll also explore basic statistical analysis and dive into time series data, which is especially
                useful for things like stock trends or sensor data. Finally, you’ll learn how to visualize your data
                using Matplotlib and Pandas' built-in plotting — because making sense of data visually is a key skill in
                any ML or data science role.</li>
        </ul>
        <div class="wh">
            <h3>Many topics from this unit were already covered in Semester 4 under the subject Data Analytics Using
                Python.</h3>
            <ul>
                <li><a href="../../../sem4/python_tbc401/unit5/index.html#t1" target="_blank">NumPy &neArr;</a></li>
                <li><a href="../../../sem4/python_tbc401/unit5/index.html#t2" target="_blank">Pandas &neArr;</a></li>
                <li><a href="../../../sem4/python_tbc401/unit5/index.html#t3" target="_blank">Data Handling &neArr;</a>
                </li>
                <li><a href="../../../sem4/python_tbc401/unit5/index.html#t4" target="_blank">Data Visualization
                        &neArr;</a></li>
            </ul>
        </div>
        <div class="wh">
            <h2>Key Python Libraries for Machine Learning & Data Analysis</h2>

            <p>When you're diving into machine learning and data analysis with Python, there are five essential
                libraries that form the backbone of most projects. Think of these as your toolkit - each one serves a
                specific purpose, but they all work beautifully together.</p>

            <div class="in">
                <h3>NumPy - The Foundation of Everything</h3>

                <p><strong>What it is:</strong> NumPy (Numerical Python) is like the bedrock of scientific computing in
                    Python. It provides support for large, multi-dimensional arrays and matrices, along with
                    mathematical
                    functions to operate on them.</p>

                <p><strong>Why you need it:</strong> Python lists are great for general use, but they're slow when
                    you're
                    doing heavy number crunching. NumPy arrays are much faster and use less memory. Plus, almost every
                    other
                    data science library is built on top of NumPy.</p>

                <p><strong>Key features:</strong></p>
                <ul>
                    <li><strong>N-dimensional arrays:</strong> Handle everything from 1D vectors to complex
                        multi-dimensional datasets</li>
                    <li><strong>Broadcasting:</strong> Perform operations on arrays of different shapes without writing
                        loops</li>
                    <li><strong>Mathematical functions:</strong> Trigonometry, linear algebra, statistics - it's all
                        there
                    </li>
                    <li><strong>Memory efficiency:</strong> Arrays use contiguous memory, making operations lightning
                        fast
                    </li>
                </ul>

                <p><strong>Common use cases:</strong> Array operations, mathematical computations, data preprocessing,
                    serving as the foundation for other libraries.</p>

            </div>
            <div class="in">
                <h3>SciPy - Scientific Computing Powerhouse</h3>

                <p><strong>What it is:</strong> SciPy builds on NumPy and adds a collection of algorithms and high-level
                    commands for scientific and technical computing. If NumPy is the foundation, SciPy is the
                    specialized
                    toolkit.</p>

                <p><strong>Why you need it:</strong> While NumPy gives you basic array operations, SciPy provides
                    advanced
                    mathematical algorithms that you'd otherwise have to implement from scratch (and trust me, you don't
                    want to code your own optimization algorithms).</p>

                <p><strong>Key modules:</strong></p>
                <ul>
                    <li><strong>scipy.optimize:</strong> Find minima/maxima of functions, solve equations</li>
                    <li><strong>scipy.linalg:</strong> Advanced linear algebra operations</li>
                    <li><strong>scipy.stats:</strong> Statistical functions and probability distributions</li>
                    <li><strong>scipy.signal:</strong> Signal processing tools</li>
                    <li><strong>scipy.integrate:</strong> Numerical integration</li>
                    <li><strong>scipy.interpolate:</strong> Interpolation and smoothing</li>
                </ul>

                <p><strong>Common use cases:</strong> Statistical analysis, optimization problems, signal processing,
                    scientific simulations.</p>
            </div>

            <div class="in">
                <h3>Matplotlib - Making Data Visual</h3>

                <p><strong>What it is:</strong> Matplotlib is Python's go-to plotting library. It's like having a
                    complete
                    graphics studio for your data - you can create everything from simple line plots to complex
                    interactive
                    visualizations.</p>

                <p><strong>Why you need it:</strong> Data without visualization is just numbers on a screen. Matplotlib
                    helps you see patterns, trends, and insights that would be invisible in raw data. Plus, they say a
                    picture is worth a thousand words - in data science, a good plot is worth a thousand rows of data.
                </p>

                <p><strong>Key components:</strong></p>
                <ul>
                    <li><strong>pyplot:</strong> MATLAB-like interface for quick plotting</li>
                    <li><strong>Object-oriented API:</strong> Fine-grained control over every aspect of your plots</li>
                    <li><strong>Multiple backends:</strong> Display plots in Jupyter notebooks, save to files, or create
                        interactive applications</li>
                    <li><strong>Extensive customization:</strong> Control colors, fonts, styles, annotations -
                        everything
                    </li>
                </ul>

                <p><strong>Plot types you can create:</strong></p>
                <ul>
                    <li>Line plots, scatter plots, bar charts, histograms</li>
                    <li>Heatmaps, contour plots, 3D visualizations</li>
                    <li>Subplots and complex multi-panel figures</li>
                    <li>Interactive plots with widgets and animations</li>
                </ul>

                <p><strong>Common use cases:</strong> Exploratory data analysis, presenting results, creating
                    publication-ready figures, debugging ML models by visualizing data distributions.</p>
            </div>

            <div class="in">
                <h3>Pandas - Data Manipulation Made Easy</h3>

                <p><strong>What it is:</strong> Pandas is your best friend for data manipulation and analysis. Think of
                    it
                    as Excel on steroids - it provides data structures and tools for handling structured data with ease.
                </p>

                <p><strong>Why you need it:</strong> Real-world data is messy. It has missing values, weird formats, and
                    needs cleaning before you can do anything useful with it. Pandas makes data wrangling feel almost
                    enjoyable (okay, maybe that's going too far, but it definitely makes it bearable).</p>

                <p><strong>Core data structures:</strong></p>
                <ul>
                    <li><strong>Series:</strong> 1D labeled arrays (think of a single column from a spreadsheet)</li>
                    <li><strong>DataFrame:</strong> 2D labeled data structure (like a whole spreadsheet with rows and
                        columns)</li>
                </ul>

                <p><strong>Key capabilities:</strong></p>
                <ul>
                    <li><strong>Data loading:</strong> Read from CSV, Excel, JSON, databases, and more</li>
                    <li><strong>Data cleaning:</strong> Handle missing values, remove duplicates, fix data types</li>
                    <li><strong>Data transformation:</strong> Filter, sort, group, merge, and reshape data</li>
                    <li><strong>Statistical analysis:</strong> Built-in descriptive statistics and aggregation functions
                    </li>
                    <li><strong>Time series:</strong> Specialized tools for working with dates and time-based data</li>
                </ul>

                <p><strong>Common use cases:</strong> Data cleaning, exploratory data analysis, feature engineering,
                    data
                    preprocessing for ML models.</p>
            </div>

            <div class="in">
                <h3>Scikit-Learn - Machine Learning Made Accessible</h3>

                <p><strong>What it is:</strong> Scikit-Learn (sklearn) is the Swiss Army knife of machine learning in
                    Python. It provides simple and efficient tools for data mining and data analysis, built on NumPy,
                    SciPy,
                    and Matplotlib.</p>

                <p><strong>Why you need it:</strong> Instead of implementing machine learning algorithms from scratch,
                    Scikit-Learn gives you battle-tested implementations that just work. It follows consistent APIs
                    across
                    all algorithms, making it easy to experiment and compare different approaches.</p>

                <p><strong>Main categories of algorithms:</strong></p>
                <ul>
                    <li><strong>Supervised Learning:</strong> Linear regression, logistic regression, SVM, random
                        forests,
                        neural networks</li>
                    <li><strong>Unsupervised Learning:</strong> K-means clustering, hierarchical clustering, PCA, DBSCAN
                    </li>
                    <li><strong>Model Selection:</strong> Cross-validation, grid search, train/test splitting</li>
                    <li><strong>Preprocessing:</strong> Feature scaling, encoding categorical variables, handling
                        missing
                        data</li>
                </ul>

                <p><strong>Key features:</strong></p>
                <ul>
                    <li><strong>Consistent API:</strong> All estimators follow the same fit/predict pattern</li>
                    <li><strong>Comprehensive documentation:</strong> Excellent examples and user guides</li>
                    <li><strong>Model evaluation:</strong> Built-in metrics for classification, regression, and
                        clustering
                    </li>
                    <li><strong>Pipeline support:</strong> Chain preprocessing and modeling steps together</li>
                    <li><strong>Cross-validation:</strong> Robust model evaluation techniques built-in</li>
                </ul>

                <p><strong>Common use cases:</strong> Building predictive models, feature selection, model evaluation,
                    prototyping ML solutions.</p>

            </div>
        </div>
        <div class="wh">
            <h2>NumPy Basics</h2>

            <p>NumPy is where your data science journey really begins. Think of it as upgrading from a bicycle to a
                sports car - everything becomes faster, more powerful, and way more fun. Let's start from the very
                beginning and build up your understanding step by step.</p>

            <div class="in">
                <h3>What You Need to Get Started</h3>

                <p><strong>Installing NumPy:</strong> Before we can use NumPy, you need to install it. Open your command
                    prompt or terminal and type:</p>

                <pre><code>pip install numpy</code></pre>

                <p><strong>Importing NumPy:</strong> At the beginning of every Python script where you want to use
                    NumPy, you need to import it. This is the standard way everyone does it:</p>

                <pre><code>import numpy as np</code></pre>

                <p><strong>Why "np"?</strong> We use "np" as a shortcut instead of typing "numpy" every time. It's a
                    convention that everyone follows, so you'll see it everywhere.</p>

                <p><strong>Testing your installation:</strong></p>
                <pre>
    <code>
import numpy as np
print("NumPy version:", np.__version__)
print("NumPy is working!")
    </code>
</pre>
            </div>

            <div class="in">
                <h3>What Are Multidimensional Arrays (ndarrays)?</h3>

                <p><strong>The Big Picture:</strong> An ndarray (n-dimensional array) is NumPy's main data structure.
                    Think of it like a super-powered list that can handle multiple dimensions and is incredibly fast for
                    math operations.</p>

                <p><strong>Simple comparison:</strong></p>
                <ul>
                    <li><strong>Python list:</strong> [1, 2, 3, 4] - flexible but slow for math</li>
                    <li><strong>NumPy array:</strong> array([1, 2, 3, 4]) - less flexible but lightning fast for math
                    </li>
                </ul>

                <p><strong>Understanding dimensions:</strong></p>
                <ul>
                    <li><strong>1D array (1 dimension):</strong> Like a single row of numbers [1, 2, 3, 4]</li>
                    <li><strong>2D array (2 dimensions):</strong> Like a table with rows and columns (think Excel
                        spreadsheet)</li>
                    <li><strong>3D array (3 dimensions):</strong> Like a stack of tables (think multiple Excel sheets)
                    </li>
                </ul>

                <p><strong>Why ndarrays are amazing:</strong></p>
                <ul>
                    <li><strong>Speed:</strong> Operations are 10-100 times faster than Python lists</li>
                    <li><strong>Memory efficient:</strong> Use less memory than Python lists</li>
                    <li><strong>Vectorized operations:</strong> You can do math on entire arrays without writing loops
                    </li>
                    <li><strong>Same data type:</strong> All elements must be the same type (all numbers, all text,
                        etc.)</li>
                </ul>

                <p><strong>Your first array:</strong></p>
                <pre><code># Always start by importing numpy
import numpy as np

# Create your first array from a Python list
my_first_array = np.array([1, 2, 3, 4, 5])
print("My first array:", my_first_array)

# See what type it is
print("Type:", type(my_first_array))

# Python list vs NumPy array comparison
python_list = [1, 2, 3, 4, 5]
numpy_array = np.array([1, 2, 3, 4, 5])

# With Python list, you need a loop to multiply each element
doubled_list = [x * 2 for x in python_list]
print("Python list doubled:", doubled_list)

# With NumPy, you can multiply the whole array at once!
doubled_array = numpy_array * 2
print("NumPy array doubled:", doubled_array)</code></pre>
            </div>

            <div class="in">
                <h3>Creating ndarrays - All the Different Ways</h3>

                <p>There are many ways to create NumPy arrays. Let's learn them all, starting with the simplest.</p>

                <h3>Method 1: From Python Lists</h3>

                <p>This is the most common way when you're starting out.</p>

                <pre><code>import numpy as np

# 1D array from a list
simple_array = np.array([1, 2, 3, 4, 5])
print("1D array:", simple_array)

# 2D array from nested lists (list of lists)
# Think of it as rows and columns
matrix = np.array([[1, 2, 3], 
                   [4, 5, 6], 
                   [7, 8, 9]])
print("2D array:")
print(matrix)

# 3D array from nested nested lists
# This is like having multiple 2D arrays stacked
cube = np.array([[[1, 2], [3, 4]], 
                 [[5, 6], [7, 8]]])
print("3D array:")
print(cube)

# You can also use tuples instead of lists
tuple_array = np.array((10, 20, 30))
print("From tuple:", tuple_array)</code></pre>

                <h3>Method 2: Arrays Full of Zeros</h3>

                <p>Sometimes you want to start with an array of all zeros and fill it later.</p>

                <pre><code>import numpy as np

# 1D array of 5 zeros
zeros_1d = np.zeros(5)
print("1D zeros:", zeros_1d)

# 2D array of zeros - you need to give (rows, columns)
zeros_2d = np.zeros((3, 4))  # 3 rows, 4 columns
print("2D zeros:")
print(zeros_2d)

# 3D array of zeros - (depth, rows, columns)
zeros_3d = np.zeros((2, 3, 4))  # 2 layers, 3 rows, 4 columns per layer
print("3D zeros shape:", zeros_3d.shape)</code></pre>

                <h3>Method 3: Arrays Full of Ones</h3>

                <p>Similar to zeros, but filled with ones.</p>

                <pre><code>import numpy as np

# 1D array of ones
ones_1d = np.ones(4)
print("1D ones:", ones_1d)

# 2D array of ones
ones_2d = np.ones((2, 3))  # 2 rows, 3 columns
print("2D ones:")
print(ones_2d)</code></pre>

                <h3>Method 4: Arrays Full of Any Number</h3>

                <p>You can fill an array with any number you want.</p>

                <pre><code>import numpy as np

# Fill with the number 7
sevens = np.full((2, 3), 7)  # 2x3 array filled with 7
print("Array of sevens:")
print(sevens)

# Fill with 3.14
pis = np.full((3, 2), 3.14)
print("Array of 3.14s:")
print(pis)</code></pre>

                <h3>Method 5: Identity Matrix</h3>

                <p>This creates a square matrix with 1s on the diagonal and 0s everywhere else. Very useful in linear
                    algebra.</p>

                <pre><code>import numpy as np

# 3x3 identity matrix
identity = np.eye(3)
print("3x3 identity matrix:")
print(identity)

# 4x4 identity matrix
identity_4 = np.eye(4)
print("4x4 identity matrix:")
print(identity_4)</code></pre>

                <h3>Method 6: Arrays with Number Sequences</h3>

                <p>Create arrays with sequences of numbers automatically.</p>

                <pre><code>import numpy as np

# Simple sequence from 0 to 9
simple_range = np.arange(10)
print("0 to 9:", simple_range)

# Sequence from 2 to 20, but not including 20
range_start_stop = np.arange(2, 20)
print("2 to 19:", range_start_stop)

# Sequence with custom step
range_with_step = np.arange(2, 20, 3)  # Start 2, stop before 20, step by 3
print("2 to 19 step 3:", range_with_step)

# Evenly spaced numbers between two points
evenly_spaced = np.linspace(0, 10, 5)  # 5 numbers evenly spaced from 0 to 10
print("5 numbers from 0 to 10:", evenly_spaced)

# More evenly spaced numbers
more_spaced = np.linspace(0, 1, 11)  # 11 numbers from 0 to 1
print("11 numbers from 0 to 1:", more_spaced)</code></pre>

                <h3>Method 7: Random Arrays</h3>

                <p>Create arrays filled with random numbers. Super useful for testing and simulations.</p>

                <pre><code>import numpy as np

# Random numbers between 0 and 1
random_small = np.random.random(5)  # 5 random numbers
print("5 random numbers (0-1):", random_small)

# 2D array of random numbers
random_2d = np.random.random((2, 3))  # 2x3 array of random numbers
print("2x3 random array:")
print(random_2d)

# Random integers
random_integers = np.random.randint(1, 10, size=5)  # 5 random integers from 1 to 9
print("Random integers 1-9:", random_integers)

# 2D array of random integers
random_int_2d = np.random.randint(1, 100, size=(3, 3))  # 3x3 random integers 1-99
print("3x3 random integers:")
print(random_int_2d)</code></pre>
            </div>

            <div class="in">
                <h3>Understanding Array Properties</h3>

                <p>Once you create an array, you need to understand what you're working with. NumPy gives you several
                    ways to inspect your arrays.</p>

                <pre><code>import numpy as np

# Create a sample array to explore
sample_array = np.array([[1, 2, 3, 4], 
                         [5, 6, 7, 8], 
                         [9, 10, 11, 12]])

print("Our sample array:")
print(sample_array)
print()

# SHAPE - tells you the dimensions
print("Shape:", sample_array.shape)  # (3, 4) means 3 rows, 4 columns

# SIZE - total number of elements
print("Size (total elements):", sample_array.size)  # 12 elements

# NDIM - number of dimensions
print("Number of dimensions:", sample_array.ndim)  # 2 dimensions

# DTYPE - what type of data is stored
print("Data type:", sample_array.dtype)  # probably int64

# Let's try with different data
float_array = np.array([1.1, 2.2, 3.3])
print("Float array dtype:", float_array.dtype)  # float64

text_array = np.array(['hello', 'world'])
print("Text array dtype:", text_array.dtype)  # probably &lt;U5 or similar</code></pre>

                <p><strong>Understanding shape:</strong></p>
                <ul>
                    <li><strong>1D array shape:</strong> (5,) means 5 elements in one dimension</li>
                    <li><strong>2D array shape:</strong> (3, 4) means 3 rows and 4 columns</li>
                    <li><strong>3D array shape:</strong> (2, 3, 4) means 2 layers, each with 3 rows and 4 columns</li>
                </ul>
            </div>

            <div class="in">
                <h3>Data Types for ndarrays - What Kind of Data Can You Store?</h3>

                <p>NumPy arrays can only store one type of data at a time. Understanding data types helps you choose the
                    right one for your needs and save memory.</p>

                <h3>Integer Types (Whole Numbers)</h3>

                <p><strong>Different sizes for different needs:</strong></p>

                <pre><code>import numpy as np

# Different integer sizes
tiny_int = np.array([1, 2, 3], dtype=np.int8)    # Very small: -128 to 127
small_int = np.array([1, 2, 3], dtype=np.int16)  # Small: -32,768 to 32,767
normal_int = np.array([1, 2, 3], dtype=np.int32) # Normal: about -2 billion to 2 billion
big_int = np.array([1, 2, 3], dtype=np.int64)    # Big: huge range (default)

print("int8 array:", tiny_int)
print("int64 array:", big_int)

# Check memory usage
print("int8 uses", tiny_int.nbytes, "bytes")
print("int64 uses", big_int.nbytes, "bytes")

# Unsigned integers (only positive numbers, but larger range)
positive_only = np.array([1, 2, 3], dtype=np.uint8)  # 0 to 255
print("Unsigned int8:", positive_only)
print("Max value for uint8:", np.iinfo(np.uint8).max)</code></pre>

                <h3>Float Types (Decimal Numbers)</h3>

                <pre><code>import numpy as np

# Different precision levels
half_precision = np.array([1.1, 2.2, 3.3], dtype=np.float16)    # Less precise, saves memory
single_precision = np.array([1.1, 2.2, 3.3], dtype=np.float32) # Normal precision
double_precision = np.array([1.1, 2.2, 3.3], dtype=np.float64) # High precision (default)

print("float16:", half_precision)
print("float32:", single_precision)
print("float64:", double_precision)

# Scientific notation works
scientific = np.array([1e-3, 2e5, 3.14e2])  # 0.001, 200000, 314.0
print("Scientific notation:", scientific)</code></pre>

                <h3>Converting Between Types</h3>

                <p>Sometimes you need to change the data type of an array.</p>

                <pre><code>import numpy as np

# Start with float numbers
original = np.array([1.7, 2.3, 3.9, 4.1])
print("Original (float):", original)

# Convert to integers (cuts off decimal part)
as_integers = original.astype(np.int32)
print("As integers:", as_integers)

# Convert back to float
back_to_float = as_integers.astype(np.float64)
print("Back to float:", back_to_float)

# Convert numbers to text
as_text = original.astype('U10')
print("As text:", as_text)
print("Text array type:", as_text.dtype)

# NumPy automatically chooses types when mixing
mixed = np.array([1, 2.5, 3])  # Automatically becomes float to fit all values
print("Mixed array:", mixed)
print("Automatic type:", mixed.dtype)</code></pre>
            </div>

            <div class="in">
                <h3>Basic Indexing and Slicing - Getting Data Out of Arrays</h3>

                <p>This is one of the most important skills - being able to get specific pieces of data from your
                    arrays. Let's start simple and build up.</p>

                <h3>1D Array Indexing (Single Dimension)</h3>

                <p><strong>Basic rules:</strong></p>
                <ul>
                    <li>Indexing starts at 0 (first element is index 0)</li>
                    <li>Negative indices count from the end (-1 is the last element)</li>
                    <li>Slicing uses [start:stop:step] format</li>
                </ul>

                <pre><code>import numpy as np

# Create a simple 1D array
numbers = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
print("Original array:", numbers)

# Getting single elements
print("First element (index 0):", numbers[0])      # 10
print("Third element (index 2):", numbers[2])      # 30
print("Last element (index -1):", numbers[-1])     # 90
print("Second to last (index -2):", numbers[-2])   # 80

# Getting multiple elements (slicing)
print("First 3 elements:", numbers[:3])        # [10, 20, 30]
print("Last 3 elements:", numbers[-3:])        # [70, 80, 90]
print("Elements 2 to 5:", numbers[2:6])        # [30, 40, 50, 60]
print("Every 2nd element:", numbers[::2])      # [10, 30, 50, 70, 90]
print("Every 3rd element:", numbers[::3])      # [10, 40, 70]
print("Reverse order:", numbers[::-1])         # [90, 80, 70, 60, 50, 40, 30, 20, 10]

# Changing values
numbers[0] = 100  # Change first element
print("After changing first element:", numbers)

# Change multiple values at once
numbers[1:4] = [200, 300, 400]
print("After changing elements 1-3:", numbers)</code></pre>

                <h3>2D Array Indexing (Rows and Columns)</h3>

                <p><strong>Key concept:</strong> For 2D arrays, you specify [row, column]. Remember: row first, then
                    column.</p>

                <pre><code>import numpy as np

# Create a 2D array (3 rows, 4 columns)
grid = np.array([[1,  2,  3,  4],
                 [5,  6,  7,  8],
                 [9, 10, 11, 12]])
print("2D array:")
print(grid)
print()

# Getting single elements: [row, column]
print("Element at row 0, column 1:", grid[0, 1])    # 2
print("Element at row 1, column 2:", grid[1, 2])    # 7
print("Element at row 2, column 3:", grid[2, 3])    # 12

# Getting entire rows
print("First row (row 0):", grid[0])      # [1, 2, 3, 4]
print("Second row (row 1):", grid[1])     # [5, 6, 7, 8]
print("Last row (row -1):", grid[-1])     # [9, 10, 11, 12]

# Getting entire columns (using : for all rows)
print("First column:", grid[:, 0])    # [1, 5, 9]
print("Second column:", grid[:, 1])   # [2, 6, 10]
print("Last column:", grid[:, -1])    # [4, 8, 12]

# Getting sub-rectangles
print("Top-left 2x2 corner:")
print(grid[:2, :2])    # First 2 rows, first 2 columns

print("Bottom-right 2x2 corner:")
print(grid[1:, 2:])    # Last 2 rows, last 2 columns

print("Middle 2x2 section:")  
print(grid[1:3, 1:3])  # Rows 1-2, columns 1-2</code></pre>

                <h3>Boolean Indexing (Super Powerful!)</h3>

                <p>This lets you find elements based on conditions. It's like asking "give me all elements that are
                    greater than 5".</p>

                <pre><code>import numpy as np

# Create sample data
data = np.array([1, 5, 3, 8, 2, 9, 4, 7, 6])
print("Original data:", data)

# Create a "mask" - True/False for each element
mask = data > 5  # Which elements are greater than 5?
print("Mask (data > 5):", mask)
print("Elements greater than 5:", data[mask])

# You can do it in one line
print("Elements > 5 (one line):", data[data > 5])

# More complex conditions
print("Elements between 3 and 7:", data[(data >= 3) & (data <= 7)])
print("Elements equal to 5 or 8:", data[(data == 5) | (data == 8)])

# Works with 2D arrays too
matrix = np.array([[1, 2, 8], [4, 5, 6], [7, 3, 9]])
print("Original matrix:")
print(matrix)
print("Elements > 5:", matrix[matrix > 5])

# Change values based on conditions
matrix[matrix > 5] = 99  # Set all elements > 5 to 99
print("After setting elements > 5 to 99:")
print(matrix)</code></pre>

            </div>

            <div class="in">
                <h3>Views vs Copies - Important Concept!</h3>

                <p><strong>Critical to understand:</strong> Sometimes when you slice an array, you get a "view"
                    (connected to original) and sometimes you get a "copy" (separate). This affects whether changes to
                    one affect the other.</p>

                <pre><code>import numpy as np

# Create original array
original = np.array([1, 2, 3, 4, 5])
print("Original:", original)

# Slicing creates a VIEW (shares memory with original)
view = original[1:4]  # Get elements 1, 2, 3
print("View:", view)

# Change the view
view[0] = 999
print("After changing view:")
print("View:", view)
print("Original:", original)  # Original changed too!

# Reset for next example
original = np.array([1, 2, 3, 4, 5])

# Boolean indexing creates a COPY (separate from original)
copy = original[original > 2]  # Get elements > 2
print("Copy:", copy)

# Change the copy
copy[0] = 888
print("After changing copy:")
print("Copy:", copy)
print("Original:", original)  # Original unchanged!

# Make an explicit copy when you want one
explicit_copy = original.copy()
explicit_copy[0] = 777
print("After changing explicit copy:")
print("Explicit copy:", explicit_copy)
print("Original:", original)  # Still unchanged</code></pre>
            </div>

            <div class="in">
                <h3>Putting It All Together - Real Examples</h3>

                <p>Let's see how these concepts work in practical situations you might encounter.</p>

                <h3>Example 1: Student Grades</h3>

                <pre><code>import numpy as np

# Student grades for 5 students in 4 subjects
# Rows = students, Columns = subjects (Math, Science, English, History)
grades = np.array([[85, 92, 78, 88],  # Student 1
                   [90, 85, 95, 82],  # Student 2  
                   [78, 88, 85, 90],  # Student 3
                   [92, 95, 88, 85],  # Student 4
                   [88, 82, 92, 87]]) # Student 5

print("All grades:")
print(grades)

# Get one student's grades
print("Student 1 grades:", grades[0])

# Get all students' math grades (first column) 
print("All math grades:", grades[:, 0])

# Find students with math grade > 85
good_at_math = grades[:, 0] > 85
print("Students good at math (>85):", good_at_math)
print("Their math grades:", grades[good_at_math, 0])

# Calculate average grade for each student
student_averages = np.mean(grades, axis=1)  # axis=1 means across columns
print("Student averages:", student_averages)

# Calculate average grade for each subject  
subject_averages = np.mean(grades, axis=0)  # axis=0 means across rows
print("Subject averages:", subject_averages)</code></pre>

                <h3>Example 2: Temperature Data</h3>

                <pre><code>import numpy as np

# Daily temperatures for a week (7 days)
temperatures = np.array([22.5, 25.0, 28.5, 30.0, 27.5, 24.0, 21.5])
days = np.array(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'])

print("Daily temperatures:")
for day, temp in zip(days, temperatures):
    print(f"{day}: {temp}°C")

# Find hot days (>25°C)
hot_days_mask = temperatures > 25
print("Hot days (>25°C):", days[hot_days_mask])
print("Hot day temperatures:", temperatures[hot_days_mask])

# Find the hottest day
hottest_day_index = np.argmax(temperatures)
print("Hottest day:", days[hottest_day_index])
print("Hottest temperature:", temperatures[hottest_day_index], "°C")

# Calculate weekly average
weekly_average = np.mean(temperatures)
print("Weekly average:", weekly_average, "°C")</code></pre>

            </div>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script type="module" src="../../../../public/main.js"></script>
</body>

</html>
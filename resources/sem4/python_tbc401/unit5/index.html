<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing and Visualizing Data</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
    <style>
        li>pre {
            margin: 5px 0;
        }
    </style>
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="" class="link">Next Topic &rarr;</a>
                <a href="" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Processing and Visualizing Data</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Processing and Visualizing Data</h1>
        <ul>
            <li>In the modern data-driven world, the ability to effectively process and visualize data is crucial. Data
                processing involves transforming raw data into a meaningful format that can be analyzed and interpreted.
                Visualization, on the other hand, helps to present this processed data in a graphical format, making it
                easier to identify patterns, trends, and insights. Together, these skills enable data scientists and
                analysts to make informed decisions and communicate their findings clearly.</li>
            <li>Two powerful tools that aid in this process are NumPy and pandas. NumPy provides support for large,
                multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on
                these arrays. It forms the foundation for numerical computing in Python. pandas builds on NumPy by
                offering data structures and operations specifically designed for data manipulation and analysis, making
                it easier to handle and analyze large datasets. Before diving into the technical aspects like using
                NumPy for array manipulations, it's important to grasp the fundamental concepts of data processing and
                visualization, as these form the backbone of data analysis.</li>
        </ul>
        <div class="wh">
            <h2>NumPy</h2>
            <ul>
                <li>NumPy is an open-source library designed for working with arrays.</li>
                <li>It was developed in 2005 by Travis Oliphant.</li>
                <li>The name stands for Numerical Python and it is a critical data science library in Python, with many
                    other libraries depending on it.</li>
                <li>NumPy is extremely popular because it improves the performance of working with multi-dimensional
                    arrays. Mathematical operations on NumPy arrays are up to 50 times faster than iterating over Python
                    lists using loops. It requires fewer lines of code for mathematical operations compared to native
                    Python lists.</li>

                <li>It offers an indexing system for easily accessing portions of data within arrays.</li>
                <li>It contains built-in functions that improve the quality of code when working with arrays and
                    mathematics, such as linear algebra, array transformations, and other mathematical operations.</li>
            </ul>
            <h3>Purpose of NumPy</h3>
            <ul>
                <li>It is mostly used in data analytics for working with arrays and matrices, including
                    multi-dimensional arrays.</li>
                <li>It helps to solve complex mathematical and statistical operations, offering multiple functions for
                    working with 2D matrices and 3D tensors.</li>
            </ul>
            <div class="in">
                <h3>NumPy Arrays</h3>
                <ul>
                    <li>NumPy arrays are used to create n-dimensional arrays, allowing us to solve complex problems in
                        mathematics, statistics, linear algebra, and matrix operations.</li>

                    <li>NumPy provides efficient data structures for handling large datasets and performing fast
                        numerical computations.</li>
                    <li>With NumPy arrays, we can perform vectorized operations, which are much faster than traditional
                        loop-based operations on Python lists.</li>
                    <li>NumPy is widely used in scientific computing, machine learning, data analysis, and other fields
                        due to its speed and convenience.</li>
                    <li>It is a package, so first, we have to import it using: <code>import numpy as np</code>.
                        <br>Make sure it is installed on your system by using the command:
                        <pre>
                            <code>
pip install numpy
                            </code>
                        </pre>
                    </li>
                </ul>
                <h3>Working with Arrays</h3>
                <pre>
                    <code>
import numpy as np 

# Creating a 1D array
a = np.array([1, 2, 3, 4])
print(a)
                    </code>
                </pre>
                <p>The above code creates a 1D array and prints it.</p>
                <p><strong>Taking elements from the user and printing them:</strong></p>
                <pre>
                    <code>
import numpy as np

# Taking input from the user
n = int(input("Enter the number of elements in the array: "))
elements = []

for i in range(n):
    element = int(input(f"Enter element {i + 1}: "))
    elements.append(element)

# Converting the list of elements to a NumPy array
elements_array = np.array(elements)

print("The created array is:", elements_array)
                    </code>
                </pre>
                <p>The above code takes the number of elements and each element from the user to create an array and
                    then prints the array. It prompts the user to enter the number of elements in the array, then
                    iteratively takes each element as input, appends it to a list, converts the list to a NumPy array,
                    and prints the resulting array.</p>
                <div class="wh">
                    <h3>Creating 1D, 2D, and 3D Arrays in NumPy</h3>

                    <p><strong>1. Creating a 1D array:</strong></p>
                    <pre>
                    <code>
import numpy as np

# Creating a 1D array using np.array()
a_1d = np.array([1, 2, 3, 4, 5])
print("1D Array:")
print(a_1d)
                    </code>
                    </pre>
                    <p><strong>2. Creating a 2D array:</strong></p>
                    <pre>
                    <code>
# Creating a 2D array using np.array()
a_2d = np.array([[1, 2, 3], [4, 5, 6]])
print("2D Array:")
print(a_2d)
                    </code>
                    </pre>
                    <p><strong>3. Creating an 3D array:</strong></p>
                    <pre>
                    <code>
# Creating an N-dimensional array using np.array()
a_nd = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print("N-dimensional Array:")
print(a_nd)
                    </code>
                    </pre>
                    <p>The above code demonstrates creating 1D, 2D, and N-dimensional arrays in NumPy using the
                        <code>np.array()</code> function. You can specify the elements of the array as nested lists,
                        with
                        each list representing a row in a 2D array or a higher-dimensional structure in N-dimensional
                        arrays.
                    </p>
                </div>
                <div class="wh">

                    <h3>Special Arrays in NumPy</h3>
                    <ul>
                        <li>NumPy provides functions to easily create special arrays, such as:</li>
                    </ul>
                    <p><strong>1- Zero Array</strong></p>
                    <pre>
        <code>
import numpy as np

# Creating a 1D zero array of length 3
print(np.zeros(3))

# Creating a 2D zero array of shape (3, 3)
print(np.zeros((3, 3)))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code>
[0. 0. 0.]
        
[[0. 0. 0.]
[0. 0. 0.]
[0. 0. 0.]]
        </code>
        </pre>
                    <p>The <code>np.zeros()</code> function creates an array filled with zeros. When used with a single
                        argument, it creates a 1D array of zeros with the specified length. When used with a tuple
                        specifying the shape, it creates a multi-dimensional array (in this case, a 2D array) filled
                        with
                        zeros.</p>
                    <p><strong>2. Ones Array:</strong> An array where all elements are ones.</p>
                    <pre>
        <code>
import numpy as np

# Creating a 1D ones array of length 3
print(np.ones(3))

# Creating a 2D ones array of shape (3, 3)
print(np.ones((3, 3)))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code>
[1. 1. 1.]

[[1. 1. 1.]
[1. 1. 1.]
[1. 1. 1.]]
        </code>
        </pre>

                    <p><strong>3. Full Array:</strong> An array filled with a specified value.</p>
                    <pre>
        <code>
# Creating a 1D full array of length 3 filled with 5
print(np.full(3, 5))

# Creating a 2D full array of shape (3, 3) filled with 7
print(np.full((3, 3), 7))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code>
[5 5 5]

[[7 7 7]
[7 7 7]
[7 7 7]]
        </code>
        </pre>

                    <p><strong>4. Identity Matrix:</strong> A square matrix with ones on the diagonal and zeros
                        elsewhere.
                    </p>
                    <pre>
        <code>
# Creating a 3x3 identity matrix
print(np.eye(3))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code>
[[1. 0. 0.]
[0. 1. 0.]
[0. 0. 1.]]
        </code>
        </pre>

                    <p><strong>5. Range Array:</strong> An array of evenly spaced values within a specified range.</p>
                    <pre>
        <code>
# Creating a range array from 0 to 5 (exclusive) with a step of 1
print(np.arange(0, 5, 1))

# Creating a range array from 0 to 10 (exclusive) with a step of 2
print(np.arange(0, 10, 2))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code>
[0 1 2 3 4]

[0 2 4 6 8]
        </code>
        </pre>
                </div>
                <div class="wh">
                    <h3>Attributes of NumPy Arrays</h3>

                    <p><strong>1. ndim:</strong> The ndim attribute returns the number of dimensions (axes) of the
                        array.
                    </p>
                    <pre>
                    <code>
import numpy as np

# Creating a NumPy array
a = np.array([[1, 2, 3], [4, 5, 6]])

# Using ndim attribute to get the number of dimensions
num_dimensions = a.ndim
print("Number of dimensions:", num_dimensions)
                    </code>
                    </pre>
                    <p>The ndim attribute in this example will return 2, indicating that the array 'a' is a
                        2-dimensional
                        array.</p>

                    <p><strong>2. shape:</strong> The shape attribute returns a tuple representing the shape of the
                        array.
                    </p>
                    <pre>
                    <code>
# Using shape attribute to get the shape of the array
array_shape = a.shape
print("Shape of the array:", array_shape)
                    </code>
                    </pre>
                    <p>The shape attribute will return (2, 3), indicating that the array 'a' has 2 rows and 3 columns.
                    </p>

                    <p><strong>3. size:</strong> The size attribute returns the total number of elements in the array.
                    </p>
                    <pre>
                    <code>
# Using size attribute to get the total number of elements
array_size = a.size
print("Size of the array:", array_size)
                    </code>
                    </pre>
                    <p>The size attribute will return 6, indicating that the array 'a' contains 6 elements.</p>

                    <p><strong>4. dtype:</strong> The dtype attribute returns the data type of the elements in the
                        array.
                    </p>
                    <pre>
                    <code>
# Using dtype attribute to get the data type of elements
array_dtype = a.dtype
print("Data type of the array:", array_dtype)
                    </code>
                    </pre>
                    <p>The dtype attribute will return int64, indicating that the elements in the array 'a' are of type
                        integer with 64-bit precision.</p>

                    <p>These attributes provide valuable information about the structure, size, and data type of NumPy
                        arrays, allowing for effective manipulation and analysis of array data.</p>
                </div>
                <div class="wh">
                    <h3>Upcasting in NumPy</h3>

                    <p>When performing operations or combining arrays with different data types in NumPy, there is a
                        concept
                        called "upcasting" where NumPy automatically converts the data types of the arrays to a common
                        data
                        type to ensure consistency.</p>

                    <p><strong>Example:</strong></p>
                    <pre>
                        <code>
import numpy as np

# Creating arrays with different data types
a = np.array([1, 2, 3])
b = np.array([1.1, 2.2, 3.3])

# Performing an operation that requires upcasting
c = a + b

print("Array a (int):", a)
print("Array b (float):", b)
print("Array c (upcasted):", c)
print("Data type of array c:", c.dtype)
                        </code>
                    </pre>
                    <p>In this example, array 'a' has integer elements, and array 'b' has floating-point elements. When
                        we
                        perform the addition operation (a + b), NumPy automatically upcasts the elements of array 'a' to
                        float64 to match the data type of array 'b', resulting in array 'c' with elements of type
                        float64.
                    </p>

                    <p>The output will show the arrays and their data types, confirming the upcasting that occurred
                        during
                        the operation.</p>

                    <p>Understanding upcasting is important when working with mixed data types in NumPy arrays to ensure
                        correct results and avoid unexpected behavior due to data type inconsistencies.</p>
                    <h3>Handling Mixed Data Types in NumPy Arrays</h3>

                    <p>NumPy arrays can handle mixed data types, but it's essential to understand how NumPy treats these
                        mixed types, especially during operations and array creation.</p>

                    <p><strong>Example 1: Integer and Float Elements</strong></p>
                    <pre>
                        <code>
import numpy as np

# Creating an array with integer and float elements
mixed_array = np.array([2, 3, 4.4, 4, 3])

print("Mixed-type array:", mixed_array)
print("Data type of the array:", mixed_array.dtype)
                        </code>
                    </pre>
                    <p>Output:</p>
                    <pre>
                        <code>
Mixed-type array: [2.  3.  4.4 4.  3. ]
Data type of the array: float64
                        </code>
                    </pre>

                    <p>In this example, the array contains both integers and floats. NumPy automatically upcasts the
                        integers to floating-point numbers to maintain consistency in operations, resulting in the
                        entire array being of data type float64.</p>

                    <p><strong>Example 2: Integer and String Elements</strong></p>
                    <pre>
                        <code>
# Creating an array with integer and string elements
mixed_array = np.array([3, 4, 5, '6', 4])

print("Mixed-type array:", mixed_array)
print("Data type of the array:", mixed_array.dtype)
                        </code>
                    </pre>
                    <p>Output:</p>
                    <pre>
                        <code>
Mixed-type array: ['3' '4' '5' '6' '4']
Data type of the array: &lt;U21
                        </code>
                    </pre>

                    <p>Here, the array contains integers and a string. NumPy upcasts the entire array to a string data
                        type (&lt;U21) because of the presence of a string element, ensuring consistency in the array's
                        data type.</p>

                    <p>Understanding how NumPy handles mixed data types is crucial for avoiding unexpected
                        behavior and ensuring correct data processing in array operations and manipulations.</p>

                </div>
                <div class="wh">
                    <h3>Creating N-dimensional Arrays with ndmin</h3>
                    <ul>
                        <li>The ndmin argument in np.array specifies the minimum number of dimensions an array should
                            have.</li>
                    </ul>
                    <pre>
                        <code>
import numpy as np

# Create a 1D array
arr = np.array([1, 2, 3])

# Increase the dimension of the array to 5 using ndmin argument
ndimarray = np.array(arr, ndmin=5)

# Print the shape of the new array
print(ndimarray.shape)
                        </code>
                    </pre>
                    <ul>
                        <li>np.array(arr, ndmin=5) creates a new array from arr and ensures it has a minimum of 5
                            dimensions using ndmin=5</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Random Number Generation in Numpy</h3>
                <ul>
                    <li>NumPy provides a suite of functions for generating random numbers and performing random
                        operations. These functions are part of the <strong>numpy.random</strong> module.</li>
                    <li>Role of Random Number Generation in NumPy:
                        <ol>
                            <li>Simulations and Modeling : Random numbers are essential for creating simulations that
                                mimic real-world phenomena, such as weather patterns, financial markets, or physical
                                processes. For example, Monte Carlo simulations rely heavily on random number generation
                                to model complex systems and assess the impact of uncertainty.</li>
                            <li>Statistical Analysis :

                                Random numbers are used in statistical methods such as bootstrapping and resampling to
                                estimate the distribution of a statistic by sampling with replacement from the original
                                data.</li>
                            <li>Machine Learning:

                                In machine learning, random numbers are used for initializing weights in neural
                                networks, splitting datasets into training and testing sets, shuffling data, and
                                augmenting data to improve model robustness.</li>
                            <li>Random Sampling:

                                Random number generation allows for the creation of random samples from larger datasets,
                                which is useful for exploratory data analysis, hypothesis testing, and creating training
                                datasets.</li>
                            <li>Data Augmentation:

                                In fields like computer vision and natural language processing, random transformations
                                such as rotations, translations, or noise addition are applied to data to create new
                                training samples, enhancing model generalization.</li>
                            <li>Cryptography:

                                Although cryptographically secure random numbers should be generated using specialized
                                libraries, random number generation in NumPy can be used for simulations and prototyping
                                cryptographic algorithms.</li>
                            <li>Games and Entertainment :

                                Random numbers are used to introduce unpredictability and variation in games, such as
                                shuffling cards, rolling dice, or generating random game scenarios.</li>
                            <li>Algorithm Testing:

                                Random number generation is used to create test cases and benchmark algorithms, ensuring
                                they perform well under different conditions and inputs.</li>
                        </ol>
                    </li>
                </ul>
                <h3>Basic Random Number Generation</h3>
                <ul>
                    <li>Generating Random Floats: The <strong>rand()</strong> function generates random floats between 0
                        and 1.
                        <pre>
                            <code>
import numpy as np
random_floats = np.random.rand(3)  # Generates an array of 3 random floats
print(random_floats)
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
[0.37454012 0.95071431 0.73199394]
                            </code>
                        </pre>
                    </li>
                    <li>Generating Random Integers: The <strong>randint()</strong> function generates random integers
                        within a specified range.
                        <pre>
                            <code>
random_integers = np.random.randint(1, 10, size=5)  # Generates an array of 5 random integers between 1 and 9
print(random_integers)
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
[8 1 5 9 3]
                            </code>
                        </pre>
                    </li>
                </ul>
                <h3>Creating Random Arrays</h3>
                <ul>
                    <li>Random Array of Given Shape: The <strong>rand()</strong> function can also be used to create
                        random arrays of a given shape.
                        <pre>
        <code>
random_array = np.random.rand(2, 3)  # Generates a 2x3 array of random floats
print(random_array)
        </code>
        </pre>
                        Output:
                        <pre>
                            <code>
[[0.59865848 0.15601864 0.15599452]
 [0.05808361 0.86617615 0.60111501]]
                            </code>
                        </pre>
                    </li>
                    <li>Random Integer Array of Given Shape: The <strong>randint()</strong> function can be used to
                        create arrays of random integers.
                        <pre>
        <code>
random_int_array = np.random.randint(1, 100, size=(2, 3))  # Generates a 2x3 array of random integers between 1 and 99
print(random_int_array)
        </code>
        </pre>
                        Output:
                        <pre>
                            <code>
[[12 84 56]
 [78 60 38]]
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Array Indexing and Slicing</h3>
                <ul>
                    <li>First, let's create a 2D array:</li>
                </ul>
                <pre>
                    <code>
import numpy as np

# Create a 1D array with values from 1 to 50
a = np.arange(1, 51)

# Reshape the 1D array to a 2D array with 10 rows and 5 columns
a = a.reshape(10, 5)
                    </code>
                </pre>
                <ul>
                    <li>
                        <code>a = np.arange(1, 51)</code> will create a 1D array that starts from 1 and goes up to 50 as
                        follows:
                        <pre>
                            <code>
[1, 2, 3, ..., 50]
                        </code>
                    </pre>
                    </li>
                    <li>
                        <code>a.reshape(10, 5)</code> will reshape the 1D array into a 2D array with 10 rows and 5
                        columns as follows:
                        <pre>
                            <code>
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                        </code>
                    </pre>
                    </li>
                </ul>
                <p><strong>Now, let's perform some indexing and slicing operations on the 2D array:</strong></p>
                <ul>
                    <li>Printing the first array, as this is now an array of arrays, and we are interested in printing
                        the first row:
                        <pre>
                            <code>
print(a[0])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
[ 1,  2,  3,  4,  5]
                            </code>
                        </pre>
                    </li>

                    <li>Printing the 3rd row array, which will be indexed as 2:
                        <pre>
                            <code>
print(a[2])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
[11, 12, 13, 14, 15]
                            </code>
                        </pre>
                    </li>

                    <li><code>a[0, 0]</code> - What will this print? 0, 0 means the 0th row (first row for our
                        understanding) and 0th column (1st column):
                        <pre>
                            <code>
print(a[0, 0])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
1
                            </code>
                        </pre>
                    </li>

                    <li>What will <code>a[3, 4]</code> print? It will print the element at the 3rd row and 4th column:
                        <pre>
                            <code>
print(a[3, 4])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
20
                            </code>
                        </pre>
                    </li>

                    <li><strong>a[2:5]</strong> - What does this <strong>:</strong> represent? That means slicing from
                        the 2nd
                        index (inclusive) to the 5th index (exclusive), which will give us rows 3 to 4:
                        <pre>
                            <code>
print(a[2:5])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code>
[[11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25]]
                            </code>
                        </pre>
                    </li>
                    <ul>
                        <li>Printing all the rows:
                            <pre>
                                <code>
print(a[0:10])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                            </code>
                        </pre>
                            If we provide <strong>0:100</strong>, this will also work because we are asking for a range
                            that exceeds the actual number of rows in the array. NumPy handles this gracefully by
                            returning all available rows.
                        </li>

                        <li>Printing a column: <strong>a[:, 2]</strong> - The first part before <strong>,</strong> is
                            for rows,
                            and after it is for columns. <strong>:</strong> means all rows, and <strong>2</strong> means
                            the 2nd
                            column:
                            <pre>
                                <code>
print(a[:, 2])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
[ 3,  8, 13, 18, 23, 28, 33, 38, 43, 48]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[2:5, 4]</strong> - This means selecting rows from index 2 to 4 and the element in
                            the
                            4th column:
                            <pre>
                                <code>
print(a[2:5, 4])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
[15, 20, 25]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, :]</strong> - This means selecting all rows and all columns:
                            <pre>
                                <code>
print(a[:, :])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, 2:5]</strong> - This means selecting all rows and columns from index 2 to 4:
                            <pre>
                                <code>
print(a[:, 2:5])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
[[ 3,  4,  5],
 [ 8,  9, 10],
 [13, 14, 15],
 [18, 19, 20],
 [23, 24, 25],
 [28, 29, 30],
 [33, 34, 35],
 [38, 39, 40],
 [43, 44, 45],
 [48, 49, 50]]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, 2:].dtype</strong> - This will give the data type of the elements in the array
                            starting from column index 2 to the end:
                            <pre>
                                <code>
print(a[:, 2:].dtype)
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code>
dtype('int64')
                            </code>
                        </pre>
                        </li>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Pandas 🐼</h2>
            <ul>
                <li>Pandas is a fast, powerful, flexible, and easy-to-use open-source data analysis and manipulation
                    tool built on top of the Python programming language.</li>
                <li>Pandas is one of the most popular and robust data analysis libraries in Python. Data analysts, data
                    scientists, and machine learning engineers utilize it essentially every day for projects involving
                    data wrangling, data manipulation, and data visualization.</li>
            </ul>

            <p><strong>Installation</strong></p>
            <ul>
                <li>Pandas must be installed first before you can use it in your system:</li>
            </ul>
            <pre>
                <code>
pip install pandas
                </code>
            </pre>
            <ul>
                <li>Once installed, it is now ready to be imported and used:</li>
            </ul>
            <pre>
                <code>
import pandas as pd
                </code>
            </pre>

            <h3>Working with Data</h3>
            <p>Pandas offers primarily two types of data structures: Series and DataFrames. These are designed in a way
                to make data fast and easier to analyze.</p>
            <ol>
                <li>Series: Pandas Series is a one-dimensional array object of key-value pairs of integers, strings,
                    floats, and other data types. Each element (value) of a Series is assigned a unique label, often
                    known as an index or key. Series are often used in data manipulation tasks.
                    <pre>
                        <code>
import pandas as pd
# Initialize the series object
num = pd.Series([12, 3, 2, 8])
print(num)
                        </code>
                    </pre>
                    Output:
                    <pre>
                        <code>
0    12
1     3
2     2
3     8
dtype: int64
                        </code>
                    </pre>
                </li>
                <li>DataFrame: DataFrames have a two-dimensional structure that is similar to a spreadsheet or table
                    with rows and columns. A DataFrame is basically an arrangement of two or more Series, with distinct
                    data types, such as name (string), age (int), and date_of_birth (datetime), in each column. To
                    create a DataFrame in Pandas, we use <strong>pandas.DataFrame()</strong>:
                    <pre>
                        <code>
import pandas as pd
# Initialize the DataFrame object
data = {
    'Name': ['John', 'Anna', 'Peter', 'Linda'],
    'Age': [28, 24, 35, 32],
    'Date_of_Birth': ['1996-05-24', '1999-03-17', '1988-12-05', '1991-08-12']
}
df = pd.DataFrame(data)
print(df)
                        </code>
                    </pre>
                    Output:
                    <pre>
                        <code>
    Name  Age Date_of_Birth
0   John   28    1996-05-24
1   Anna   24    1999-03-17
2  Peter   35    1988-12-05
3  Linda   32    1991-08-12
                        </code>
                    </pre>
                </li>
            </ol>
            <div class="in">
                <h3>Pandas Series with Python Lists</h3>
                <ul>
                    <li>A list in Python is a collection of elements which can include integers, strings, floats, and
                        other data types. Lists are mutable and ordered.</li>
                </ul>
                <pre>
                        <code>
lst = [1, 2, 3, 4, 5, 6]
print(lst)
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                    <code>
[1, 2, 3, 4, 5, 6]
                    </code>
                </pre>
                <p>There are some advantages of Series over lists:</p>
                <ul>
                    <li>Pandas Series provide more functionality, such as the ability to handle missing data, vectorized
                        operations, and the ability to use labels for indexing.</li>
                </ul>
                <p>We can create a Series using a list:</p>
                <pre>
                    <code>
import pandas as pd
series = pd.Series(lst)
print(series)
print(type(series))
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
&lt;class 'pandas.core.series.Series'>
                    </code>
                </pre>
                <ul>
                    <li>As you can see in the output, the 1D array is converted to a column with an index.</li>
                    <li>We can create a Series using a dictionary as well:</li>
                </ul>
                <pre>
                    <code>
data = {'a': 10, 'b': 20, 'c': 30}
series_dict = pd.Series(data)
print(series_dict)
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                    <code>
a    10
b    20
c    30
dtype: int64
                    </code>
                </pre>
                <h3>Creating Empty Series</h3>
                <ul>
                    <li>You don't have to provide anything; just an empty list or array.</li>
                    <li>By default, the data type is float.</li>
                </ul>
                <pre>
                    <code>
empty = pd.Series([])
print(empty)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
Series([], dtype: float64)
                    </code>
                </pre>

                <h3>Defining Your Own Index</h3>
                <pre>
                    <code>
a = pd.Series(['p', 'q', 'r', 's', 't'], index=[10, 11, 12, 13, 14])
print(a)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
10    p
11    q
12    r
13    s
14    t
dtype: object
                    </code>
                </pre>

                <h3>Giving Name to a Series</h3>
                <ul>
                    <li>Using this we can assign a name to the Series, which can be useful for identifying the Series in
                        a DataFrame or when displaying it.</li>
                </ul>
                <pre>
                    <code>
a = pd.Series(['p', 'q', 'r', 's', 't'], index=[10, 11, 12, 13, 14], name="alphabets")
print(a)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
10    p
11    q
12    r
13    s
14    t
Name: alphabets, dtype: object
                    </code>
                </pre>

                <h3>Creating Scalar Series</h3>
                <ul>
                    <li>A scalar Series is a Series where every element is the same scalar value.</li>
                </ul>
                <pre>
                    <code>
scalar_series = pd.Series(0.5)
print(scalar_series)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
0    0.5
dtype: float64
                    </code>
                </pre>
                <ul>
                    <li>This contains a single scalar value 0.5 repeated once.</li>
                </ul>

                <h3>Increasing the Quantity of the Scalar Values</h3>
                <ul>
                    <li>We can do this by specifying an index with the desired length.</li>
                </ul>
                <pre>
                    <code>
scalar_series = pd.Series(0.5, index=[1, 2, 3])
print(scalar_series)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
1    0.5
2    0.5
3    0.5
dtype: float64
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Pandas Series with Python Dictionary</h3>
                <ul>
                    <li>A dictionary in Python contains key-value pairs, where each key is unique and maps to a
                        corresponding value.</li>
                </ul>
                <p>Creating a Series using a dictionary:</p>
                <pre>
                    <code>
import pandas as pd
dict_series = pd.Series({'p': 1, 'q': 2, 'r': 3, 's': 4, 't': 5})
print(dict_series)
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code>
p    1
q    2
r    3
s    4
t    5
dtype: int64
                </code>
            </pre>

                <h3>Accessing the Data</h3>
                <pre>
                    <code>
print(dict_series[0])
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code>
                1
                </code>
            </pre>
                <ul>
                    <li>This will print the value associated with the first key in the Series, which is 1.</li>
                </ul>
                <pre>
                    <code>
print(dict_series[0:3])
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code>
p    1
q    2
r    3
dtype: int64
                </code>
            </pre>
                <ul>
                    <li>This will print the first three elements in the Series.</li>
                </ul>

                <h3>Getting the Maximum Value in the Dictionary Series</h3>
                <pre>
                    <code>
print(max(dict_series))
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code>
5
                </code>
            </pre>

                <h3>Increasing the Column Count</h3>
                <ul>
                    <li>Till now, it was containing only one column. Now we want three columns, and we can do this by
                        combining a dictionary and a list.</li>
                </ul>
                <pre>
                    <code>
dict_series = pd.Series({'p': [1, 5, 6], 'q': [2, 6, 7], 'r': [3, 7, 8], 's': [4, 8, 9], 't': [5, 9, 10]})
print(dict_series)
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code>
p    [1, 5, 6]
q    [2, 6, 7]
r    [3, 7, 8]
s    [4, 8, 9]
t    [5, 9, 10]
dtype: object
                </code>
            </pre>
            </div>
            <div class="in">
                <h3>Pandas DataFrame</h3>
                <ul>
                    <li>We know how to create pandas Series. Now we will create pandas DataFrame, which is a more
                        effective way of representing data in terms of rows and columns.</li>
                </ul>
                <p>Example:</p>
                <pre>
                    <code>
import pandas as pd
df = pd.DataFrame()
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
Empty DataFrame
Columns: []
Index: []
                    </code>
                </pre>
                <ul>
                    <li>It creates an empty DataFrame because we have not provided any data.</li>
                </ul>

                <h3>DataFrame using a List</h3>
                <pre>
                    <code>
lst = [1, 2, 3, 4, 5]
df = pd.DataFrame(lst)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
   0
0  1
1  2
2  3
3  4
4  5
                    </code>
                </pre>
                <ul>
                    <li>We will get a DataFrame with index values and one column containing the list elements.</li>
                </ul>

                <h3>Creating DataFrame with Multiple Columns</h3>
                <pre>
                    <code>
lst = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15]]
df = pd.DataFrame(lst)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
    0   1   2   3   4
0   1   2   3   4   5
1  11  12  13  14  15
                    </code>
                </pre>
                <ul>
                    <li>We will get a DataFrame with two rows and five columns, where each inner list represents a row.
                    </li>
                </ul>

                <h3>DataFrame using a Dictionary</h3>
                <pre>
                    <code>
a = [{'a': 5, 'b': 7, 'c': 9, 'd': 2},
     {'a': 4, 'b': 8, 'c': 19, 'd': 12}] # dictionary keys represent column names
df = pd.DataFrame(a)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
   a  b   c   d
0  5  7   9   2
1  4  8  19  12
                    </code>
                </pre>
                <ul>
                    <li>The dictionary keys become column names, and the values form the rows of the DataFrame.</li>
                </ul>

                <h3>Creating DataFrame using Pandas Series</h3>
                <pre>
                    <code>
b = {'RollNo.': pd.Series([1, 2, 3, 4, 5]),
     'Maths': pd.Series([67, 89, 23, 90, 56]),
     'Physics': pd.Series([12, 98, 44, 90, 78])}
df = pd.DataFrame(b)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
   RollNo.  Maths  Physics
0        1     67       12
1        2     89       98
2        3     23       44
3        4     90       90
4        5     56       78
                    </code>
                </pre>
                <ul>
                    <li>The Series objects form the columns of the DataFrame, with their indexes aligning to form rows.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Reading CSV (Comma Separated Values) as DataFrames</h3>
                <ul>
                    <li>CSV (Comma Separated Values) files are a common format for storing tabular data, where each line
                        represents a row, and columns are separated by commas.</li>
                    <li>CSV files are widely used because they are simple to read and write and can be processed by many
                        different applications.</li>
                    <li>Excel files with the extension .xlsx can also be saved as CSV files, which is a more generalized
                        format for data interchange. CSV files are plain text files that can be created and edited with
                        any text editor.</li>
                    <li>Using the <code>read_csv</code> method from Pandas, we can easily create a DataFrame from a CSV
                        file. This method offers many options for handling different types of data and file formats.
                    </li>
                    <li>Let's suppose we have a CSV file named <code>Salary_Data.csv</code> that contains two columns:
                        <code>YearsExperience</code> and <code>Salary</code>.
                    </li>
                    <li>Here is an example of the content of the <code>Salary_Data.csv</code> file:</li>
                </ul>
                <img src="../../images/csv1.svg" alt="" class="wb">
                <ul>
                    <li>We can use the following code to read the CSV file into a Pandas DataFrame and print its
                        contents:</li>
                </ul>
                <pre>
                    <code>
import pandas as pd
df = pd.read_csv('Salary_Data.csv')
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
        YearsExperience     Salary
    0               1.1   39343.00
    1               1.3   46205.00
    2               1.5   37731.00
    3               2.0   43525.00
    4               2.2   39891.00
    5               2.9   56642.00
    6               3.0   60150.00
    7               3.2   54445.00
    8               3.2   64445.00
    9               3.7   57189.00
    10              3.9   63218.00
    11              4.0   55794.00
    12              4.0   56957.00
    13              4.1   57081.00
    14              4.5   61111.00
    15              4.9   67938.00
    16              5.1   66029.00
    17              5.3   83088.00
    18              5.9   81363.00
    19              6.0   93940.00
    20              6.8   91738.00
    21              7.1   98273.00
    22              7.9  101302.00
    23              8.2  113812.00
    24              8.7  109431.00
    25              9.0  105582.00
    26              9.5  116969.00
    27              9.6  112635.00
    28             10.3  122391.00
    29             10.5  121872.00
                </code>
            </pre>
                <ul>
                    <li>The above code reads the CSV file into a DataFrame named <strong>df</strong> and prints its
                        contents.</li>
                    <li>Pandas provides various options in the <strong>read_csv</strong> method to handle different file
                        structures, such as specifying delimiters, handling missing values, and parsing dates.</li>
                    <li>Using <strong>df.head()</strong> and <strong>df.tail()</strong>, we can view the first and last
                        few rows
                        of the DataFrame, respectively.</li>
                    <li>We can also get summary statistics of the DataFrame using <strong>df.describe()</strong>.</li>
                </ul>
                <pre>
                    <code>
print(df.head())  # Displays the first 5 rows
print(df.tail())  # Displays the last 5 rows
print(df.describe())  # Displays summary statistics
                </code>
            </pre>
            </div>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing and Visualizing Data</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
    <style>
        li>pre {
            margin: 5px 0;
        }
    </style>
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="" class="link">Next Topic &rarr;</a>
                <a href="" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Processing and Visualizing Data</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Processing and Visualizing Data</h1>
        <ul>
            <li>In the modern data-driven world, the ability to effectively process and visualize data is crucial. Data
                processing involves transforming raw data into a meaningful format that can be analyzed and interpreted.
                Visualization, on the other hand, helps to present this processed data in a graphical format, making it
                easier to identify patterns, trends, and insights. Together, these skills enable data scientists and
                analysts to make informed decisions and communicate their findings clearly.</li>
            <li>Two powerful tools that aid in this process are NumPy and pandas. NumPy provides support for large,
                multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on
                these arrays. It forms the foundation for numerical computing in Python. pandas builds on NumPy by
                offering data structures and operations specifically designed for data manipulation and analysis, making
                it easier to handle and analyze large datasets. Before diving into the technical aspects like using
                NumPy for array manipulations, it's important to grasp the fundamental concepts of data processing and
                visualization, as these form the backbone of data analysis.</li>
        </ul>
        <div class="wh">
            <h2>NumPy</h2>
            <ul>
                <li>NumPy is an open-source library designed for working with arrays.</li>
                <li>It was developed in 2005 by Travis Oliphant.</li>
                <li>The name stands for Numerical Python and it is a critical data science library in Python, with many
                    other libraries depending on it.</li>
                <li>NumPy is extremely popular because it improves the performance of working with multi-dimensional
                    arrays. Mathematical operations on NumPy arrays are up to 50 times faster than iterating over Python
                    lists using loops. It requires fewer lines of code for mathematical operations compared to native
                    Python lists.</li>

                <li>It offers an indexing system for easily accessing portions of data within arrays.</li>
                <li>It contains built-in functions that improve the quality of code when working with arrays and
                    mathematics, such as linear algebra, array transformations, and other mathematical operations.</li>
            </ul>
            <h3>Purpose of NumPy</h3>
            <ul>
                <li>It is mostly used in data analytics for working with arrays and matrices, including
                    multi-dimensional arrays.</li>
                <li>It helps to solve complex mathematical and statistical operations, offering multiple functions for
                    working with 2D matrices and 3D tensors.</li>
            </ul>
            <div class="in">
                <h3>NumPy Arrays</h3>
                <ul>
                    <li>NumPy arrays are used to create n-dimensional arrays, allowing us to solve complex problems in
                        mathematics, statistics, linear algebra, and matrix operations.</li>

                    <li>NumPy provides efficient data structures for handling large datasets and performing fast
                        numerical computations.</li>
                    <li>With NumPy arrays, we can perform vectorized operations, which are much faster than traditional
                        loop-based operations on Python lists.</li>
                    <li>NumPy is widely used in scientific computing, machine learning, data analysis, and other fields
                        due to its speed and convenience.</li>
                    <li>It is a package, so first, we have to import it using: <code
                            class="language-py">import numpy as np</code>.
                        <br>Make sure it is installed on your system by using the command:
                        <pre>
                            <code class="language-py">
pip install numpy
                            </code>
                        </pre>
                    </li>
                </ul>
                <h3>Working with Arrays</h3>
                <pre>
                    <code class="language-py">
import numpy as np 

# Creating a 1D array
a = np.array([1, 2, 3, 4])
print(a)
                    </code>
                </pre>
                <p>The above code creates a 1D array and prints it.</p>
                <p><strong>Taking elements from the user and printing them:</strong></p>
                <pre>
                    <code class="language-py">
import numpy as np

# Taking input from the user
n = int(input("Enter the number of elements in the array: "))
elements = []

for i in range(n):
    element = int(input(f"Enter element {i + 1}: "))
    elements.append(element)

# Converting the list of elements to a NumPy array
elements_array = np.array(elements)

print("The created array is:", elements_array)
                    </code>
                </pre>
                <p>The above code takes the number of elements and each element from the user to create an array and
                    then prints the array. It prompts the user to enter the number of elements in the array, then
                    iteratively takes each element as input, appends it to a list, converts the list to a NumPy array,
                    and prints the resulting array.</p>
                <div class="wh">
                    <h3>Creating 1D, 2D, and 3D Arrays in NumPy</h3>

                    <p><strong>1. Creating a 1D array:</strong></p>
                    <pre>
                    <code class="language-py">
import numpy as np

# Creating a 1D array using np.array()
a_1d = np.array([1, 2, 3, 4, 5])
print("1D Array:")
print(a_1d)
                    </code>
                    </pre>
                    <p><strong>2. Creating a 2D array:</strong></p>
                    <pre>
                    <code class="language-py">
# Creating a 2D array using np.array()
a_2d = np.array([[1, 2, 3], [4, 5, 6]])
print("2D Array:")
print(a_2d)
                    </code>
                    </pre>
                    <p><strong>3. Creating an 3D array:</strong></p>
                    <pre>
                    <code class="language-py">
# Creating an N-dimensional array using np.array()
a_nd = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print("N-dimensional Array:")
print(a_nd)
                    </code>
                    </pre>
                    <p>The above code demonstrates creating 1D, 2D, and N-dimensional arrays in NumPy using the
                        <code class="language-py">np.array()</code> function. You can specify the elements of the
                        array as nested lists,
                        with
                        each list representing a row in a 2D array or a higher-dimensional structure in N-dimensional
                        arrays.
                    </p>
                </div>
                <div class="wh">

                    <h3>Special Arrays in NumPy</h3>
                    <ul>
                        <li>NumPy provides functions to easily create special arrays, such as:</li>
                    </ul>
                    <p><strong>1- Zero Array</strong></p>
                    <pre>
        <code class="language-py">
import numpy as np

# Creating a 1D zero array of length 3
print(np.zeros(3))

# Creating a 2D zero array of shape (3, 3)
print(np.zeros((3, 3)))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code class="language-py">
[0. 0. 0.]
        
[[0. 0. 0.]
[0. 0. 0.]
[0. 0. 0.]]
        </code>
        </pre>
                    <p>The <code class="language-py">np.zeros()</code> function creates an array filled with zeros.
                        When used with a single
                        argument, it creates a 1D array of zeros with the specified length. When used with a tuple
                        specifying the shape, it creates a multi-dimensional array (in this case, a 2D array) filled
                        with
                        zeros.</p>
                    <p><strong>2. Ones Array:</strong> An array where all elements are ones.</p>
                    <pre>
        <code class="language-py">
import numpy as np

# Creating a 1D ones array of length 3
print(np.ones(3))

# Creating a 2D ones array of shape (3, 3)
print(np.ones((3, 3)))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code class="language-py">
[1. 1. 1.]

[[1. 1. 1.]
[1. 1. 1.]
[1. 1. 1.]]
        </code>
        </pre>

                    <p><strong>3. Full Array:</strong> An array filled with a specified value.</p>
                    <pre>
        <code class="language-py">
# Creating a 1D full array of length 3 filled with 5
print(np.full(3, 5))

# Creating a 2D full array of shape (3, 3) filled with 7
print(np.full((3, 3), 7))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code class="language-py">
[5 5 5]

[[7 7 7]
[7 7 7]
[7 7 7]]
        </code>
        </pre>

                    <p><strong>4. Identity Matrix:</strong> A square matrix with ones on the diagonal and zeros
                        elsewhere.
                    </p>
                    <pre>
        <code class="language-py">
# Creating a 3x3 identity matrix
print(np.eye(3))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code class="language-py">
[[1. 0. 0.]
[0. 1. 0.]
[0. 0. 1.]]
        </code>
        </pre>

                    <p><strong>5. Range Array:</strong> An array of evenly spaced values within a specified range.</p>
                    <pre>
        <code class="language-py">
# Creating a range array from 0 to 5 (exclusive) with a step of 1
print(np.arange(0, 5, 1))

# Creating a range array from 0 to 10 (exclusive) with a step of 2
print(np.arange(0, 10, 2))
        </code>
        </pre>
                    <p>Output:</p>
                    <pre>
        <code class="language-py">
[0 1 2 3 4]

[0 2 4 6 8]
        </code>
        </pre>
                </div>
                <div class="wh">
                    <h3>Attributes of NumPy Arrays</h3>

                    <p><strong>1. ndim:</strong> The ndim attribute returns the number of dimensions (axes) of the
                        array.
                    </p>
                    <pre>
                    <code class="language-py">
import numpy as np

# Creating a NumPy array
a = np.array([[1, 2, 3], [4, 5, 6]])

# Using ndim attribute to get the number of dimensions
num_dimensions = a.ndim
print("Number of dimensions:", num_dimensions)
                    </code>
                    </pre>
                    <p>The ndim attribute in this example will return 2, indicating that the array 'a' is a
                        2-dimensional
                        array.</p>

                    <p><strong>2. shape:</strong> The shape attribute returns a tuple representing the shape of the
                        array.
                    </p>
                    <pre>
                    <code class="language-py">
# Using shape attribute to get the shape of the array
array_shape = a.shape
print("Shape of the array:", array_shape)
                    </code>
                    </pre>
                    <p>The shape attribute will return (2, 3), indicating that the array 'a' has 2 rows and 3 columns.
                    </p>

                    <p><strong>3. size:</strong> The size attribute returns the total number of elements in the array.
                    </p>
                    <pre>
                    <code class="language-py">
# Using size attribute to get the total number of elements
array_size = a.size
print("Size of the array:", array_size)
                    </code>
                    </pre>
                    <p>The size attribute will return 6, indicating that the array 'a' contains 6 elements.</p>

                    <p><strong>4. dtype:</strong> The dtype attribute returns the data type of the elements in the
                        array.
                    </p>
                    <pre>
                    <code class="language-py">
# Using dtype attribute to get the data type of elements
array_dtype = a.dtype
print("Data type of the array:", array_dtype)
                    </code>
                    </pre>
                    <p>The dtype attribute will return int64, indicating that the elements in the array 'a' are of type
                        integer with 64-bit precision.</p>

                    <p>These attributes provide valuable information about the structure, size, and data type of NumPy
                        arrays, allowing for effective manipulation and analysis of array data.</p>
                </div>
                <div class="wh">
                    <h3>Upcasting in NumPy</h3>

                    <p>When performing operations or combining arrays with different data types in NumPy, there is a
                        concept
                        called "upcasting" where NumPy automatically converts the data types of the arrays to a common
                        data
                        type to ensure consistency.</p>

                    <p><strong>Example:</strong></p>
                    <pre>
                        <code class="language-py">
import numpy as np

# Creating arrays with different data types
a = np.array([1, 2, 3])
b = np.array([1.1, 2.2, 3.3])

# Performing an operation that requires upcasting
c = a + b

print("Array a (int):", a)
print("Array b (float):", b)
print("Array c (upcasted):", c)
print("Data type of array c:", c.dtype)
                        </code>
                    </pre>
                    <p>In this example, array 'a' has integer elements, and array 'b' has floating-point elements. When
                        we
                        perform the addition operation (a + b), NumPy automatically upcasts the elements of array 'a' to
                        float64 to match the data type of array 'b', resulting in array 'c' with elements of type
                        float64.
                    </p>

                    <p>The output will show the arrays and their data types, confirming the upcasting that occurred
                        during
                        the operation.</p>

                    <p>Understanding upcasting is important when working with mixed data types in NumPy arrays to ensure
                        correct results and avoid unexpected behavior due to data type inconsistencies.</p>
                    <h3>Handling Mixed Data Types in NumPy Arrays</h3>

                    <p>NumPy arrays can handle mixed data types, but it's essential to understand how NumPy treats these
                        mixed types, especially during operations and array creation.</p>

                    <p><strong>Example 1: Integer and Float Elements</strong></p>
                    <pre>
                        <code class="language-py">
import numpy as np

# Creating an array with integer and float elements
mixed_array = np.array([2, 3, 4.4, 4, 3])

print("Mixed-type array:", mixed_array)
print("Data type of the array:", mixed_array.dtype)
                        </code>
                    </pre>
                    <p>Output:</p>
                    <pre>
                        <code class="language-py">
Mixed-type array: [2.  3.  4.4 4.  3. ]
Data type of the array: float64
                        </code>
                    </pre>

                    <p>In this example, the array contains both integers and floats. NumPy automatically upcasts the
                        integers to floating-point numbers to maintain consistency in operations, resulting in the
                        entire array being of data type float64.</p>

                    <p><strong>Example 2: Integer and String Elements</strong></p>
                    <pre>
                        <code class="language-py">
# Creating an array with integer and string elements
mixed_array = np.array([3, 4, 5, '6', 4])

print("Mixed-type array:", mixed_array)
print("Data type of the array:", mixed_array.dtype)
                        </code>
                    </pre>
                    <p>Output:</p>
                    <pre>
                        <code class="language-py">
Mixed-type array: ['3' '4' '5' '6' '4']
Data type of the array: &lt;U21
                        </code>
                    </pre>

                    <p>Here, the array contains integers and a string. NumPy upcasts the entire array to a string data
                        type (&lt;U21) because of the presence of a string element, ensuring consistency in the array's
                        data type.</p>

                    <p>Understanding how NumPy handles mixed data types is crucial for avoiding unexpected
                        behavior and ensuring correct data processing in array operations and manipulations.</p>

                </div>
                <div class="wh">
                    <h3>Creating N-dimensional Arrays with ndmin</h3>
                    <ul>
                        <li>The ndmin argument in np.array specifies the minimum number of dimensions an array should
                            have.</li>
                    </ul>
                    <pre>
                        <code class="language-py">
import numpy as np

# Create a 1D array
arr = np.array([1, 2, 3])

# Increase the dimension of the array to 5 using ndmin argument
ndimarray = np.array(arr, ndmin=5)

# Print the shape of the new array
print(ndimarray.shape)
                        </code>
                    </pre>
                    <ul>
                        <li>np.array(arr, ndmin=5) creates a new array from arr and ensures it has a minimum of 5
                            dimensions using ndmin=5</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Random Number Generation in Numpy</h3>
                <ul>
                    <li>NumPy provides a suite of functions for generating random numbers and performing random
                        operations. These functions are part of the <strong>numpy.random</strong> module.</li>
                    <li>Role of Random Number Generation in NumPy:
                        <ol>
                            <li>Simulations and Modeling : Random numbers are essential for creating simulations that
                                mimic real-world phenomena, such as weather patterns, financial markets, or physical
                                processes. For example, Monte Carlo simulations rely heavily on random number generation
                                to model complex systems and assess the impact of uncertainty.</li>
                            <li>Statistical Analysis :

                                Random numbers are used in statistical methods such as bootstrapping and resampling to
                                estimate the distribution of a statistic by sampling with replacement from the original
                                data.</li>
                            <li>Machine Learning:

                                In machine learning, random numbers are used for initializing weights in neural
                                networks, splitting datasets into training and testing sets, shuffling data, and
                                augmenting data to improve model robustness.</li>
                            <li>Random Sampling:

                                Random number generation allows for the creation of random samples from larger datasets,
                                which is useful for exploratory data analysis, hypothesis testing, and creating training
                                datasets.</li>
                            <li>Data Augmentation:

                                In fields like computer vision and natural language processing, random transformations
                                such as rotations, translations, or noise addition are applied to data to create new
                                training samples, enhancing model generalization.</li>
                            <li>Cryptography:

                                Although cryptographically secure random numbers should be generated using specialized
                                libraries, random number generation in NumPy can be used for simulations and prototyping
                                cryptographic algorithms.</li>
                            <li>Games and Entertainment :

                                Random numbers are used to introduce unpredictability and variation in games, such as
                                shuffling cards, rolling dice, or generating random game scenarios.</li>
                            <li>Algorithm Testing:

                                Random number generation is used to create test cases and benchmark algorithms, ensuring
                                they perform well under different conditions and inputs.</li>
                        </ol>
                    </li>
                </ul>
                <h3>Basic Random Number Generation</h3>
                <ul>
                    <li>Generating Random Floats: The <strong>rand()</strong> function generates random floats between 0
                        and 1.
                        <pre>
                            <code class="language-py">
import numpy as np
random_floats = np.random.rand(3)  # Generates an array of 3 random floats
print(random_floats)
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[0.37454012 0.95071431 0.73199394]
                            </code>
                        </pre>
                    </li>
                    <li>Generating Random Integers: The <strong>randint()</strong> function generates random integers
                        within a specified range.
                        <pre>
                            <code class="language-py">
random_integers = np.random.randint(1, 10, size=5)  # Generates an array of 5 random integers between 1 and 9
print(random_integers)
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[8 1 5 9 3]
                            </code>
                        </pre>
                    </li>
                </ul>
                <h3>Creating Random Arrays</h3>
                <ul>
                    <li>Random Array of Given Shape: The <strong>rand()</strong> function can also be used to create
                        random arrays of a given shape.
                        <pre>
        <code class="language-py">
random_array = np.random.rand(2, 3)  # Generates a 2x3 array of random floats
print(random_array)
        </code>
        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[[0.59865848 0.15601864 0.15599452]
 [0.05808361 0.86617615 0.60111501]]
                            </code>
                        </pre>
                    </li>
                    <li>Random Integer Array of Given Shape: The <strong>randint()</strong> function can be used to
                        create arrays of random integers.
                        <pre>
        <code class="language-py">
random_int_array = np.random.randint(1, 100, size=(2, 3))  # Generates a 2x3 array of random integers between 1 and 99
print(random_int_array)
        </code>
        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[[12 84 56]
 [78 60 38]]
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Array Indexing and Slicing</h3>
                <ul>
                    <li>First, let's create a 2D array:</li>
                </ul>
                <pre>
                    <code class="language-py">
import numpy as np

# Create a 1D array with values from 1 to 50
a = np.arange(1, 51)

# Reshape the 1D array to a 2D array with 10 rows and 5 columns
a = a.reshape(10, 5)
                    </code>
                </pre>
                <ul>
                    <li>
                        <code class="language-py">a = np.arange(1, 51)</code> will create a 1D array that starts
                        from 1 and goes up to 50 as
                        follows:
                        <pre>
                            <code class="language-py">
[1, 2, 3, ..., 50]
                        </code>
                    </pre>
                    </li>
                    <li>
                        <code class="language-py">a.reshape(10, 5)</code> will reshape the 1D array into a 2D array
                        with 10 rows and 5
                        columns as follows:
                        <pre>
                            <code class="language-py">
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                        </code>
                    </pre>
                    </li>
                </ul>
                <p><strong>Now, let's perform some indexing and slicing operations on the 2D array:</strong></p>
                <ul>
                    <li>Printing the first array, as this is now an array of arrays, and we are interested in printing
                        the first row:
                        <pre>
                            <code class="language-py">
print(a[0])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[ 1,  2,  3,  4,  5]
                            </code>
                        </pre>
                    </li>

                    <li>Printing the 3rd row array, which will be indexed as 2:
                        <pre>
                            <code class="language-py">
print(a[2])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[11, 12, 13, 14, 15]
                            </code>
                        </pre>
                    </li>

                    <li><code class="language-py">a[0, 0]</code> - What will this print? 0, 0 means the 0th row
                        (first row for our
                        understanding) and 0th column (1st column):
                        <pre>
                            <code class="language-py">
print(a[0, 0])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
1
                            </code>
                        </pre>
                    </li>

                    <li>What will <code class="language-py">a[3, 4]</code> print? It will print the element at the
                        3rd row and 4th column:
                        <pre>
                            <code class="language-py">
print(a[3, 4])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
20
                            </code>
                        </pre>
                    </li>

                    <li><strong>a[2:5]</strong> - What does this <strong>:</strong> represent? That means slicing from
                        the 2nd
                        index (inclusive) to the 5th index (exclusive), which will give us rows 3 to 4:
                        <pre>
                            <code class="language-py">
print(a[2:5])
                            </code>
                        </pre>
                        Output:
                        <pre>
                            <code class="language-py">
[[11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25]]
                            </code>
                        </pre>
                    </li>
                    <ul>
                        <li>Printing all the rows:
                            <pre>
                                <code class="language-py">
print(a[0:10])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                            </code>
                        </pre>
                            If we provide <strong>0:100</strong>, this will also work because we are asking for a range
                            that exceeds the actual number of rows in the array. NumPy handles this gracefully by
                            returning all available rows.
                        </li>

                        <li>Printing a column: <strong>a[:, 2]</strong> - The first part before <strong>,</strong> is
                            for rows,
                            and after it is for columns. <strong>:</strong> means all rows, and <strong>2</strong> means
                            the 2nd
                            column:
                            <pre>
                                <code class="language-py">
print(a[:, 2])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
[ 3,  8, 13, 18, 23, 28, 33, 38, 43, 48]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[2:5, 4]</strong> - This means selecting rows from index 2 to 4 and the element in
                            the
                            4th column:
                            <pre>
                                <code class="language-py">
print(a[2:5, 4])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
[15, 20, 25]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, :]</strong> - This means selecting all rows and all columns:
                            <pre>
                                <code class="language-py">
print(a[:, :])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30],
 [31, 32, 33, 34, 35],
 [36, 37, 38, 39, 40],
 [41, 42, 43, 44, 45],
 [46, 47, 48, 49, 50]]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, 2:5]</strong> - This means selecting all rows and columns from index 2 to 4:
                            <pre>
                                <code class="language-py">
print(a[:, 2:5])
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
[[ 3,  4,  5],
 [ 8,  9, 10],
 [13, 14, 15],
 [18, 19, 20],
 [23, 24, 25],
 [28, 29, 30],
 [33, 34, 35],
 [38, 39, 40],
 [43, 44, 45],
 [48, 49, 50]]
                            </code>
                        </pre>
                        </li>

                        <li><strong>a[:, 2:].dtype</strong> - This will give the data type of the elements in the array
                            starting from column index 2 to the end:
                            <pre>
                                <code class="language-py">
print(a[:, 2:].dtype)
                            </code>
                        </pre>
                            Output:
                            <pre>
                                <code class="language-py">
dtype('int64')
                            </code>
                        </pre>
                        </li>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Pandas 🐼</h2>
            <ul>
                <li>Pandas is a fast, powerful, flexible, and easy-to-use open-source data analysis and manipulation
                    tool built on top of the Python programming language.</li>
                <li>Pandas is one of the most popular and robust data analysis libraries in Python. Data analysts, data
                    scientists, and machine learning engineers utilize it essentially every day for projects involving
                    data wrangling, data manipulation, and data visualization.</li>
            </ul>

            <p><strong>Installation</strong></p>
            <ul>
                <li>Pandas must be installed first before you can use it in your system:</li>
            </ul>
            <pre>
                <code class="language-py">
pip install pandas
                </code>
            </pre>
            <ul>
                <li>Once installed, it is now ready to be imported and used:</li>
            </ul>
            <pre>
                <code class="language-py">
import pandas as pd
                </code>
            </pre>

            <h3>Working with Data</h3>
            <p>Pandas offers primarily two types of data structures: Series and DataFrames. These are designed in a way
                to make data fast and easier to analyze.</p>
            <ol>
                <li>Series: Pandas Series is a one-dimensional array object of key-value pairs of integers, strings,
                    floats, and other data types. Each element (value) of a Series is assigned a unique label, often
                    known as an index or key. Series are often used in data manipulation tasks.
                    <pre>
                        <code class="language-py">
import pandas as pd
# Initialize the series object
num = pd.Series([12, 3, 2, 8])
print(num)
                        </code>
                    </pre>
                    Output:
                    <pre>
                        <code class="language-py">
0    12
1     3
2     2
3     8
dtype: int64
                        </code>
                    </pre>
                </li>
                <li>DataFrame: DataFrames have a two-dimensional structure that is similar to a spreadsheet or table
                    with rows and columns. A DataFrame is basically an arrangement of two or more Series, with distinct
                    data types, such as name (string), age (int), and date_of_birth (datetime), in each column. To
                    create a DataFrame in Pandas, we use <strong>pandas.DataFrame()</strong>:
                    <pre>
                        <code class="language-py">
import pandas as pd
# Initialize the DataFrame object
data = {
    'Name': ['John', 'Anna', 'Peter', 'Linda'],
    'Age': [28, 24, 35, 32],
    'Date_of_Birth': ['1996-05-24', '1999-03-17', '1988-12-05', '1991-08-12']
}
df = pd.DataFrame(data)
print(df)
                        </code>
                    </pre>
                    Output:
                    <pre>
                        <code class="language-py">
    Name  Age Date_of_Birth
0   John   28    1996-05-24
1   Anna   24    1999-03-17
2  Peter   35    1988-12-05
3  Linda   32    1991-08-12
                        </code>
                    </pre>
                </li>
            </ol>
            <div class="in">
                <h3>Pandas Series with Python Lists</h3>
                <ul>
                    <li>A list in Python is a collection of elements which can include integers, strings, floats, and
                        other data types. Lists are mutable and ordered.</li>
                </ul>
                <pre>
                        <code class="language-py">
lst = [1, 2, 3, 4, 5, 6]
print(lst)
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
[1, 2, 3, 4, 5, 6]
                    </code>
                </pre>
                <p>There are some advantages of Series over lists:</p>
                <ul>
                    <li>Pandas Series provide more functionality, such as the ability to handle missing data, vectorized
                        operations, and the ability to use labels for indexing.</li>
                </ul>
                <p>We can create a Series using a list:</p>
                <pre>
                    <code class="language-py">
import pandas as pd
series = pd.Series(lst)
print(series)
print(type(series))
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
&lt;class 'pandas.core.series.Series'>
                    </code>
                </pre>
                <ul>
                    <li>As you can see in the output, the 1D array is converted to a column with an index.</li>
                    <li>We can create a Series using a dictionary as well:</li>
                </ul>
                <pre>
                    <code class="language-py">
data = {'a': 10, 'b': 20, 'c': 30}
series_dict = pd.Series(data)
print(series_dict)
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
a    10
b    20
c    30
dtype: int64
                    </code>
                </pre>
                <h3>Creating Empty Series</h3>
                <ul>
                    <li>You don't have to provide anything; just an empty list or array.</li>
                    <li>By default, the data type is float.</li>
                </ul>
                <pre>
                    <code class="language-py">
empty = pd.Series([])
print(empty)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
Series([], dtype: float64)
                    </code>
                </pre>

                <h3>Defining Your Own Index</h3>
                <pre>
                    <code class="language-py">
a = pd.Series(['p', 'q', 'r', 's', 't'], index=[10, 11, 12, 13, 14])
print(a)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
10    p
11    q
12    r
13    s
14    t
dtype: object
                    </code>
                </pre>

                <h3>Giving Name to a Series</h3>
                <ul>
                    <li>Using this we can assign a name to the Series, which can be useful for identifying the Series in
                        a DataFrame or when displaying it.</li>
                </ul>
                <pre>
                    <code class="language-py">
a = pd.Series(['p', 'q', 'r', 's', 't'], index=[10, 11, 12, 13, 14], name="alphabets")
print(a)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
10    p
11    q
12    r
13    s
14    t
Name: alphabets, dtype: object
                    </code>
                </pre>

                <h3>Creating Scalar Series</h3>
                <ul>
                    <li>A scalar Series is a Series where every element is the same scalar value.</li>
                </ul>
                <pre>
                    <code class="language-py">
scalar_series = pd.Series(0.5)
print(scalar_series)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
0    0.5
dtype: float64
                    </code>
                </pre>
                <ul>
                    <li>This contains a single scalar value 0.5 repeated once.</li>
                </ul>

                <h3>Increasing the Quantity of the Scalar Values</h3>
                <ul>
                    <li>We can do this by specifying an index with the desired length.</li>
                </ul>
                <pre>
                    <code class="language-py">
scalar_series = pd.Series(0.5, index=[1, 2, 3])
print(scalar_series)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
1    0.5
2    0.5
3    0.5
dtype: float64
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Pandas Series with Python Dictionary</h3>
                <ul>
                    <li>A dictionary in Python contains key-value pairs, where each key is unique and maps to a
                        corresponding value.</li>
                </ul>
                <p>Creating a Series using a dictionary:</p>
                <pre>
                    <code class="language-py">
import pandas as pd
dict_series = pd.Series({'p': 1, 'q': 2, 'r': 3, 's': 4, 't': 5})
print(dict_series)
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
p    1
q    2
r    3
s    4
t    5
dtype: int64
                </code>
            </pre>

                <h3>Accessing the Data</h3>
                <pre>
                    <code class="language-py">
print(dict_series[0])
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
1
                </code>
            </pre>
                <ul>
                    <li>This will print the value associated with the first key in the Series, which is 1.</li>
                </ul>
                <pre>
                    <code class="language-py">
print(dict_series[0:3])
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
p    1
q    2
r    3
dtype: int64
                </code>
            </pre>
                <ul>
                    <li>This will print the first three elements in the Series.</li>
                </ul>

                <h3>Getting the Maximum Value in the Dictionary Series</h3>
                <pre>
                    <code class="language-py">
print(max(dict_series))
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
5
                </code>
            </pre>

                <h3>Increasing the Column Count</h3>
                <ul>
                    <li>Till now, it was containing only one column. Now we want three columns, and we can do this by
                        combining a dictionary and a list.</li>
                </ul>
                <pre>
                    <code class="language-py">
dict_series = pd.Series({'p': [1, 5, 6], 'q': [2, 6, 7], 'r': [3, 7, 8], 's': [4, 8, 9], 't': [5, 9, 10]})
print(dict_series)
                </code>
            </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
p    [1, 5, 6]
q    [2, 6, 7]
r    [3, 7, 8]
s    [4, 8, 9]
t    [5, 9, 10]
dtype: object
                </code>
            </pre>
            </div>
            <div class="in">
                <h3>Pandas DataFrame</h3>
                <ul>
                    <li>We know how to create pandas Series. Now we will create pandas DataFrame, which is a more
                        effective way of representing data in terms of rows and columns.</li>
                </ul>
                <p>Example:</p>
                <pre>
                    <code class="language-py">
import pandas as pd
df = pd.DataFrame()
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
Empty DataFrame
Columns: []
Index: []
                    </code>
                </pre>
                <ul>
                    <li>It creates an empty DataFrame because we have not provided any data.</li>
                </ul>

                <h3>DataFrame using a List</h3>
                <pre>
                    <code class="language-py">
lst = [1, 2, 3, 4, 5]
df = pd.DataFrame(lst)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
   0
0  1
1  2
2  3
3  4
4  5
                    </code>
                </pre>
                <ul>
                    <li>We will get a DataFrame with index values and one column containing the list elements.</li>
                </ul>

                <h3>Creating DataFrame with Multiple Columns</h3>
                <pre>
                    <code class="language-py">
lst = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15]]
df = pd.DataFrame(lst)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
    0   1   2   3   4
0   1   2   3   4   5
1  11  12  13  14  15
                    </code>
                </pre>
                <ul>
                    <li>We will get a DataFrame with two rows and five columns, where each inner list represents a row.
                    </li>
                </ul>

                <h3>DataFrame using a Dictionary</h3>
                <pre>
                    <code class="language-py">
a = [{'a': 5, 'b': 7, 'c': 9, 'd': 2},
     {'a': 4, 'b': 8, 'c': 19, 'd': 12}] # dictionary keys represent column names
df = pd.DataFrame(a)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
   a  b   c   d
0  5  7   9   2
1  4  8  19  12
                    </code>
                </pre>
                <ul>
                    <li>The dictionary keys become column names, and the values form the rows of the DataFrame.</li>
                </ul>

                <h3>Creating DataFrame using Pandas Series</h3>
                <pre>
                    <code class="language-py">
b = {'RollNo.': pd.Series([1, 2, 3, 4, 5]),
     'Maths': pd.Series([67, 89, 23, 90, 56]),
     'Physics': pd.Series([12, 98, 44, 90, 78])}
df = pd.DataFrame(b)
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
   RollNo.  Maths  Physics
0        1     67       12
1        2     89       98
2        3     23       44
3        4     90       90
4        5     56       78
                    </code>
                </pre>
                <ul>
                    <li>The Series objects form the columns of the DataFrame, with their indexes aligning to form rows.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Reading CSV (Comma Separated Values) as DataFrames</h3>
                <ul>
                    <li>CSV (Comma Separated Values) files are a common format for storing tabular data, where each line
                        represents a row, and columns are separated by commas.</li>
                    <li>CSV files are widely used because they are simple to read and write and can be processed by many
                        different applications.</li>
                    <li>Excel files with the extension .xlsx can also be saved as CSV files, which is a more generalized
                        format for data interchange. CSV files are plain text files that can be created and edited with
                        any text editor.</li>
                    <li>Using the <code class="language-py">read_csv</code> method from Pandas, we can easily create
                        a DataFrame from a CSV
                        file. This method offers many options for handling different types of data and file formats.
                    </li>
                    <li>Let's suppose we have a CSV file named <code class="language-py">Salary_Data.csv</code> that
                        contains two columns:
                        <code class="language-py">YearsExperience</code> and <code class="language-py">Salary</code>.
                    </li>
                    <li><a class="ba"
                            href="https://github.com/Pravin-hub-rgb/BCA/tree/master/resources/sem4/python_tbc401/unit5/program"
                            target="_blank">Access
                            the Salary_Data.csv file from here &neArr;</a></li>
                    <li>Here is an example of the content of the <strong>Salary_Data.csv</strong>
                        file:</li>
                </ul>
                <img src="../../images/csv1.svg" alt="" class="wb">
                <ul>
                    <li>We can use the following code to read the CSV file into a Pandas DataFrame and print its
                        contents:</li>
                </ul>
                <pre>
                    <code class="language-py">
import pandas as pd
df = pd.read_csv('Salary_Data.csv')
print(df)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code class="language-py">
        YearsExperience     Salary
    0               1.1   39343.00
    1               1.3   46205.00
    2               1.5   37731.00
    3               2.0   43525.00
    4               2.2   39891.00
    5               2.9   56642.00
    6               3.0   60150.00
    7               3.2   54445.00
    8               3.2   64445.00
    9               3.7   57189.00
    10              3.9   63218.00
    11              4.0   55794.00
    12              4.0   56957.00
    13              4.1   57081.00
    14              4.5   61111.00
    15              4.9   67938.00
    16              5.1   66029.00
    17              5.3   83088.00
    18              5.9   81363.00
    19              6.0   93940.00
    20              6.8   91738.00
    21              7.1   98273.00
    22              7.9  101302.00
    23              8.2  113812.00
    24              8.7  109431.00
    25              9.0  105582.00
    26              9.5  116969.00
    27              9.6  112635.00
    28             10.3  122391.00
    29             10.5  121872.00
                </code>
            </pre>
                <ul>
                    <li>The above code reads the CSV file into a DataFrame named <strong>df</strong> and prints its
                        contents.</li>
                    <li>Pandas provides various options in the <strong>read_csv</strong> method to handle different file
                        structures, such as specifying delimiters, handling missing values, and parsing dates.</li>
                    <li>Using <strong>df.head()</strong> and <strong>df.tail()</strong>, we can view the first and last
                        few rows of the DataFrame, respectively.</li>
                    <li>We can also get summary statistics of the DataFrame using <strong>df.describe()</strong> like
                        count, mean, min, max, etc.</li>
                </ul>
                <pre>
                        <code class="language-py">
# Display the first 5 rows
print(df.head())

# Display the last 5 rows
print(df.tail())

# Display the last 8 rows
print(df.tail(8))

# Display summary statistics
print(df.describe())
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                        <code>
    YearsExperience    Salary
0              1.1   39343.0
1              1.3   46205.0
2              1.5   37731.0
3              2.0   43525.0
4              2.2   39891.0
                    
    YearsExperience    Salary
25             9.0  105582.0
26             9.5  116969.0
27             9.6  112635.0
28            10.3  122391.0
29            10.5  121872.0

    YearsExperience    Salary
22             7.9  101302.0
23             8.2  113812.0
24             8.7  109431.0
25             9.0  105582.0
26             9.5  116969.0
27             9.6  112635.0
28            10.3  122391.0
29            10.5  121872.0

        YearsExperience         Salary
count        30.000000      30.000000
mean          5.313333   76003.000000
std           2.937071   27414.429785
min           1.100000   37731.000000
25%           3.200000   56720.500000
50%           4.850000   65237.500000
75%           7.150000   93877.500000
max          10.500000  122391.000000
                        </code>
                    </pre>
                <ul>
                    <li><code>df.columns</code> gives the column labels of the DataFrame.
                        <pre>
                                <code class="language-py">
print(df.columns)
                                </code>
                            </pre>
                        <p>Output:</p>
                        <pre>
                                <code>
Index(['YearsExperience', 'Salary'], dtype='object')
                                </code>
                            </pre>
                    </li>
                    <li><code>df.shape</code> gives the dimensions of the DataFrame (rows, columns).
                        <pre>
                                <code class="language-py">
print(df.shape)
                                </code>
                            </pre>
                        <p>Output:</p>
                        <pre>
                                <code>
(30, 2)
                                </code>
                            </pre>
                    </li>
                    <li><code>df.size</code> gives the total number of elements in the DataFrame.
                        <pre>
                                <code class="language-py">
print(df.size)
                                </code>
                            </pre>
                        <p>Output:</p>
                        <pre>
                                <code>
60
                                </code>
                            </pre>
                    </li>
                    <li><code>df.info()</code> gives a concise summary of the DataFrame, including the index dtype,
                        column dtypes, non-null values, and memory usage.
                        <pre>
        <code class="language-py">
# Display DataFrame information
df.info()
        </code>
    </pre>
                        <p>Output:</p>
                        <pre>
                            <code>
&lt;class 'pandas.core.frame.DataFrame'>
RangeIndex: 30 entries, 0 to 29
Data columns (total 2 columns):
 #   Column           Non-Null Count  Dtype  
---  ------           --------------  -----  
 0   YearsExperience  30 non-null     float64
 1   Salary           30 non-null     float64
dtypes: float64(2)
memory usage: 608.0 bytes
                            </code>
                        </pre>
                    </li>
                </ul>
                <p>Now we will work with a different type of CSV file that contains complex data. This file includes
                    restaurant data with the following columns: rank of restaurant, name of restaurant, content (which
                    has many null values), sales, YOY_Sales (year-over-year sales), units, YOY_Units (year-over-year
                    units), headquarters, and segment category.</p>
                <ul>
                    <li><a class="ba"
                            href="https://github.com/Pravin-hub-rgb/BCA/tree/master/resources/sem4/python_tbc401/unit5/program"
                            target="_blank">Access the Restaurant.csv file from here &neArr;</a></li>
                    <li>Now we will convert this file to a DataFrame and start working with it.</li>
                </ul>
                <pre>
                    <code class="language-py">
import pandas as pd

# Load the CSV file into a DataFrame
df = pd.read_csv("Restaurant.csv")

# Display the first few rows of the DataFrame
print(df.head())
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
   Rank   Restaurant  ... Headquarters             Segment_Category
0     1   McDonald's  ...          NaN       Quick Service & Burger
1     2    Starbucks  ...          NaN  Quick Service & Coffee Cafe
2     3  Chick-fil-A  ...          NaN      Quick Service & Chicken
3     4    Taco Bell  ...          NaN      Quick Service & Mexican
4     5  Burger King  ...          NaN       Quick Service & Burger

[5 rows x 9 columns]
                    </code>
                </pre>
                <ul>
                    <li>
                        <strong>df.info()</strong> provides detailed information about the DataFrame, including the
                        number of non-null values in each column and the data types of the columns.
                        <pre>
                            <code class="language-py">
df.info()
                            </code>
                        </pre>
                        <p>Output:</p>
                        <pre>
                            <code>
&lt;class 'pandas.core.frame.DataFrame'>
RangeIndex: 250 entries, 0 to 249
Data columns (total 9 columns):
    #   Column            Non-Null Count  Dtype 
---  ------            --------------  ----- 
    0   Rank              250 non-null    int64 
    1   Restaurant        250 non-null    object
    2   Content           33 non-null     object
    3   Sales             250 non-null    int64 
    4   YOY_Sales         250 non-null    object
    5   Units             250 non-null    int64 
    6   YOY_Units         250 non-null    object
    7   Headquarters      52 non-null     object
    8   Segment_Category  250 non-null    object
dtypes: int64(3), object(6)
memory usage: 17.7+ KB
                            </code>
                        </pre>
                    </li>
                    <li>
                        <strong>df.describe()</strong> gives summary statistics of the DataFrame, which includes count,
                        mean, standard deviation, min, max, and quartiles for numerical columns.
                        <pre>
                            <code class="language-py">
print(df.describe())
                            </code>
                        </pre>
                        <p>Output:</p>
                        <pre>
                            <code>
            Rank        Sales         Units
count  250.000000    250.00000    250.000000
mean   125.500000   1242.74000    850.076000
std     72.312977   3365.22882   2296.151659
min      1.000000    126.00000     13.000000
25%     63.250000    181.00000     85.000000
50%    125.500000    330.00000    207.000000
75%    187.750000    724.75000    555.250000
max    250.000000  40412.00000  23801.000000
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Handling Missing or Null Values</h3>
                <ul>
                    <li>We are going to work with a <strong>sample.csv</strong> file that contains a dataset of roll
                        numbers, physics marks, chemistry marks, maths marks, and computer marks. Some values in this
                        dataset are missing.</li>
                    <li>Handling null values is crucial because when training a machine learning model, we can't have
                        null values. The compiler will give an error as the dataset is incomplete. We either have to
                        remove these rows with null values or fill them.</li>
                    <li><a class="ba"
                            href="https://github.com/Pravin-hub-rgb/BCA/tree/master/resources/sem4/python_tbc401/unit5/program"
                            target="_blank">Access the sample.csv file from here &neArr;</a></li>
                </ul>
                <pre>
                    <code class="language-py">
import pandas as pd 
df = pd.read_csv('sample.csv')
print(df.head())
                    </code>
                </pre>
                <ul>
                    <li>To check if the dataset contains null values, use the <strong>df.isnull()</strong> method, which
                        shows a DataFrame of boolean values indicating where null values are present.</li>
                </ul>
                <pre>
                    <code class="language-py">
                print(df.isnull())
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
    Roll No.  Physics  Chemistry  Maths  Computer
0      False    False      False  False     False
1      False    False      False  False     False
2      False    False      False  False     False
3      False    False      False  False     False
4      False    False      False  False     False
5      False    False       True  False     False
6      False    False      False  False     False
7      False    False      False  False     False
8      False     True      False  False     False
9      False    False      False  False     False
10     False     True      False  False     False
11     False    False       True  False     False
12     False    False      False  False     False
13     False    False       True   True     False
14     False     True      False  False     False
15     False    False      False  False     False
16     False    False      False  False     False
17     False    False      False  False     False
18     False    False      False  False     False
19     False    False      False  False     False
20     False    False      False  False     False
21     False    False      False  False     False
22     False    False      False  False     False
23     False    False      False  False     False
24     False    False       True   True     False
25     False    False      False  False     False
26     False    False      False  False     False
27     False    False      False  False      True
28     False    False      False  False     False
29     False    False      False  False     False
                    </code>
                </pre>
                <ul>
                    <li>Using <strong>df.isnull()</strong> makes it difficult to calculate the number of null values.
                        For better results, use <strong>df.isnull().sum()</strong>, which provides the count of null
                        values in each column.</li>
                </ul>
                <pre>
                    <code class="language-py">
print(df.isnull().sum())
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
Roll No.     0
Physics      3
Chemistry    4
Maths        2
Computer     1
dtype: int64
                    </code>
                </pre>
                <ul>
                    <li>From this, we understand that the Physics column contains 3 null values, Chemistry has 4, Maths
                        has 2, and Computer has 1.</li>
                    <li>If we want the total number of null values in the entire DataFrame, use
                        <strong>df.isnull().sum().sum()</strong>, which will give the total count of null values.
                    </li>
                </ul>
                <pre>
                    <code class="language-py">
print(df.isnull().sum().sum())
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
10
                    </code>
                </pre>
                <ul>
                    <li>So, 10 is the total number of null values in our dataset.</li>
                    <li>The first thing we can do for the null values is to drop those rows.</li>
                    <li>First, we will check the shape of the dataset before dropping the null values.</li>
                </ul>
                <pre>
                    <code class="language-py">
print(df.shape)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
(30, 5)
                    </code>
                </pre>
                <ul>
                    <li>If a row consists of any null value, it will be removed using <strong>df.dropna()</strong>.</li>
                    <li>We will create a new DataFrame variable <strong>df2</strong> and store all the non-null values
                        in it.</li>
                </ul>
                <pre>
                    <code class="language-py">
df2 = df.dropna()
print(df2)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
    Roll No.  Physics  Chemistry  Maths  Computer
0          1     56.0       57.0   58.0      59.0
1          2     23.0       24.0   25.0      26.0
2          3     89.0       25.0   26.0      27.0
3          4     45.0       26.0   27.0      28.0
4          5     23.0       27.0   28.0      29.0
6          7     12.0       13.0   14.0      15.0
7          8     78.0       14.0   15.0      16.0
9         10     45.0       16.0   17.0      18.0
12        13     22.0       23.0   24.0      25.0
15        16     44.0       44.0   44.0      44.0
16        17     45.0       45.0   45.0      45.0
17        18     46.0       46.0   46.0      46.0
18        19     47.0       47.0   47.0      47.0
19        20     48.0       48.0   48.0      48.0
20        21     49.0       49.0   49.0      49.0
21        22     50.0       50.0   50.0      50.0
22        23     51.0       51.0   51.0      51.0
23        24     52.0       52.0   52.0      52.0
25        26     54.0       33.0   33.0      54.0
26        27     55.0       34.0   34.0      55.0
28        29     57.0       36.0   36.0      66.0
29        30     58.0       37.0   37.0      43.0
                    </code>
                </pre>
                <ul>
                    <li>Now, <strong>df2</strong> contains all the data that is not null.</li>
                    <li>Next, check the shape of the non-null data stored in <strong>df2</strong>.</li>
                </ul>
                <pre>
                    <code class="language-py">
print(df2.shape)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
(22, 5)
                    </code>
                </pre>
                <ul>
                    <li>This means that 8 rows were having null values.</li>
                    <li>The <strong>dropna()</strong> function takes an <strong>axis</strong> parameter. The default
                        axis is 0 (for rows), and for columns, the number is 1. When <strong>dropna(axis=1)</strong> is
                        used, it will drop all columns that contain null values. For example:</li>
                </ul>
                <pre>
                    <code class="language-py">
df3 = df.dropna(axis=1)
print(df3.shape)
                    </code>
                </pre>
                <p>Output:</p>
                <pre>
                    <code>
(30, 1)
                    </code>
                </pre>
                <ul>
                    <li>This means there are 30 rows and only 1 column remaining (RollNo column). This indicates that 4
                        columns were
                        removed because they contain null values somewhere.</li>
                    <li>Two more parameters we are going to discuss with <strong>dropna</strong> are
                        <strong>how='any'</strong> and <strong>how='all'</strong>. The row will be dropped if any column
                        value is null in the case of <strong>how='any'</strong>, and in the case of
                        <strong>how='all'</strong>, the row will only be dropped if all the row values are null. For
                        example:
                    </li>
                </ul>
                <pre>
                            <code class="language-py">
df2 = df.dropna(how='any')
print("Shape = ", df2.shape)
                            </code>
                        </pre>
                <p>Output:</p>
                <pre>
                            <code>
Shape =  (22, 5)
                            </code>
                        </pre>
                <ul>
                    <li>This means there were 8 rows in which at least one column value was null, so those rows were
                        removed.</li>
                </ul>
                <pre>
                            <code class="language-py">
df2 = df.dropna(how='all')
print("Shape = ", df2.shape)
                            </code>
                        </pre>
                <p>Output:</p>
                <pre>
                            <code>
Shape = (30, 5)
                            </code>
                        </pre>
                <ul>
                    <li>This means there were no rows in which all values were null, so no rows were removed.</li>
                    <li><strong>df.dropna(inplace=True)</strong> using the <strong>inplace=True</strong> parameter will
                        replace our original DataFrame. The original DataFrame will be lost, and a new DataFrame will be
                        created without any null values.</li>
                </ul>
                <pre>
                        <code class="language-py">
df.dropna(inplace=True)
print("Shape = ", df.shape)
                        </code>
                    </pre>
                <p>Output:</p>
                <pre>
                        <code>
(22, 5)
                        </code>
                    </pre>
                <ul>
                    <li>The original DataFrame had 30 rows and 5 columns, but now it has 22 rows and 5 columns. This
                        means that rows containing null values were removed, and the original DataFrame was modified in
                        place.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Filling the null values in dataframe</h3>
                <pre>
                    <code>
import pandas as pd
df = pd.read_csv('sample.csv')
print(df.head())
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
   Roll No.  Physics  Chemistry  Maths  Computer
0         1     56.0       57.0   58.0      59.0
1         2     23.0       24.0   25.0      26.0
2         3     89.0       25.0   26.0      27.0
3         4     45.0       26.0   27.0      28.0
4         5     23.0       27.0   28.0      29.0
                    </code>
                </pre>
                <ul>
                    <li>Let's check the null values in our dataframe again:</li>
                </ul>
                <pre>
                    <code>
print(df.isnull().sum())
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
Roll No.     0
Physics      3
Chemistry    4
Maths        2
Computer     1
dtype: int64
                    </code>
                </pre>
                <ul>
                    <li>From the output above, we can see that our data has some null values.</li>
                    <li>Now, we need to handle these null values. Removing entire rows is not ideal because we would
                        lose data, so we'll fill the null values.</li>
                    <li><code>df.fillna(0)</code> will fill all the null values with zero:</li>
                </ul>
                <pre>
                    <code>
df2 = df.fillna(0)
print(df2)
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
    Roll No.  Physics  Chemistry  Maths  Computer
0          1     56.0       57.0   58.0      59.0
1          2     23.0       24.0   25.0      26.0
2          3     89.0       25.0   26.0      27.0
3          4     45.0       26.0   27.0      28.0
4          5     23.0       27.0   28.0      29.0
5          6     90.0        0.0   29.0      30.0
6          7     12.0       13.0   14.0      15.0
7          8     78.0       14.0   15.0      16.0
8          9      0.0       15.0   16.0      17.0
9         10     45.0       16.0   17.0      18.0
10        11      0.0       17.0   18.0      19.0
11        12     88.0        0.0   19.0      20.0
12        13     22.0       23.0   24.0      25.0
13        14     90.0        0.0    0.0      42.0
14        15      0.0       43.0   43.0      43.0
15        16     44.0       44.0   44.0      44.0
16        17     45.0       45.0   45.0      45.0
17        18     46.0       46.0   46.0      46.0
18        19     47.0       47.0   47.0      47.0
19        20     48.0       48.0   48.0      48.0
20        21     49.0       49.0   49.0      49.0
21        22     50.0       50.0   50.0      50.0
22        23     51.0       51.0   51.0      51.0
23        24     52.0       52.0   52.0      52.0
24        25     53.0        0.0    0.0      53.0
25        26     54.0       33.0   33.0      54.0
26        27     55.0       34.0   34.0      55.0
27        28     56.0       35.0   35.0       0.0
28        29     57.0       36.0   36.0      66.0
29        30     58.0       37.0   37.0      43.0
                    </code>
                </pre>
                <ul>
                    <li>As seen in the output, the null values are now filled with 0.0.</li>
                    <li>We can also fill null values with other numbers, for example, filling with 2:</li>
                </ul>
                <pre>
                    <code>
df2 = df.fillna(2)
print(df2)
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
    Roll No.  Physics  Chemistry  Maths  Computer
0          1     56.0       57.0   58.0      59.0
1          2     23.0       24.0   25.0      26.0
2          3     89.0       25.0   26.0      27.0
3          4     45.0       26.0   27.0      28.0
4          5     23.0       27.0   28.0      29.0
5          6     90.0       12.0   29.0      30.0
6          7     12.0       13.0   14.0      15.0
7          8     78.0       14.0   15.0      16.0
8          9     12.0       15.0   16.0      17.0
9         10     45.0       16.0   17.0      18.0
10        11     12.0       17.0   18.0      19.0
11        12     88.0       12.0   19.0      20.0
12        13     22.0       23.0   24.0      25.0
13        14     90.0       12.0   12.0      42.0
14        15     12.0       43.0   43.0      43.0
15        16     44.0       44.0   44.0      44.0
16        17     45.0       45.0   45.0      45.0
17        18     46.0       46.0   46.0      46.0
18        19     47.0       47.0   47.0      47.0
19        20     48.0       48.0   48.0      48.0
20        21     49.0       49.0   49.0      49.0
21        22     50.0       50.0   50.0      50.0
22        23     51.0       51.0   51.0      51.0
23        24     52.0       52.0   52.0      52.0
24        25     53.0       12.0   12.0      53.0
25        26     54.0       33.0   33.0      54.0
26        27     55.0       34.0   34.0      55.0
27        28     56.0       35.0   35.0      12.0
28        29     57.0       36.0   36.0      66.0
29        30     58.0       37.0   37.0      43.0
                    </code>
                </pre>
                <ul>
                    <li>If we want to be more specific, we can fill null values in specific columns with specific
                        values:</li>
                </ul>
                <pre>
                    <code>
df2 = df.fillna({'Physics': 'none', 'Chemistry': 0, 'Maths': 30})
print(df2)
                    </code>
                </pre>
                <p>output:</p>
                <pre>
                    <code>
    Roll No. Physics  Chemistry  Maths  Computer
0          1    56.0       57.0   58.0      59.0
1          2    23.0       24.0   25.0      26.0
2          3    89.0       25.0   26.0      27.0
3          4    45.0       26.0   27.0      28.0
4          5    23.0       27.0   28.0      29.0
5          6    90.0        0.0   29.0      30.0
6          7    12.0       13.0   14.0      15.0
7          8    78.0       14.0   15.0      16.0
8          9    none       15.0   16.0      17.0
9         10    45.0       16.0   17.0      18.0
10        11    none       17.0   18.0      19.0
11        12    88.0        0.0   19.0      20.0
12        13    22.0       23.0   24.0      25.0
13        14    90.0        0.0   30.0      42.0
14        15    none       43.0   43.0      43.0
15        16    44.0       44.0   44.0      44.0
16        17    45.0       45.0   45.0      45.0
17        18    46.0       46.0   46.0      46.0
18        19    47.0       47.0   47.0      47.0
19        20    48.0       48.0   48.0      48.0
20        21    49.0       49.0   49.0      49.0
21        22    50.0       50.0   50.0      50.0
22        23    51.0       51.0   51.0      51.0
23        24    52.0       52.0   52.0      52.0
24        25    53.0        0.0   30.0      53.0
25        26    54.0       33.0   33.0      54.0
26        27    55.0       34.0   34.0      55.0
27        28    56.0       35.0   35.0       NaN
28        29    57.0       36.0   36.0      66.0
29        30    58.0       37.0   37.0      43.0
                    </code>
                </pre>
                <ul>
                    <li>Now only the Physics, Chemistry, and Maths columns are affected by filling specific values.</li>
                    <li>Let's now discuss the 'method' parameter in the fillna function. It can have 'ffill' (forward
                        fill) and 'bfill' (backward fill) values.</li>
                    <li>The 'ffill' method fills the null values with the previous row's values in the same column. For
                        example, if a null value appears in the Physics column of row 3, it will be replaced by the
                        value from the Physics column of row 2.</li>
                </ul>
                <pre>
    <code>
df2 = df.fillna(method='ffill')
    </code>
</pre>
                <ul>
                    <li>When we also provide another parameter, axis=1, the fillna method fills the null values with the
                        previous column's values in the same row. For example, if a null value appears in the Chemistry
                        column of row 3, it will be replaced by the value from the Physics column of row 3.</li>
                </ul>
                <pre>
    <code>
df2 = df.fillna(method='ffill', axis=1)
    </code>
</pre>
                <ul>
                    <li>We can be more precise by filling the null values with the mean value of a specific column. For
                        example, using the mean value of the Physics column to fill its null values ensures that the
                        replacement is more representative of the data.</li>
                </ul>
                <pre>
    <code>
df2 = df.fillna(value=df['Physics'].mean())
    </code>
</pre>
                <ul>
                    <li>Using the above code, all null values in the Physics column will be replaced with the mean of
                        the non-null values in the Physics column.</li>
                    <li>The 'bfill' method fills the null values with the next row's values in the same column. For
                        example, if a null value appears in the Physics column of row 2, it will be replaced by the
                        value from the Physics column of row 3.</li>
                </ul>
                <pre>
    <code>
df2 = df.fillna(method='bfill')
    </code>
</pre>
                <ul>
                    <li>Using this method, all null values in the dataframe will be filled with the next row's values in
                        their respective columns, effectively propagating values backward to fill gaps.</li>
                </ul>
            </div>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
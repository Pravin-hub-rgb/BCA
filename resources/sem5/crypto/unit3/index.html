<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Encrption Algorithm</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="" class="link">Next Topic &rarr;</a>
                <a href="" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Advanced Encrption Algorithm</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Advanced Encrption Algorithm</h1>
        <p>Advanced Encryption Algorithms (AEA) are sophisticated techniques used to secure data and ensure
            confidentiality in modern cryptographic systems. These algorithms are designed to provide robust protection
            against unauthorized access by leveraging complex mathematical operations. This unit explores some of the
            widely used encryption algorithms, such as Blowfish, International Data Encryption Algorithm (IDEA), and
            RC-5, along with their unique features and applications. Additionally, it delves into key concepts like
            Symmetric Key Distribution, which facilitates secure key sharing, and Random Number Generators, critical for
            generating unpredictable keys. Lastly, the Placement of the Encryption Function is examined, highlighting
            its significance in optimizing security and system performance.</p>
        <div class="wh">
            <h2>Blowfish Algorithm</h2>
            <ul>
                <li>Blowfish is a block cipher encryption algorithm.</li>
                <li>It follows symmetric key cryptography, where the same key is used for both encryption and
                    decryption.</li>
                <li>Input size (block size) is fixed at 64 bits.</li>
                <li>The key size is variable, ranging from 32 to 448 bits.</li>
            </ul>

            <div class="in">
                <h3>Properties</h3>
                <ul>
                    <li>Fast encryption and decryption process, making it suitable for real-time applications.</li>
                    <li>Requires less memory, making it efficient for resource-constrained environments.</li>
                    <li>Simple to understand and implement compared to other complex encryption algorithms.</li>
                    <li>Highly secure due to the use of a variable-length key, allowing for flexibility in security
                        strength.</li>
                    <li>Resistant to known cryptographic attacks like brute force due to its key size flexibility.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Blowfish Algorithm Steps</h3>
                <p>The Blowfish algorithm consists of two main steps:</p>
                <ol>
                    <li><strong>Key Generation</strong>: Generates subkeys and initializes the algorithm components.
                    </li>
                    <li><strong>Data Encryption</strong>: Encrypts plaintext using the generated keys and the block
                        cipher process.</li>
                </ol>
            </div>

            <div class="in">
                <h3>Key Generation</h3>
                <ol>
                    <li>
                        Keys are stored in an array:
                        <ul>
                            <li>Array elements: k1, k2, k3, ..., kn where 1 ≤ n ≤ 14.</li>
                            <li>Each key block has a length of 32 bits.</li>
                            <li>The total key length can be up to 448 bits (32 × 14), which is a multiple of 32.</li>
                        </ul>
                    </li>
                    <li>
                        Initialize the P-array:
                        <ul>
                            <li>The P-array consists of 18 subkeys: P1, P2, P3, ..., P18.</li>
                            <li>Each element in the P-array is 32 bits long.</li>
                        </ul>
                    </li>
                    <li>
                        Initialize the S-boxes:
                        <ul>
                            <li>There are 4 S-boxes, each containing 256 entries.</li>
                            <li>
                                Example for S-box initialization:
                                <ul>
                                    <li>S1: s0, s1, ..., s255</li>
                                    <li>S2: s0, s1, ..., s255</li>
                                    <li>The same pattern applies for S3 and S4.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Initialize each element of the P-array and S-boxes with predefined hexadecimal values.</li>
                    <li>
                        Perform XOR operations to further initialize the P-array:
                        <ul>
                            <li>P1 = P1 XOR K1</li>
                            <li>P2 = P2 XOR K2</li>
                            <li>... (continue for all key values)</li>
                            <li>When all 14 keys are used, restart from K1 for the remaining P-array elements.</li>
                            <li>
                                Example:
                                <ul>
                                    <li>P15 = P15 XOR K1</li>
                                    <li>P18 = P18 XOR K4</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        Process a 64-bit block of plaintext (initially all bits are 0) to generate subkeys:
                        <ul>
                            <li>Initial plaintext: (0, 0, 0, ..., 0)</li>
                            <li>Subkeys are generated and used in the encryption process.</li>
                        </ul>
                    </li>
                </ol>
            </div>
            <div class="in">
                <h3>Data Encryption</h3>
                <ul>
                    <li>
                        The plaintext size is 64 bits, which is divided into two halves:
                        <ul>
                            <li>The left half (L) consists of the first 32 bits.</li>
                            <li>The right half (R) consists of the remaining 32 bits.</li>
                        </ul>
                    </li>
                    <li>
                        The encryption process involves the following steps:
                        <ul>
                            <li>The left half (L) is XORed with the first subkey (P1).</li>
                            <li>The result of this XOR operation (denoted as `x`) is input to the function `F` to
                                produce an output (denoted as `y`).</li>
                            <li>The output `y` is XORed with the right half (R).</li>
                            <li>After XORing, the left and right halves are swapped.</li>
                            <li>This process is repeated for all 18 subkeys in the P-array (P1 to P18).</li>
                        </ul>
                    </li>
                    <li>
                        After processing through all 18 rounds:
                        <ul>
                            <li>The final left (L) and right (R) halves are combined to form a 64-bit block of
                                ciphertext.</li>
                            <li>The swapping step ensures the encryption provides strong diffusion and security.</li>
                        </ul>
                    </li>
                </ul>
                <img src="../../images/cry23.jpeg" alt="">

                <h3>Understanding the Function (F)</h3>
                <ul>
                    <li>
                        The input to the function `F` is 32 bits, which is divided into four 8-bit segments:
                        <ul>
                            <li>Each 8-bit segment is independently processed by one of the four S-boxes (S1, S2, S3,
                                S4).</li>
                        </ul>
                    </li>
                    <li>
                        The output of the S-boxes undergoes the following operations:
                        <ul>
                            <li>The output of S-box 1 is XORed with the output of S-box 2.</li>
                            <li>The result of this XOR operation is then XORed with the output of S-box 3.</li>
                            <li>Finally, the result is XORed with the output of S-box 4.</li>
                        </ul>
                    </li>
                    <li>
                        The final output of the function `F` is a 32-bit value (denoted as `y`), which is used in the
                        encryption process.
                    </li>
                    <li>
                        The purpose of the function `F` is to provide a non-linear transformation of the input,
                        contributing to the algorithm's security by introducing confusion and diffusion.
                    </li>
                </ul>

            </div>
        </div>
        <div class="wh">
            <h2>IDEA Algorithm (International Data Encryption Algorithm)</h2>
            <ul>
                <li>It is a block cipher algorithm.</li>
                <li>It follows symmetric key cryptography.</li>
                <li>Uses a Feistel structure for its operations.</li>
                <li>The input plaintext size is 64 bits, divided into four 16-bit blocks.</li>
                <li>The key size is 128 bits, which is expanded into 52 subkeys.</li>
                <li>Number of rounds = 17 (16 primary rounds + 1 final transformation round).</li>
                <li>Odd-numbered rounds use <strong>4 keys</strong>, while even-numbered rounds use only <strong>2
                        keys</strong>.</li>
                <li>The goal of each round is to scramble and mix the data so much that it becomes completely
                    unrecognizable by the end.</li>
            </ul>
            <div class="in">
                <h3>Working</h3>
                <ul>
                    <li>The plaintext of 64 bits is divided into 4 equal parts, each of size 16 bits.</li>
                    <li>These 4 parts are denoted as X1, X2, X3, and X4.</li>
                    <li>The algorithm involves 17 rounds, out of which 16 are primary rounds and the 17th is a final
                        transformation round.</li>
                    <li>Each round processes the input blocks using specific subkeys from the 52 subkeys generated
                        during the key expansion phase.</li>
                    <li><strong>For each round:</strong>
                        <ul>
                            <li>Subkeys are applied to the blocks using modular addition, modular multiplication, and
                                XOR operations.</li>
                            <li>Data blocks are mixed to ensure confusion and diffusion.</li>
                            <li>Odd and even rounds have distinct operations, explained further below.</li>
                        </ul>
                    </li>
                    <li>The final transformation round applies the last 4 subkeys (K49, K50, K51, K52) to the blocks.
                    </li>
                    <li>After all rounds, the 4 resulting 16-bit blocks are concatenated to form the 64-bit ciphertext.
                    </li>
                </ul>
                <img src="../../images/cry24.jpeg" alt="">
            </div>
            <div class="in">
                <h3>What Happens in Each Round?</h3>
                <p>Each round involves processing the 4 parts (X1, X2, X3, X4) using subkeys and simple operations to
                    create layers of scrambling. Here's how it works:</p>

                <p><strong>Odd Rounds (e.g., Round 1, 3, 5...):</strong></p>
                <ul>
                    <li><strong>4 subkeys</strong> are used, one for each part: X1, X2, X3, and X4.</li>
                    <li>The keys are applied directly to the parts, followed by rearrangements and combinations to mix
                        the data.</li>
                    <li>The result is passed to the next round.</li>
                </ul>

                <p><strong>Even Rounds (e.g., Round 2, 4, 6...):</strong></p>
                <ul>
                    <li><strong>2 subkeys</strong> are used instead of 4, making these rounds slightly different from
                        the odd rounds.</li>
                    <li>The keys are applied to specific parts of the data, followed by scrambling and rearrangements.
                    </li>
                    <li>This adds another layer of complexity to the scrambled data.</li>
                </ul>

                <p><strong>Final Round (Round 17):</strong></p>
                <ul>
                    <li>The 4 parts (X1, X2, X3, X4) are processed with the last set of subkeys.</li>
                    <li>This step finalizes the ciphertext.</li>
                    <li>The scrambled 4 parts are combined into the final 64-bit ciphertext.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>RC5 Algorithm (Rivest Cipher)</h2>
            <ul>
                <li>A symmetric key block cipher encryption algorithm.</li>
                <li>Processes two-word blocks at a time; the plaintext is divided into two equal-sized blocks.</li>
                <li>It has three main parameters:
                    <ol>
                        <li><strong>w</strong>: Word size (16, 32, or 64 bits).</li>
                        <li><strong>r</strong>: Number of rounds (can range from 0 to 255).</li>
                        <li><strong>b</strong>: Key size in bits (ranges from 0 to 255).</li>
                    </ol>
                    <p>These parameters are chosen based on the requirements of the input plaintext.</p>
                </li>
                <li>The algorithm consists of three main components:
                    <ol>
                        <li><strong>Key Expansion</strong>: Expands the secret key into a series of subkeys.</li>
                        <li><strong>Encryption</strong>: Transforms plaintext into ciphertext using subkeys.</li>
                        <li><strong>Decryption</strong>: Reverses the encryption process to retrieve the original
                            plaintext.</li>
                    </ol>
                </li>
            </ul>

            <div class="in">
                <h3>Block Diagram</h3>
                <ul>
                    <li>The secret key is first processed through the <strong>Key Expansion Algorithm</strong> to
                        generate multiple subkeys. For example, a 128-bit secret key can be expanded into a sequence of
                        subkeys depending on the block size.</li>
                    <li>These subkeys are then used during the encryption rounds to transform the plaintext into
                        ciphertext.</li>
                    <li>During decryption, the same subkeys are used in reverse order to retrieve the original
                        plaintext.</li>
                </ul>
                <img src="../../images/cry25.jpeg" alt="">
            </div>

            <div class="in">
                <h3>What Happens in Each Stage?</h3>
                <h4>1. Key Expansion</h4>
                <ul>
                    <li>Key expansion is a preprocessing step that generates a large number of subkeys from the original
                        secret key.</li>
                </ul>
                <p><strong>Steps:</strong></p>
                <ol>
                    <li>The plaintext of 64 bits is divided into two equal blocks: A (32 bits) and B (32 bits).</li>
                    <li>The secret key is expanded into a subkey array <strong>S</strong>, containing 2(r+1) subkeys
                        (e.g., S[0], S[1], ..., S[2r+1]).</li>
                    <li>Initial values for A and B are created by adding the first two subkeys:
                        <ul>
                            <li><strong>A = A + S[0]</strong></li>
                            <li><strong>B = B + S[1]</strong></li>
                        </ul>
                    </li>
                </ol>

                <h4>2. Encryption</h4>
                <ul>
                    <li>Encryption involves multiple rounds of transformations using subkeys.</li>
                    <li>Each round performs the following steps:
                        <ol>
                            <li>A is updated using a combination of bitwise operations (XOR, left rotation) and addition
                                with a subkey.</li>
                            <li>B is updated in a similar manner using the next subkey.</li>
                        </ol>
                    </li>
                    <li>After completing all rounds, the output is combined to form the final ciphertext.</li>
                </ul>

                <h4>3. Decryption</h4>
                <ul>
                    <li>The decryption process reverses the encryption steps.</li>
                    <li>It uses the same subkeys, but applies them in reverse order.</li>
                    <li>By undoing the operations (e.g., subtracting instead of adding, reversing rotations), the
                        ciphertext is converted back into the original plaintext.</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/watch?v=ngqtEbxQLBE" target="_blank">Blowfish Algorithm Video lecture
                    &neArr;</a>
            </li>
            <li><a href="https://www.youtube.com/watch?v=909pwcyqVFQ" target="_blank">IDEA Algorithm Video lecture
                    &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=4Z0xa13oov4" target="_blank">RC-5 Algorithm Video lecture
                    &neArr;</a></li>
                    <li><a href="https://www.youtube.com/watch?v=4Z0xa13oov4" target="_blank">RC-5 Algorithm video lecture &neArr;</a></li>
        </ul>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>
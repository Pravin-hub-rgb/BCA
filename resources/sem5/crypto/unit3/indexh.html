<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Encrption Algorithm</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit4/indexh.html" class="link">Next Topic &rarr;</a>
                <a href="../unit2/indexh.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Advanced Encrption Algorithm</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Advanced Encryption Algorithm</h1>
        <p>
            <strong>Advanced Encryption Algorithms (AEA)</strong> wo advanced techniques hain jo data ko secure karne
            aur confidentiality ensure karne ke liye use hoti hain, especially modern cryptographic systems mein. Yeh
            algorithms complex mathematical operations ka use karte hain taaki unauthorized access se bach sake. Is unit
            mein, hum kuch widely used encryption algorithms explore karenge, jaise Blowfish, International Data
            Encryption Algorithm (IDEA), aur RC-5. Hum inke unique features aur applications ko samjhenge. Iske alawa,
            hum kuch important concepts bhi samjhenge, jaise <strong>Symmetric Key Distribution</strong>, jo secure key
            sharing ko facilitate karta hai, aur <strong>Random Number Generators</strong>, jo unpredictable keys
            generate karte hain. Aur last mein, hum <strong>Placement of the Encryption Function</strong> bhi discuss
            karenge, jo security aur system performance ko optimize karne mein madad karta hai.
        </p>

        <div class="wh">
            <h2>Blowfish Algorithm</h2>
            <ul>
                <li><strong>Blowfish</strong> ek block cipher encryption algorithm hai, jo data ko fixed-size blocks
                    mein encrypt karta hai.</li>
                <li>Yeh symmetric key cryptography follow karta hai, matlab same key encryption aur decryption dono ke
                    liye use hoti hai.</li>
                <li>Iska input size (block size) fixed hota hai, jo 64 bits hota hai.</li>
                <li>Key size variable hota hai, matlab aap key ko 32 bits se lekar 448 bits tak set kar sakte hain.</li>
            </ul>

            <div class="in">
                <h3>Properties</h3>
                <ul>
                    <li>Yeh fast encryption aur decryption process offer karta hai, isliye real-time applications ke
                        liye perfect hai.</li>
                    <li>Kam memory ki zaroorat hoti hai, jo resource-constrained environments mein kaafi efficient
                        banata hai.</li>
                    <li>Dusre complex encryption algorithms ke comparison mein, yeh simple samajhne aur implement karne
                        mein aata hai.</li>
                    <li>Highly secure hai kyunki yeh variable-length key use karta hai, jo security ki flexibility deta
                        hai.</li>
                    <li>Yeh brute force jaise known cryptographic attacks ke against resistant hai, kyunki key size
                        flexible hai aur zyada strong ho sakta hai.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Blowfish Algorithm Steps</h3>
                <p>Blowfish algorithm do main steps mein divide hota hai:</p>
                <ol>
                    <li><strong>Key Generation</strong>: Yeh step subkeys generate karta hai aur algorithm ke components
                        ko initialize karta hai.</li>
                    <li><strong>Data Encryption</strong>: Is step mein plaintext ko generate kiye gaye keys aur block
                        cipher process ka use karke encrypt kiya jata hai.</li>
                </ol>
            </div>

            <div class="in">
                <h3>Key Generation</h3>
                <ol>
                    <li>
                        Keys are stored in an array:
                        <ul>
                            <li>Array elements: k1, k2, k3, ..., kn where 1 ≤ n ≤ 14.</li>
                            <li>Each key block has a length of 32 bits.</li>
                            <li>The total key length can be up to 448 bits (32 × 14), which is a multiple of 32.</li>
                        </ul>
                    </li>
                    <li>
                        Initialize the P-array:
                        <ul>
                            <li>The P-array consists of 18 subkeys: P1, P2, P3, ..., P18.</li>
                            <li>Each element in the P-array is 32 bits long.</li>
                        </ul>
                    </li>
                    <li>
                        Initialize the S-boxes:
                        <ul>
                            <li>There are 4 S-boxes, each containing 256 entries.</li>
                            <li>
                                Example for S-box initialization:
                                <ul>
                                    <li>S1: s0, s1, ..., s255</li>
                                    <li>S2: s0, s1, ..., s255</li>
                                    <li>The same pattern applies for S3 and S4.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Initialize each element of the P-array and S-boxes with predefined hexadecimal values.</li>
                    <li>
                        Perform XOR operations to further initialize the P-array:
                        <ul>
                            <li>P1 = P1 XOR K1</li>
                            <li>P2 = P2 XOR K2</li>
                            <li>... (continue for all key values)</li>
                            <li>When all 14 keys are used, restart from K1 for the remaining P-array elements.</li>
                            <li>
                                Example:
                                <ul>
                                    <li>P15 = P15 XOR K1</li>
                                    <li>P18 = P18 XOR K4</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        Process a 64-bit block of plaintext (initially all bits are 0) to generate subkeys:
                        <ul>
                            <li>Initial plaintext: (0, 0, 0, ..., 0)</li>
                            <li>Subkeys are generated and used in the encryption process.</li>
                        </ul>
                    </li>
                </ol>
            </div>
            <div class="in">
                <h3>Data Encryption</h3>
                <ul>
                    <li>
                        The plaintext size is 64 bits, which is divided into two halves:
                        <ul>
                            <li>The left half (L) consists of the first 32 bits.</li>
                            <li>The right half (R) consists of the remaining 32 bits.</li>
                        </ul>
                    </li>
                    <li>
                        The encryption process involves the following steps:
                        <ul>
                            <li>The left half (L) is XORed with the first subkey (P1).</li>
                            <li>The result of this XOR operation (denoted as `x`) is input to the function `F` to
                                produce an output (denoted as `y`).</li>
                            <li>The output `y` is XORed with the right half (R).</li>
                            <li>After XORing, the left and right halves are swapped.</li>
                            <li>This process is repeated for all 18 subkeys in the P-array (P1 to P18).</li>
                        </ul>
                    </li>
                    <li>
                        After processing through all 18 rounds:
                        <ul>
                            <li>The final left (L) and right (R) halves are combined to form a 64-bit block of
                                ciphertext.</li>
                            <li>The swapping step ensures the encryption provides strong diffusion and security.</li>
                        </ul>
                    </li>
                </ul>
                <img src="../../images/cry23.jpeg" alt="">

                <h3>Understanding the Function (F)</h3>
                <ul>
                    <li>
                        The input to the function `F` is 32 bits, which is divided into four 8-bit segments:
                        <ul>
                            <li>Each 8-bit segment is independently processed by one of the four S-boxes (S1, S2, S3,
                                S4).</li>
                        </ul>
                    </li>
                    <li>
                        The output of the S-boxes undergoes the following operations:
                        <ul>
                            <li>The output of S-box 1 is XORed with the output of S-box 2.</li>
                            <li>The result of this XOR operation is then XORed with the output of S-box 3.</li>
                            <li>Finally, the result is XORed with the output of S-box 4.</li>
                        </ul>
                    </li>
                    <li>
                        The final output of the function `F` is a 32-bit value (denoted as `y`), which is used in the
                        encryption process.
                    </li>
                    <li>
                        The purpose of the function `F` is to provide a non-linear transformation of the input,
                        contributing to the algorithm's security by introducing confusion and diffusion.
                    </li>
                </ul>

            </div>
        </div>

        <div class="wh">
            <h2>IDEA Algorithm (International Data Encryption Algorithm)</h2>
            <ul>
                <li><strong>IDEA</strong> ek block cipher algorithm hai, jo data ko fixed-size blocks mein encrypt karta
                    hai.</li>
                <li>Yeh <strong>symmetric key cryptography</strong> follow karta hai, matlab encryption aur decryption
                    ke
                    liye same key use hoti hai.</li>
                <li>IDEA apne operations ke liye <strong>Feistel structure</strong> ka use karta hai, jo ek popular
                    method
                    hai block ciphers mein.</li>
                <li>Input plaintext ka size 64 bits hota hai, jise 4 equal 16-bit blocks mein divide kiya jata hai.</li>
                <li>Key size 128 bits hoti hai, jo 52 subkeys mein expand hoti hai.</li>
                <li>Number of rounds 17 hote hain: 16 primary rounds aur 1 final transformation round.</li>
                <li>Odd-numbered rounds mein <strong>4 keys</strong> use hoti hain, jabki even-numbered rounds mein sirf
                    <strong>2 keys</strong> use hoti hain.
                </li>
                <li>Har round ka goal yeh hota hai ki data ko itna scramble aur mix kiya jaye ki akhir tak woh
                    completely
                    unrecognizable ho jaye.</li>
            </ul>

            <div class="in">
                <h3>Working</h3>
                <ul>
                    <li>64-bit plaintext ko pehle 4 equal parts mein divide kiya jata hai, har part ka size 16 bits hota
                        hai.</li>
                    <li>In parts ko hum X1, X2, X3, aur X4 ke naam se denote karte hain.</li>
                    <li>IDEA algorithm mein 17 rounds hote hain, jisme 16 primary rounds aur 17th round final
                        transformation
                        round hota hai.</li>
                    <li>Har round mein input blocks ko specific subkeys ke saath process kiya jata hai, jo 52 subkeys
                        generate hoti hain key expansion phase mein.</li>
                    <li><strong>Har round ke liye:</strong>
                        <ul>
                            <li>Subkeys ko blocks pe apply kiya jata hai modular addition, modular multiplication, aur
                                XOR
                                operations ke through.</li>
                            <li>Data blocks ko mix kiya jata hai taaki confusion aur diffusion ensure ho sake (yeh
                                concepts
                                encryption ke security ko badhate hain).</li>
                            <li>Odd aur even rounds ke operations alag hote hain, jo ki niche aur explain kiye gaye
                                hain.
                            </li>
                        </ul>
                    </li>
                    <li>Final transformation round mein last 4 subkeys (K49, K50, K51, K52) ko blocks pe apply kiya jata
                        hai.</li>
                    <li>Jab saare rounds complete ho jate hain, toh 4 resulting 16-bit blocks ko concatenate karte hain
                        aur
                        64-bit ciphertext banata hai.</li>
                </ul>
                <img src="../../images/cry24.jpeg" alt="">
            </div>
            <div class="in">
                <h3>What Happens in Each Round?</h3>
                <p>Each round involves processing the 4 parts (X1, X2, X3, X4) using subkeys and simple operations to
                    create layers of scrambling. Here's how it works:</p>

                <p><strong>Odd Rounds (e.g., Round 1, 3, 5...):</strong></p>
                <ul>
                    <li><strong>4 subkeys</strong> are used, one for each part: X1, X2, X3, and X4.</li>
                    <li>The keys are applied directly to the parts, followed by rearrangements and combinations to mix
                        the data.</li>
                    <li>The result is passed to the next round.</li>
                </ul>

                <p><strong>Even Rounds (e.g., Round 2, 4, 6...):</strong></p>
                <ul>
                    <li><strong>2 subkeys</strong> are used instead of 4, making these rounds slightly different from
                        the odd rounds.</li>
                    <li>The keys are applied to specific parts of the data, followed by scrambling and rearrangements.
                    </li>
                    <li>This adds another layer of complexity to the scrambled data.</li>
                </ul>

                <p><strong>Final Round (Round 17):</strong></p>
                <ul>
                    <li>The 4 parts (X1, X2, X3, X4) are processed with the last set of subkeys.</li>
                    <li>This step finalizes the ciphertext.</li>
                    <li>The scrambled 4 parts are combined into the final 64-bit ciphertext.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>RC5 Algorithm (Rivest Cipher)</h2>
            <ul>
                <li>RC5 ek symmetric key block cipher encryption algorithm hai, jo same key ka use karta hai encryption
                    aur decryption dono ke liye.</li>
                <li>Yeh algorithm plaintext ko two-word blocks mein process karta hai; matlab plaintext ko do
                    equal-sized blocks mein divide kiya jata hai.</li>
                <li>RC5 ke teen main parameters hain:
                    <ol>
                        <li><strong>w</strong>: Word size (yeh 16, 32, ya 64 bits ho sakta hai).</li>
                        <li><strong>r</strong>: Number of rounds (0 se 255 ke beech kuch bhi ho sakta hai).</li>
                        <li><strong>b</strong>: Key size in bits (yeh 0 se 255 ke range mein hoti hai).</li>
                    </ol>
                    <p>Yeh parameters plaintext ke requirements ke basis par choose kiye jate hain.</p>
                </li>
                <li>Algorithm ke main components teen hain:
                    <ol>
                        <li><strong>Key Expansion</strong>: Original secret key ko expand karke subkeys ka ek series
                            generate karta hai.</li>
                        <li><strong>Encryption</strong>: Subkeys ka use karke plaintext ko ciphertext mein transform
                            karta hai.</li>
                        <li><strong>Decryption</strong>: Encryption steps ko reverse karke original plaintext ko
                            retrieve karta hai.</li>
                    </ol>
                </li>
            </ul>

            <div class="in">
                <h3>Block Diagram</h3>
                <ul>
                    <li>Secret key ko pehle <strong>Key Expansion Algorithm</strong> ke through process kiya jata hai
                        taaki multiple subkeys generate ho sakein. Example ke liye, ek 128-bit secret key ko expand
                        karke subkeys ki ek sequence banai ja sakti hai jo block size par depend karti hai.</li>
                    <li>Encryption rounds ke dauraan yeh subkeys plaintext ko ciphertext mein transform karte hain.</li>
                    <li>Decryption mein, wahi subkeys reverse order mein use hoti hain taaki original plaintext wapas
                        mil sake.</li>
                </ul>
                <img src="../../images/cry25.jpeg" alt="Block Diagram of RC5">
            </div>

            <div class="in">
                <h3>What Happens in Each Stage?</h3>
                <h4>1. Key Expansion</h4>
                <ul>
                    <li>Yeh preprocessing step hai jo secret key se ek large number of subkeys generate karta hai.</li>
                </ul>
                <p><strong>Steps:</strong></p>
                <ol>
                    <li>64-bit plaintext ko do equal blocks mein divide kiya jata hai: <strong>A (32 bits)</strong> aur
                        <strong>B (32 bits)</strong>.
                    </li>
                    <li>Secret key ko expand karke ek subkey array <strong>S</strong> banaya jata hai, jo 2(r+1) subkeys
                        rakhta hai (e.g., S[0], S[1], ..., S[2r+1]).</li>
                    <li>Aur phir A aur B ke initial values yeh hoti hain:
                        <ul>
                            <li><strong>A = A + S[0]</strong></li>
                            <li><strong>B = B + S[1]</strong></li>
                        </ul>
                    </li>
                </ol>

                <h4>2. Encryption</h4>
                <ul>
                    <li>Encryption mein multiple rounds hote hain, jisme transformations subkeys ke saath ki jati hain.
                    </li>
                    <li>Har round mein:
                        <ol>
                            <li><strong>A</strong>: Bitwise operations (XOR, left rotation) aur addition subkey ke saath
                                ki jati hai taaki A update ho.</li>
                            <li><strong>B</strong>: Usi tarah bitwise operations aur agle subkey ke saath update hota
                                hai.</li>
                        </ol>
                    </li>
                    <li>Sab rounds ke baad, A aur B ko combine karke final ciphertext banaya jata hai.</li>
                </ul>

                <h4>3. Decryption</h4>
                <ul>
                    <li>Decryption ka process encryption steps ko reverse karta hai.</li>
                    <li>Same subkeys ka use hota hai, lekin reverse order mein apply kiya jata hai.</li>
                    <li>Operations ko undo kiya jata hai (e.g., addition ko subtract karna, rotations ko reverse karna)
                        taaki ciphertext se original plaintext wapas mile.</li>
                </ul>
            </div>
        </div>

        <div class="wh">
            <h2>Symmetric Key Distribution</h2>
            <ul>
                <li><strong>Symmetric key cryptography</strong> mein sender aur receiver ko same secret key use karni
                    padti
                    hai encryption aur decryption ke liye.</li>
                <li>Sabse bada challenge yeh hai ki yeh secret key dono parties ke beech securely kaise share ki jaye.
                </li>
                <li>Kayi methods hain key distribution ke liye, har method ke apne advantages aur drawbacks hote hain.
                </li>
            </ul>

            <div class="in">
                <h3>Methods of Symmetric Key Distribution</h3>
                <h4>1. Pre-Shared Key</h4>
<ul>
    <li><strong>Pre-Shared Key (PSK)</strong> ek aisa method hai jisme sender aur receiver ek secret key ko manually share karte hain, communication start hone se pehle.</li>
    <li>Yeh key securely share karne ke liye secure channels ka use kiya jata hai, jaise:
        <ul>
            <li><strong>Face-to-face meetings:</strong> Dono parties ek doosre se directly milke key exchange kar sakte hain.</li>
            <li><strong>Trusted couriers:</strong> Kisi reliable messenger ya service ke through key ko deliver kiya jata hai.</li>
        </ul>
    </li>
    <li><strong>Advantages:</strong>
        <ul>
            <li><strong>Simple aur direct:</strong> Small-scale systems ke liye yeh approach straightforward aur asaan hoti hai.</li>
            <li><strong>Infrastructure-free:</strong> Is method mein kisi additional hardware ya software ki zarurat nahi hoti.</li>
        </ul>
    </li>
    <li><strong>Drawbacks:</strong>
        <ul>
            <li><strong>Scalability issue:</strong> Large-scale ya geographically spread systems ke liye yeh practical nahi hai, kyunki manually har receiver tak key pahuchana mushkil hota hai.</li>
            <li><strong>Interception risk:</strong> Agar key transmission ke dauraan intercept ho gayi, to security compromise ho sakti hai.</li>
        </ul>
    </li>
</ul>


<h4>2. Using a Trusted Third Party (Key Distribution Center)</h4>
<ul>
    <li><strong>Key Distribution Center (KDC):</strong> Yeh ek trusted third party hoti hai jo secure key exchange ko facilitate karti hai.</li>
    <li><strong>Steps involved:</strong>
        <ol>
            <li><strong>Secure connection establish karna:</strong> Sender aur receiver dono apne secure connection KDC ke saath setup karte hain.</li>
            <li><strong>Session key generation:</strong> KDC ek unique session key generate karta hai jo sender aur receiver ke beech communication ke liye use hoti hai.</li>
            <li><strong>Session key ka secure transmission:</strong> KDC yeh session key securely dono parties ko transmit karta hai.</li>
        </ol>
    </li>
    <li><strong>Advantages:</strong>
        <ul>
            <li><strong>No direct key sharing:</strong> Sender aur receiver ko directly key exchange karne ki zarurat nahi hoti, jo security ko badhata hai.</li>
            <li><strong>Scalable:</strong> Yeh approach bade aur distributed systems ke liye kaafi effective hai.</li>
        </ul>
    </li>
    <li><strong>Drawbacks:</strong>
        <ul>
            <li><strong>Single point of failure:</strong> Agar KDC fail ho jaye ya compromise ho jaye, toh pura system impact hoga.</li>
            <li><strong>Additional infrastructure:</strong> Is approach ke liye KDC setup karna padta hai, aur KDC par trust karna zaruri hota hai.</li>
        </ul>
    </li>
</ul>



<h4>3. Using Symmetric Encryption with Public Key Infrastructure (PKI)</h4>
<ul>
    <li><strong>Public Key Cryptography:</strong> Yeh method symmetric keys ko securely exchange karne ke liye public key cryptography ka use karta hai.</li>
    <li><strong>Steps involved:</strong>
        <ol>
            <li><strong>Encrypt symmetric key:</strong> Sender symmetric key ko receiver ke public key se encrypt karta hai.</li>
            <li><strong>Transmit encrypted key:</strong> Sender encrypted key ko receiver tak bhejta hai.</li>
            <li><strong>Decrypt symmetric key:</strong> Receiver apni private key ka use karke encrypted key ko decrypt karta hai.</li>
        </ol>
    </li>
    <li><strong>Advantages:</strong>
        <ul>
            <li><strong>Secure communication:</strong> Yeh method insecure channels par bhi secure communication ensure karta hai.</li>
            <li><strong>Scalable:</strong> Bade aur complex systems ke liye effective hai.</li>
        </ul>
    </li>
    <li><strong>Drawbacks:</strong>
        <ul>
            <li><strong>PKI infrastructure requirement:</strong> Is method ke liye ek functioning PKI (Public Key Infrastructure) setup hona zaruri hai.</li>
            <li><strong>Computational overhead:</strong> Encryption aur decryption ki wajah se system par additional computational load aata hai.</li>
        </ul>
    </li>
</ul>


<h4>4. Diffie-Hellman Key Exchange</h4>
<ul>
    <li><strong>What is it?</strong> Diffie-Hellman ek mathematical algorithm hai jo do parties ko insecure channel par bhi ek shared symmetric key generate karne ki permission deta hai.</li>
    <li><strong>How does it work?</strong>
        <ol>
            <li><strong>Agree on public parameters:</strong> Dono parties ek public base aur ek public modulus par agree karte hain.</li>
            <li><strong>Generate private and public values:</strong> Har party apna ek private key select karti hai aur public base aur modulus ka use karke ek public value generate karti hai.</li>
            <li><strong>Exchange and compute shared key:</strong> Dono parties apne public values exchange karte hain aur apne private key ka use karke shared secret key compute karte hain.</li>
        </ol>
    </li>
    <li><strong>Advantages:</strong>
        <ul>
            <li><strong>Secure communication:</strong> Yeh method insecure channels par securely shared key generate karta hai.</li>
            <li><strong>No pre-shared secret required:</strong> Pehle se koi secret share karne ki zarurat nahi hoti.</li>
        </ul>
    </li>
    <li><strong>Drawbacks:</strong>
        <ul>
            <li><strong>Man-in-the-middle attack risk:</strong> Agar authentication ka use nahi kiya gaya, to yeh attacks ke liye vulnerable ho sakta hai.</li>
            <li><strong>Limited functionality:</strong> Yeh sirf key agreement ke liye hai, encryption ke liye nahi.</li>
        </ul>
    </li>
</ul>



            </div>

            <div class="in">
                <h3>Challenges in Symmetric Key Distribution</h3>
                <ul>
                    <li><strong>Secure key transfer without interception</strong>: Yeh challenge hai ki key ko securely
                        transfer
                        kiya jaye bina kisi third party ke usse intercept kiye. Agar key ko beech mein koi attack kar
                        le,
                        toh
                        poora encryption process compromised ho sakta hai.</li>
                    <li><strong>Managing keys in large systems</strong>: Jab ek system mein bohot saare users ho, tab
                        keys
                        ko
                        manage karna thoda mushkil ho jata hai. Har user ke liye unique keys generate karna aur unhe
                        securely
                        manage karna complex ho sakta hai.</li>
                    <li><strong>Handling key revocation and replacement</strong>: Agar kisi key ko compromise ho jaata
                        hai
                        (yaani wo leak ho gayi ho), toh usse revoke karna aur nayi key replace karna zaroori hota hai.
                        Yeh
                        process properly handle karna challenging ho sakta hai, kyunki har jaga par naye keys distribute
                        karne
                        padte hain.</li>
                </ul>
            </div>

        </div>
        <div class="wh">
            <h2>Random Number Generators in Cryptography</h2>
            <ul>
                <li>Random numbers are crucial in cryptography for tasks like key generation, nonce creation, and
                    secure
                    communication.</li>
                <li>They ensure unpredictability, making cryptographic algorithms secure against attacks.</li>
                <li>There are two main types of random number generators:
                    <ul>
                        <li><strong>True Random Number Generators (TRNGs)</strong></li>
                        <li><strong>Pseudo-Random Number Generators (PRNGs)</strong></li>
                    </ul>
                </li>
            </ul>

            <div class="in">
                <h3>Types of Random Number Generators</h3>

                <h4>1. True Random Number Generators (TRNGs)</h4>
                <ul>
                    <li>Generate randomness based on physical phenomena such as:
                        <ul>
                            <li>Thermal noise.</li>
                            <li>Electromagnetic interference.</li>
                            <li>Radioactive decay.</li>
                        </ul>
                    </li>
                    <li><strong>Features:</strong>
                        <ul>
                            <li>Non-deterministic: Results cannot be predicted.</li>
                            <li>Highly secure for cryptographic applications.</li>
                        </ul>
                    </li>
                    <li><strong>Drawbacks:</strong>
                        <ul>
                            <li>Slower than PRNGs due to dependency on physical events.</li>
                            <li>Requires specialized hardware to collect randomness.</li>
                        </ul>
                    </li>
                </ul>

                <h4>2. Pseudo-Random Number Generators (PRNGs)</h4>
                <ul>
                    <li>Generate randomness using mathematical algorithms based on a seed value.</li>
                    <li><strong>Features:</strong>
                        <ul>
                            <li>Deterministic: Output depends on the seed, making it reproducible if the seed is
                                known.
                            </li>
                            <li>Faster than TRNGs and suitable for software implementations.</li>
                        </ul>
                    </li>
                    <li><strong>Drawbacks:</strong>
                        <ul>
                            <li>Less secure if the seed or algorithm is compromised.</li>
                            <li>Not truly random, as the randomness relies on the algorithm's complexity.</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Cryptographically Secure PRNGs (CSPRNGs)</h3>
                <ul>
                    <li>A special class of PRNGs designed for cryptographic applications.</li>
                    <li><strong>Features:</strong>
                        <ul>
                            <li>Passes stringent randomness tests, ensuring unpredictability.</li>
                            <li>Resilient against attacks, even if part of the output is known.</li>
                        </ul>
                    </li>
                    <li><strong>Examples:</strong>
                        <ul>
                            <li>Yarrow Algorithm.</li>
                            <li>Fortuna Algorithm.</li>
                            <li>Dual_EC_DRBG (now deprecated due to vulnerabilities).</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Applications in Cryptography</h3>
                <ul>
                    <li><strong>Key Generation:</strong> Random numbers are used to generate cryptographic keys that
                        are
                        unpredictable.</li>
                    <li><strong>Initialization Vectors (IVs):</strong> Randomness ensures that IVs are unique for
                        each
                        encryption operation.</li>
                    <li><strong>Nonces:</strong> Unique random values prevent replay attacks in protocols.</li>
                    <li><strong>Salt Values:</strong> Random salts ensure secure password hashing by preventing
                        rainbow
                        table attacks.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Challenges in Random Number Generation</h3>
                <ul>
                    <li><strong>Bias:</strong> Random numbers must be uniformly distributed without any bias.</li>
                    <li><strong>Predictability:</strong> Ensuring unpredictability is critical, especially for
                        PRNGs.
                    </li>
                    <li><strong>Entropy Source:</strong> TRNGs rely on sufficient entropy from physical phenomena,
                        which
                        can be limited.</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/watch?v=ngqtEbxQLBE" target="_blank">Blowfish Algorithm Video
                    lecture
                    &neArr;</a>
            </li>
            <li><a href="https://www.youtube.com/watch?v=909pwcyqVFQ" target="_blank">IDEA Algorithm Video lecture
                    &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=4Z0xa13oov4" target="_blank">RC-5 Algorithm Video lecture
                    &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=4Z0xa13oov4" target="_blank">RC-5 Algorithm video lecture
                    &neArr;</a></li>
        </ul>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>
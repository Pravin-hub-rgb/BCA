<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Block Ciphers</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit3/indexh.html" class="link">Next Topic &rarr;</a>
                <a href="../unit1/indexh.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Modern Block Ciphers</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Modern Block Ciphers</h1>
        <ul>
            <li><strong>Block Ciphers ka Introduction:</strong> Cryptography mein block ciphers kaafi important role
                play karte hain jab baat data ko securely encrypt karne ki hoti hai.
                Block cipher ek aisa encryption method hai jo data ko fixed-size blocks (usually 64 ya 128 bits) mein
                divide karta hai aur har block ko alag se encrypt karta hai.
                Yeh method stream ciphers se different hai, jahan data ko bit by bit process kiya jata hai. Block
                ciphers ki security do main properties ke upar depend karti hai:
                <ul>
                    <li><strong>Confusion:</strong> Yeh property ensure karti hai ki ciphertext aur key ke beech ka
                        relationship complex ho jaye. Matlab, attacker ko ciphertext dekh kar key ya plaintext ka pata
                        lagana mushkil ho.</li>
                    <li><strong>Diffusion:</strong> Diffusion ka matlab hai ki jab plaintext ka ek symbol ciphertext
                        mein convert hota hai, toh uska effect kai ciphertext symbols par padta hai. Yeh ensure karta
                        hai ki data mein koi simple patterns na bane jo attacker ke liye useful ho sakte hain.</li>
                </ul>
            </li>

            <li><strong>DES (Data Encryption Standard) ka History:</strong> Block ciphers ki duniya mein ek bahut
                important cipher tha Data Encryption Standard (DES), jo 1970s mein develop kiya gaya tha.
                DES ne block cipher design ke liye ek strong foundation set ki thi. Lekin jaise-jaise computational
                power badhi, DES thoda weak pad gaya aur isme attacks ke liye vulnerabilities dikhne lagi.
                Yeh vulnerability computational advances ki wajah se thi, jaise faster computers jo DES ko break karne
                mein capable the. Isliye DES ko replace karne ke liye aur zyada secure encryption algorithms ki zarurat
                thi.</li>

            <li><strong>AES (Advanced Encryption Standard) ka Introduction:</strong> DES ki limitations ko dekhte hue,
                ek modern block cipher ka development hua jise Advanced Encryption Standard (AES) kaha gaya.
                AES ne na sirf stronger security provide ki, balki better performance bhi di. AES ka key size zyada
                flexible hai (128, 192, aur 256 bits), aur iske algorithms kaafi fast hain, jo modern systems mein
                efficiently kaam karte hain.
                AES ko duniya ke sabse trusted encryption standard ke roop mein adopt kiya gaya hai, aur yeh aaj bhi
                government aur private sectors mein widely use ho raha hai.</li>

            <li><strong>Block Ciphers ka Evolution:</strong> Is unit mein hum block ciphers ke evolution ko samjhenge.
                Hum pehle basic components aur design principles ko explore karenge jo block cipher ko banate hain,
                phir hum specific examples ko dekhenge jaise DES aur AES. Yeh samajhna zaroori hai kyunki yeh dikhata
                hai ki cryptography kaise evolve hui hai taaki modern security demands ko handle kiya ja sake.
                Jab hum in ciphers ko explore karenge, tab hume yeh samajh mein aayega ki kaise early encryption systems
                (jaise DES) ke principles ko use karke modern encryption methods ko build kiya gaya hai jo aaj ke
                complex security threats se nipat sakte hain.</li>
        </ul>

        <div class="wh">
            <h2>Modern Block Ciphers Components</h2>
            <ul>
                <li>Modern cryptography mein block ciphers kaafi commonly use hote hain data ko secure karne ke liye. In
                    ciphers ka kaam hai plaintext (yaani jo data aapko protect karna hai) ko fixed-size chunks ya blocks
                    mein todna aur fir har block ko ek complex series of steps ke through encrypt karna.</li>
                <li>Har step mein mathematical operations aur transformations hote hain jo itne complex hote hain ki
                    bina sahi key ke original data ko recover karna almost impossible ho jata hai.</li>
                <li>Block ciphers kaise kaam karte hain ye samajhne ke liye humein unke key components ko samajhna hoga.
                    Ye components encryption process ke building blocks jaise hote hain, aur har ek ka apna alag purpose
                    hota hai jo readable data ko ciphertext (encrypted data) mein badal dete hain.</li>
            </ul>

            <div class="in">
                <h3>S-Box</h3>
                <ul>
                    <li><strong>S-Box ka matlab:</strong> Substitution Box. Ye modern block ciphers ka ek important
                        component hota hai. Iska kaam hai ek small set of input bits lena aur unhe ek alag set of output
                        bits mein transform karna. Is process ko substitution kehte hain.</li>
                    <li><strong>Confusion introduce karna:</strong> S-Box ka purpose hai plaintext aur ciphertext ke
                        beech ka relationship confuse karna. Jab attacker patterns ko detect nahi kar pata, tab cipher
                        todna mushkil ho jata hai.</li>
                    <li>S-Box predefined hota hai, jo encryption algorithm ke designers ke dwara banaya jata hai. Iska
                        design aise hota hai ki ye cryptographic attacks (jaise differential aur linear cryptanalysis)
                        se resistant rahe.</li>
                    <li>Ek well-designed S-Box ensure karta hai ki agar input mein thoda bhi change ho, toh output
                        unpredictable ho jaye. Isse encryption aur secure ho jata hai.</li>
                </ul>
                <p><strong>Ek simple example dekhein:</strong></p>
                <p>Sochiye humare paas 2 bits ka input hai. Uska S-Box kuch aisa ho sakta hai:</p>
                <img src="../../images/cry9.png" alt="">
                <p><strong>Kaise kaam karta hai:</strong></p>
                <ul>
                    <li>Agar input 01 hai, toh S-Box table ke hisaab se output hoga 10.</li>
                    <li>Substitution process simply input bits ko S-Box ke according replace kar deta hai.</li>
                </ul>
                <p>Ye substitution original bits ko hide kar deta hai aur output dekh ke input samajhna mushkil bana
                    deta hai.</p>
                <p><strong>S-Box ka encryption mein role:</strong></p>
                <ul>
                    <li>S-Box ka goal hai encryption process mein confusion dalna. Confusion ka matlab hai ki key aur
                        ciphertext ke beech ka relationship obscure ho jaye, taki attacker ciphertext analyze karke key
                        deduce na kar sake.</li>
                    <li>Effective banane ke liye modern block ciphers generally bohot saari S-Boxes ka use karte hain
                        aur multiple rounds of substitution karte hain. Iske saath permutations jaise aur
                        transformations bhi hote hain. Ye sab milke encryption process ko itna difficult bana dete hain
                        ki bina key ke usse reverse karna lagbhag impossible ho jata hai.</li>
                </ul>
            </div>


            <div class="in">
                <h3>P-Box</h3>
                <ul>
                    <li><strong>P-Box ka matlab:</strong> Permutation Box. Ye modern block ciphers ka ek crucial
                        component hota hai. Iska kaam hai input bits ki positions ko shuffle karna bina unki values ko
                        badle. Is process ko permutation kehte hain.</li>
                    <li><strong>Diffusion introduce karna:</strong> P-Box ka main purpose hai encryption process mein
                        diffusion dalna. Diffusion ka matlab hai ki plaintext ke har bit ka influence ciphertext ke
                        multiple bits par ho. Isse attacker ke liye encryption ko trace karke original message tak
                        pahunchna mushkil ho jata hai.</li>
                    <li><strong>Simple explanation:</strong> Agar S-Box bits ki values badalta hai, toh P-Box sirf unki
                        positions ko rearrange karta hai. Ye bit shuffling encryption ko zyada secure banati hai.</li>
                    <li>P-Box predefined hota hai, algorithm ke designers ke dwara banaya jata hai, aur standardized
                        hota hai. Iska purpose hai har bit ka effect pure data block mein spread karna, taki patterns ko
                        detect karna mushkil ho.</li>
                </ul>
                <p><strong>Simple Example:</strong></p>
                <p>Maan lijiye humare paas ek 8-bit input hai: <code>10111001</code>. P-Box iske bits ko ek predefined
                    pattern ke according rearrange karega. Maan lijiye predefined permutation pattern kuch aisa hai:</p>
                <img src="../../images/cry10.png" alt="">
                <p><strong>Kaise kaam karta hai:</strong></p>
                <ul>
                    <li>Is pattern ke hisaab se, input <code>10111001</code> ko permute karte hain:
                        <ul>
                            <li>Position 1 par jo bit hai (1), wo position 4 par chali jayegi.</li>
                            <li>Position 2 par jo bit hai (0), wahi position 2 par rahegi.</li>
                            <li>Position 3 par jo bit hai (1), wo position 6 par chali jayegi.</li>
                            <li>Position 4 par jo bit hai (1), wo position 8 par chali jayegi.</li>
                            <li>Position 5 par jo bit hai (1), wo position 1 par chali jayegi.</li>
                            <li>Position 6 par jo bit hai (0), wo position 7 par chali jayegi.</li>
                            <li>Position 7 par jo bit hai (0), wo position 5 par chali jayegi.</li>
                            <li>Position 8 par jo bit hai (1), wo position 3 par chali jayegi.</li>
                        </ul>
                    </li>
                    <li>Is permutation ke baad output hoga: <code>11100110</code>.</li>
                </ul>
                <p>Ye rearrangement har bit ka influence pure block mein spread karta hai, jo ek extra layer of security
                    add karta hai.</p>
                <p><strong>P-Box ka encryption mein role:</strong></p>
                <ul>
                    <li><strong>Diffusion dalna:</strong> P-Box ka main goal hai diffusion introduce karna. Diffusion ka
                        matlab hai ki plaintext ke chhote se change ka bhi ciphertext par significant aur unpredictable
                        effect ho.</li>
                    <li>Modern block ciphers generally multiple P-Boxes ka use karte hain, har round mein alag
                        transformations ke saath. Ye overall encryption process ko highly secure aur cryptanalysis se
                        resistant banata hai.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Exclusive OR (XOR)</h3>
                <ul>
                    <li><strong>XOR ka matlab:</strong> Exclusive OR ek logical operation hai jo cryptography mein
                        extensively use hoti hai, especially in modern block ciphers. Iska ek simple rule hai: agar dono
                        input bits alag ho (different), toh output 1 hota hai; agar same ho, toh output 0 hota hai.</li>
                    <li><strong>Reversible operation:</strong> XOR ka sabse bada advantage ye hai ki ye reversible hoti
                        hai. Encryption mein, ye bits ko predictable way mein flip karne deti hai, lekin bina key ke
                        isko reverse karna mushkil hota hai. Isi wajah se XOR ko plaintext aur key ko combine karke
                        ciphertext banane ke liye use kiya jata hai.</li>
                    <li>Modern block ciphers mein, XOR ka S-Boxes aur P-Boxes ke saath combination hota hai jo secure
                        aur complex encryption systems banata hai. Iska role confusion aur diffusion dono provide karne
                        ka hota hai, jo cryptographic security ke liye critical hai.</li>
                </ul>

                <p><strong>Simple Example:</strong></p>
                <p>Chaliye ek example dekhte hain. Maan lijiye do 4-bit inputs hain: <code>1010</code> aur
                    <code>1100</code>. XOR operation har bit ko compare karta hai:
                </p>
                <img src="../../images/cry11.png" alt="">
                <p><strong>Kaise kaam karta hai:</strong></p>
                <ul>
                    <li>Pehla bit: <code>1 XOR 1 = 0</code> (kyunki dono bits same hain)</li>
                    <li>Dusra bit: <code>0 XOR 1 = 1</code> (kyunki bits alag hain)</li>
                    <li>Tisra bit: <code>1 XOR 0 = 1</code> (kyunki bits alag hain)</li>
                    <li>Chautha bit: <code>0 XOR 0 = 0</code> (kyunki dono bits same hain)</li>
                </ul>
                <p>Is XOR operation ka result hoga: <code>0110</code>.</p>

                <p><strong>XOR ka encryption mein role:</strong></p>
                <ul>
                    <li><strong>Reversibility:</strong> XOR cryptography mein isliye important hai kyunki ye reversible
                        hota hai. Agar aap XOR operation do baar same key ke saath lagate ho, toh original data wapas
                        milta hai. Ye property encryption aur decryption ke liye kaam aati hai.</li>
                    <li><strong>Plaintext aur key combine karna:</strong> XOR ko plaintext aur key ko combine karne ke
                        liye use kiya jata hai. Example ke liye, agar aap plaintext ko key ke saath XOR karte ho, toh
                        ciphertext milta hai. Decrypt karne ke liye, ciphertext ko same key ke saath XOR karte ho, aur
                        original plaintext wapas mil jata hai.</li>
                    <li>Modern block ciphers mein, XOR ko encryption ke different stages mein baar-baar use kiya jata
                        hai. Isse plaintext ya key ke chhote se change ka bhi ciphertext par unpredictable aur major
                        effect hota hai, jo security ko enhance karta hai.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Circular Shift</h3>
                <ul>
                    <li><strong>Circular Shift kya hai:</strong> Circular Shift, ya rotation, ek technique hai jo modern
                        block ciphers mein use hoti hai bits ko ek specific tarike se rearrange karne ke liye. Standard
                        shift se alag, jisme bits ko left ya right move kiya jata hai aur gaps ko zeros se fill kiya
                        jata hai, Circular Shift mein bits wrap ho jati hain, ek continuous loop create karte hue.</li>
                    <li><strong>Encryption mein fayda:</strong> Circular Shift diffusion enhance karta hai. Diffusion ka
                        matlab hai ki agar input ke ek bit mein change karein, toh uska asar output ke multiple bits par
                        hota hai. Ye security ko badhata hai. Circular Shifts ko aksar S-Boxes aur P-Boxes ke saath
                        combine kiya jata hai taaki complex encryption algorithms ban sakein.</li>
                </ul>

                <p><strong>Example:</strong></p>
                <p>Maan lijiye ek 4-bit input hai: <strong>1011</strong>. Agar hum ek circular left shift karein by 1,
                    toh result hoga: <strong>0111</strong>. Yaha, leftmost bit '1' rightmost position par shift ho jata
                    hai, jo dikhata hai ki kaise bits wrap hote hain.</p>

                <p><strong>Encryption mein Circular Shift ka role:</strong></p>
                <ul>
                    <li><strong>Diffusion achieve karna:</strong> Circular Shift ka main goal hai better diffusion lana.
                        Isse plaintext aur ciphertext ke beech ka relationship obscure ho jata hai, jo attackers ke liye
                        encrypted data ko samajhna mushkil bana deta hai.</li>
                    <li><strong>Multiple rounds mein use:</strong> Modern block ciphers mein, Circular Shifts multiple
                        rounds mein apply kiya jata hai, jo data ko extensively transform karta hai aur overall security
                        enhance karta hai.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Product Cipher</h3>
                <ul>
                    <li><strong>Product Cipher kya hai:</strong> Product Cipher ek encryption technique hai jo multiple
                        methods ko combine karti hai security enhance karne ke liye. Jab hum ek se zyada encryption
                        techniques ka use karte hain, toh encryption process zyada complex ho jata hai, jo cryptographic
                        attacks ke against resistant hota hai.</li>
                    <li><strong>Kaise kaam karta hai:</strong> Isme usually ek series of transformations apply ki jati
                        hain, jaise substitutions aur permutations. In transformations ko layer karte hain taaki
                        plaintext aur ciphertext ke beech ka relationship obscure ho jaye.</li>
                </ul>

                <p><strong>Example:</strong></p>
                <p>Sochiye ek plaintext block hai jo encrypt karna hai using do methods: pehle S-Box for substitution
                    aur phir P-Box for permutation. Process kuch is tarah hoga:</p>
                <ul>
                    <li>Step 1: Pehle plaintext par S-Box apply karo taaki ek intermediate output mile.</li>
                    <li>Step 2: Intermediate output par P-Box lagao taaki final ciphertext generate ho.</li>
                </ul>

                <p><strong>Fayda kya hai:</strong> Ye combination ensure karta hai ki agar ek method compromise ho bhi
                    jaye, toh bhi additional encryption layers ki wajah se overall security intact rahe.</p>

                <p><strong>Encryption mein Product Ciphers ka role:</strong></p>
                <ul>
                    <li><strong>Security badhane ka goal:</strong> Product Ciphers ka main goal hai security ko enhance
                        karna by using multiple layers of encryption. Ye encryption ko itna complicated bana deta hai ki
                        attackers ke liye har layer ko individually break karna bahut mushkil hota hai.</li>
                    <li><strong>Modern algorithms ka base:</strong> Aaj ke modern encryption algorithms mein Product
                        Ciphers kaafi common hain kyunki ye alag-alag techniques ke strengths ko combine karke ek robust
                        aur secure communication framework dete hain.</li>
                </ul>
            </div>

        </div>
        <div class="wh">
            <h2>Thoughts of Feistel Design</h2>
            <p>Product ciphers ka concept samajhne ke baad, ab hum Feistel design par baat karte hain. Ye ek critical
                framework hai jo block ciphers ki security ko enhance karta hai. Jab product ciphers multiple encryption
                techniques ko layer karte hain, Feistel structure in processes ko organize karta hai in a unique way, jo
                encryption ko zyada efficient aur secure banata hai. Ye design modern encryption algorithms ka
                foundation hai, jaise DES (Data Encryption Standard). Feistel design ke principles samajhna zaruri hai
                kyunki ye batata hai ki multiple processing rounds kaise plaintext aur ciphertext ke beech ka
                relationship effectively obscure karte hain, jo overall security ko strengthen karta hai.</p>

            <div class="in">
                <h3>Feistel Cipher</h3>
                <p><strong>Feistel Cipher kya hai:</strong> Feistel cipher ek symmetric encryption method hai jo modern
                    block ciphers mein use hoti hai. Iska naam Horst Feistel ke naam par rakha gaya hai. Is design mein
                    encryption process ko multiple rounds mein tod diya jata hai, jo security ko enhance karta hai aur
                    process efficient bhi banata hai. Feistel structure ki khaas baat ye hai ki encryption aur
                    decryption ke liye ek hi algorithm use hota hai, jo ise versatile banata hai.</p>

                <h3>How the Feistel Cipher Works</h3>
                <p>Chaliye Feistel cipher kaam kaise karta hai, uska ek step-by-step breakdown dekhte hain. Is process
                    mein plaintext ko ek block mein liya jata hai aur usse do halves mein divide kiya jata hai. Multiple
                    rounds mein transformations apply hote hain, jisme ek round key (jo original encryption key se
                    derive hoti hai) ka use hota hai. Yahan har step ko detail mein samjhte hain:</p>

                <ul>
                    <li><strong>Step 1: Input Splitting</strong><br>
                        Plaintext block ko do parts mein tod diya jata hai:
                        <em>Left Half (L)</em> aur <em>Right Half (R)</em>. Yeh splitting encryption ka pehla step hai.
                    </li>

                    <li><strong>Step 2: Round Function (F)</strong><br>
                        Har round mein ek function apply hota hai, jise <em>F</em> kehte hain. Yeh function right half
                        (R) ko process karta hai ek round key ke saath (jaise K1, K2, etc.). Yeh step data ko modify
                        karte hue unpredictable banata hai.</li>

                    <li><strong>Step 3: XOR Operation</strong><br>
                        Jo output round function (F) se milta hai, usse left half (L) ke saath XOR (Exclusive OR)
                        operation ke zariye combine kiya jata hai. Yeh step confusion aur diffusion ka ek powerful
                        mechanism hai jo data ki security badhata hai.</li>

                    <li><strong>Step 4: Swapping</strong><br>
                        XOR operation ke baad left aur right halves ko swap kar diya jata hai. Right half (R) naya left
                        half (L) ban jata hai, aur modified left half (L) naya right half (R) ban jata hai. Yeh step har
                        round ke baad repeat hota hai.</li>

                    <li><strong>Step 5: Repetition</strong><br>
                        Yeh pura process multiple rounds ke liye repeat hota hai. Typically, 16 ya usse zyada rounds
                        hote hain, jisme har round ki key alag hoti hai. Zyada rounds hone ki wajah se encryption kaafi
                        strong ho jata hai.</li>

                    <li><strong>Step 6: Final Output</strong><br>
                        Jab saare rounds complete ho jate hain, to left aur right halves ko combine karke final
                        ciphertext produce hota hai. Yeh ciphertext kisi ke liye bhi samajhna mushkil banata hai, jab
                        tak unke paas correct key na ho.</li>
                </ul>

                <p><strong>Understanding Feistel Cipher:</strong><br>
                    Feistel cipher ka strength uski repetitive nature aur reversible process mein hai. Encryption aur
                    decryption dono same algorithm ka use karke kiye jate hain, jo simplicity aur efficiency ensure
                    karta hai. Yehi reason hai ki Feistel structure par based algorithms, jaise DES, cryptography ke
                    world mein itne popular hain.</p>


                <img src="../../images/cry12.jpeg" alt="">

                <h3>Key Points</h3>
                <ul>
                    <li>Feistel structure yeh allow karta hai ki encryption aur decryption dono same function ka use
                        karte hue kiye ja sakein, jo iski efficiency ko enhance karta hai.</li>
                    <li>Multiple rounds ko repeat karne se, Feistel cipher effectively plaintext aur ciphertext ke beech
                        ke relationships ko obscure kar deta hai, jisse security increase hoti hai.</li>
                    <li>Yeh design famous encryption standards jaise DES (Data Encryption Standard) ka base hai, jo abhi
                        bhi widely use ho raha hai.</li>
                </ul>
            </div>
        </div>


        <div class="wh">
            <h2>Data Encryption Standard (DES)</h2>
            <ul>
                <li>DES ek symmetric key-block cipher hai, iska matlab hai ki encryption aur decryption dono ke liye
                    same key use hoti hai.</li>
                <li>Isse NIST (National Institute of Standards and Technology) ne publish kiya tha.</li>
                <li>DES ek block cipher hai, jo data ko fixed-size blocks mein encrypt karta hai.</li>
                <li>Ab tak hum Feistel cipher ke baare mein padh chuke hain, aur DES bhi basicly Feistel structure ka
                    use karta hai. Isme total 16 rounds hote hain, aur har round ek Feistel round hota hai.</li>
                <li>DES kaafi time tak widely used tha secure data transmission ke liye. Yeh data ko 64-bit blocks mein
                    encrypt karta hai aur encryption process ko control karne ke liye 56-bit key use karta hai.
                    Symmetric key cryptography ka matlab hai ki same key encryption aur decryption dono ke liye use hoti
                    hai.</li>
                <li>Lekin computing power ke badhne ke saath, DES ab kam secure ho gaya hai kyunki iska key length (56
                    bits) brute-force attacks ke liye vulnerable hai. Isliye, DES ko modern encryption algorithms jaise
                    AES ne replace kar diya hai. Fir bhi, DES ko samajhna zaroori hai kyunki yeh cryptography ke history
                    aur encryption techniques ke evolution ko samajhne mein madad karta hai.</li>
                <li>DES ke steps yeh hain:
                    <ol>
                        <li><strong>Initial Permutation (IP):</strong> Sabse pehle, 64-bit plaintext ko ek predefined
                            table ke base par rearrange kiya jaata hai. Is step mein data ko ek specific order mein
                            arrange kiya jaata hai jo encryption ko zyada complex banata hai.</li>
                        <li><strong>16 Feistel Rounds:</strong> Uske baad data ko 16 rounds ke liye Feistel structure se
                            pass kiya jaata hai. Har round mein ek alag 48-bit subkey ka use hota hai jo original 56-bit
                            key se derive hota hai. Is process mein data ko repeatedly modify kiya jaata hai, jisse
                            security badhti hai.</li>
                        <li><strong>Final Permutation (FP):</strong> 16 rounds ke baad, final permutation apply hota
                            hai, jisme bits ko dobara rearrange karke final 64-bit ciphertext banaya jaata hai, jo
                            encrypted data hota hai.</li>
                    </ol>
                </li>
            </ul>

            <div class="in">
                <h3>General Structure of DES:</h3>
                <img src="../../images/cry13.jpeg" alt="DES General Structure">
                <p><strong>Explanation of the General Structure of DES:</strong></p>
                <ul>
                    <li>DES encryption process 64-bit plaintext se start hota hai. Sabse pehle, yeh plaintext ek Initial
                        Permutation (IP) se guzarata hai, jisme bits ko ek fixed table ke according rearrange kiya jaata
                        hai. Yeh permutation process data ko pehle hi confuse kar deta hai, jisse encryption thoda
                        complex ho jata hai.</li>
                    <li>Uske baad, data 16 rounds ke liye encryption ke through jaata hai, jo Feistel cipher structure
                        pe based hota hai. Har round mein, plaintext ko do halves mein divide kiya jaata hai: ek left
                        half (L) aur ek right half (R). Right half ko transform kiya jaata hai, aur phir left half ko
                        XOR operation ke zariye transformed right half ke saath combine kiya jaata hai. Is process ke
                        through data ka confusion aur diffusion hota hai, jo cryptographic principles hain jo data ko
                        scramble karte hain aur isse secure banate hain.</li>
                    <li>16 rounds complete hone ke baad, dono halves ko dobara combine karke Final Permutation (FP) se
                        guzaraya jaata hai. Is step mein, bits ko dobara rearrange kiya jaata hai, jisse final 64-bit
                        ciphertext milta hai, jo encrypted data hota hai.</li>
                    <li>Har ek round ke liye alag keys ki zaroorat hoti hai. DES ke paas ek 56-bit cipher key hoti hai,
                        lekin har round ke liye yeh key se 48-bit subkey generate kiya jaata hai, jo round key
                        generation process ke through banta hai. Matlab, DES mein ek 56-bit key start hoti hai, lekin
                        har round mein different 48-bit subkey use hota hai.</li>
                    <li>Ek important baat yaad rakhna, DES Feistel cipher model ko follow karta hai, iska matlab hai ki
                        encryption process ko decryption mein easily reverse kiya jaa sakta hai. Yaani, agar kisi ko
                        ciphertext mila hai, toh woh same steps follow karke original plaintext ko recover kar sakte
                        hain, bas key ko properly reverse process mein use karna padta hai.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Initial and Final Permutation</h3>
                <ul>
                    <li>Data Encryption Standard (DES) mein initial permutation (IP) aur final permutation (FP) ka use
                        hota hai encryption aur decryption process mein. Yeh permutations security ko directly enhance
                        nahi karte, lekin yeh bits ko ek structured way mein reorder karte hain encryption aur
                        decryption ke core process (Feistel rounds) se pehle aur baad mein.</li>
                </ul>

                <p><strong>Initial Permutation (IP)</strong></p>
                <ul>
                    <li>Initial permutation DES ke start mein ek baar hoti hai, jab 16 Feistel rounds shuru hone se
                        pehle. Matlab yeh pehle step hai jo encryption process mein hota hai.</li>
                    <li>Yeh 64 bits ko ek naye order mein rearrange karta hai, ek predefined table ke base par. Matlab,
                        plaintext jo input diya gaya hota hai, usko ek different format mein convert kar diya jaata hai.
                    </li>
                </ul>

                <p>Initial Permutation Table (IP Table)</p>
                <img src="../../images/cry14.png" alt="Initial Permutation Table">
                <ul>
                    <li>Is table mein, plaintext ka pehla bit ko 58th position pe shift kiya jaata hai, doosra bit 50th
                        position pe, aur aise har bit ko naye positions pe move kiya jaata hai. Yeh process 64 bits ke
                        liye hoti hai. Is reordering se message ka structure thoda complex ho jaata hai, lekin yeh
                        encryption ka part nahi hai. Yeh bas data ko ek naya format deta hai jisse analysis thoda
                        mushkil ho jaata hai.</li>
                </ul>

                <p><strong>Purpose of Initial and Final Permutations</strong></p>
                <ul>
                    <li><strong>Increase Complexity:</strong> Jabki initial aur final permutations directly security ko
                        enhance nahi karte, yeh DES ke process ko analyze karna complex bana dete hain. Initial
                        permutation input data ko scramble kar deti hai aur final permutation encryption ke baad us
                        scrambling ko undo kar deti hai.</li>
                    <li><strong>Prepare Data for Feistel Rounds:</strong> Initial permutation bits ko reorder karti hai
                        taaki data Feistel structure ke liye suitable ho, jo core encryption ka kaam karta hai.</li>
                </ul>

                <p><strong>Final Permutation (FP)</strong></p>
                <ul>
                    <li>Final permutation 16 Feistel rounds ke baad hoti hai. Yeh exact reverse hoti hai initial
                        permutation ki, jo bit order ko restore kar deti hai taaki output waisa hi scrambled dikhai de
                        jaise plaintext originally tha. Matlab, final permutation bit positions ko unke original
                        positions pe laati hai, jo initial permutation ne change kiya tha.</li>
                </ul>

                <p>Final Permutation Table (FP Table)</p>
                <img src="../../images/cry15.png" alt="Final Permutation Table">
                <ul>
                    <li>Is table mein, Feistel rounds ke result ka 58th bit final ciphertext ka pehla bit ban jaata hai.
                        Yeh reverse operation ensure karta hai ki bit positions ko restore kiya jaaye jo initial
                        permutation ke time pe change ki gayi thi. Iska matlab hai ki data ko encryption ke baad phir se
                        waisa hi structure milega, jaisa starting mein tha.</li>
                </ul>
            </div>


            <div class="in">
                <h3>Rounds:</h3>
                <ul>
                    <li>DES mein total 16 rounds hote hain aur har round ek Feistel Cipher round hota hai.</li>
                    <li>Jab Feistel cipher ka structure use hota hai DES mein, toh 64-bit plaintext ko do equal halves
                        mein divide kiya jaata hai:
                        <ul>
                            <li>Left half, jise L1 kaha jaata hai, 32 bits ka hota hai.</li>
                            <li>Right half, jise R1 kaha jaata hai, wo bhi 32 bits ka hota hai.</li>
                        </ul>
                    </li>
                    <p>Sirf right half (R1) aur pehla round key (K1) ko DES function ke through pass kiya jaata hai. Us
                        function ka output phir left half (L1) ke saath XOR kiya jaata hai. XOR operation ke baad, left
                        aur right halves ko swap kiya jaata hai. Yeh process, dividing, processing, XORing, aur
                        swapping, 16 rounds tak continue hota hai. Har round mein ek unique 48-bit round key ka use hota
                        hai.</p>
                    <p>DES function har round mein crucial role play karta hai. Isliye, yeh samajhna zaroori hai ki DES
                        function ka structure aur operations kaise kaam karte hain taaki aap samajh sakein ki DES mein
                        encryption kaise hota hai.</p>
                </ul>
                <img src="../../images/cry16.jpeg" alt="Rounds in DES">

                <h3>DES Function</h3>
                <ul>
                    <li>DES function ek 48-bit key ko rightmost 32 bits of input data block pe apply karta hai, aur usse
                        32-bit output milta hai.</li>
                    <li>Yeh function kuch important components ke through kaam karta hai:
                        <ol>
                            <li><strong>Expansion P-Box:</strong> Iska kaam hai 32-bit input ko 48 bits mein expand
                                karna, jisme kuch bits ko duplicate kiya jaata hai taaki 8 groups of 6 bits ban sakein.
                            </li>
                            <li><strong>Whitener (XOR Operation):</strong> Expanding ke baad, 48-bit data ko XOR kiya
                                jaata hai 48-bit subkey ke saath, jo main key se derive kiya jaata hai.</li>
                            <li><strong>Group of S-Boxes:</strong> XOR operation ke baad ka 48-bit output 8 S-Boxes ke
                                through pass hota hai. Har S-box 6 bits ko 4 bits mein convert karta hai, aur final
                                output 32 bits ka hota hai.</li>
                            <li><strong>Straight P-Box:</strong> Yeh 32-bit output phir straight P-Box se permute hota
                                hai, jo bits ko ek predefined order mein arrange karta hai, aur 32-bit output produce
                                hota hai.</li>
                        </ol>
                    </li>
                </ul>

                <p><strong>Function Diagram:</strong></p>
                <img src="../../images/cry17.jpeg" alt="DES Function Diagram">

                <p>Ab DES function ka explanation kuch is tarah hai: <br>
                    Sabse pehle, 32-bit right half ko Expansion P-Box mein bheja jaata hai, jahan usse 48 bits mein
                    expand kiya jaata hai, kuch bits ko duplicate karke. Phir, yeh 48-bit value 48-bit subkey ke saath
                    XOR hoti hai jo main DES key se generate hoti hai. XOR operation ke baad jo result aata hai, use 8
                    S-Boxes ke through pass kiya jaata hai. Har S-Box mein 6 bits ka input hota hai, jo 4 bits ke output
                    mein convert ho jaata hai, aur final output 32 bits ka hota hai. <br>
                    Iske baad, yeh 32-bit output Straight P-Box se permute hota hai, jahan bits ko fixed order mein
                    rearrange kiya jaata hai. Is final 32-bit result ko DES ke overall structure mein wapas combine kiya
                    jaata hai.</p>
            </div>

        </div>
        <div class="wh">
            <h2>Cryptanalysis</h2>
<p>
    <strong>Cryptanalysis:</strong> Cryptanalysis ek fascinating field hai jo cryptographic systems ko todne ya unhe samajhne ki koshish karta hai bina secret key ke. Simple terms mein, ye study un techniques ka hota hai jo attackers use karte hain taaki encrypted messages ka original data nikal sakein. Cryptanalysis ka main goal hota hai algorithms ki vulnerabilities aur weaknesses ko dhoondhna, jo attackers ko encryption bypass karne ka mauka de sakti hain.
</p>
<p>
    Yeh cryptography ka ek important part hai kyunki iska focus sirf attacks par nahi, balki security ko improve karne par bhi hota hai. Jab cryptanalysis se flaws identify hote hain, tab encryption methods ko zyada strong banaya ja sakta hai.
</p>
<p>
    Cryptanalysis ke different techniques hain, lekin block ciphers ko analyze karne ke liye jo do most common methods use hote hain, wo hain:
</p>
<ul>
    <li><strong>Differential Cryptanalysis:</strong> Is method mein encrypted data ke andar patterns ko dhoondhne ki koshish ki jati hai. Attackers dekhte hain ki plaintext ke small changes ciphertext mein kaise changes laate hain. Is analysis ka goal hota hai algorithm ke andar ki vulnerabilities ka pata lagana aur round keys tak pahunchna.</li>
    
    <li><strong>Linear Cryptanalysis:</strong> Is technique mein mathematical relationships ka use kiya jata hai plaintext, ciphertext, aur encryption key ke beech. Attackers kuch plaintext-ciphertext pairs ke analysis se encryption process ka model banate hain aur key ko deduce karne ki koshish karte hain.</li>
</ul>
<p>
    Yeh dono methods cryptography ke testing tools jaise kaam karte hain, jo algorithms ki strength ko evaluate karte hain. Famous block cipher algorithms jaise <strong>Data Encryption Standard (DES)</strong> inhi methods ke against test kiye gaye hain. Agar koi algorithm in techniques ke against resist kar paye, to samjha jata hai ki wo kaafi strong hai.
</p>
<p>
    Overall, cryptanalysis ka role sirf encryption todna nahi, balki security ke standards ko improve karna bhi hai. Isliye, cryptographers aur security researchers dono ke liye is field ka samajhna equally zaruri hai!
</p>


<div class="in">
    <h3>Differential Cryptanalysis</h3>
    <p>
        <strong>Differential Cryptanalysis:</strong> Differential cryptanalysis ek kaafi well-known aur powerful technique hai jo block ciphers ko todne ke liye use hoti hai. Yeh technique 1980s ke end mein develop hui thi aur iska focus hota hai yeh analyze karna ki jab input data mein kuch differences kiye jate hain, toh un differences ka output data par kya effect padta hai. Iska main goal hota hai cipher ke through differences ka propagation samajhna aur un patterns ko exploit karna jo key ke baare mein information reveal kar sake.
    </p>
    <ul>
        <li><strong>Basic Concept:</strong> Differential cryptanalysis mein, attacker do plaintexts ke pairs ko examine karta hai jisme specific differences hote hain (jaise kuch bits ko flip karna) aur yeh dekhna hota hai ki yeh differences encryption ke multiple rounds ke through kaise propagate karte hain.</li>
        <li><strong>Objective:</strong> Is technique ka main goal hota hai input differences aur output differences ke beech correlations dhoondhna, jo expected random chance se zyada probability ke saath ho. Jab attacker aise patterns identify kar leta hai, toh wo secret key ke kuch hisson ke baare mein educated guesses kar sakta hai.</li>
        <li><strong>Application to DES:</strong> Differential cryptanalysis wo pehla attack tha jise use karke DES cipher ki kuch vulnerabilities expose hui thi. Halanki, agar DES mein 16 full rounds ka encryption process use hota hai, toh yeh attack DES ko break nahi kar pata.</li>
    </ul>

    <h4>Steps in Differential Cryptanalysis:</h4>
    <ol>
        <li><strong>Choose a Pair of Plaintexts:</strong> Sabse pehle attacker do aise plaintexts select karta hai jo ek specific amount se differ karte hain, jaise kuch bits ko flip karna.</li>
        <li><strong>Encrypt the Plaintexts:</strong> Dono plaintexts ko block cipher se encrypt kiya jata hai, bina key ke jaana.</li>
        <li><strong>Analyze the Differences:</strong> Ab attacker ciphertexts ke beech differences ko analyze karta hai aur dekhta hai ki kaunse patterns common hain ya high probability ke saath occur kar rahe hain.</li>
        <li><strong>Guess Part of the Key:</strong> Observed patterns ki basis par, attacker secret key ke kuch hisson ke baare mein guess karne ki koshish karta hai aur key ki possibilities ko narrow down karta hai.</li>
        <li><strong>Iterate the Process:</strong> Yeh process repeat hota hai different plaintext pairs ke saath, taaki aur information gather ki ja sake aur key ko fully recover kiya ja sake.</li>
    </ol>

    <p>
        Differential cryptanalysis ek powerful attack hai jo ciphers ko break kar sakta hai, lekin modern ciphers is attack ko dhyaan mein rakh kar design kiye gaye hain aur unmein aise defenses hoti hain jo is attack ko ineffective bana deti hain.
    </p>
</div>


<div class="in">
    <h3>Linear Cryptanalysis</h3>
    <p>
        <strong>Linear Cryptanalysis:</strong> Linear cryptanalysis bhi ek famous technique hai jo block ciphers ko todne ke liye use hoti hai. Yeh differential cryptanalysis ke baad develop hui thi aur iska focus hota hai linear approximations dhoondhna jo plaintext, ciphertext aur key ke beech relationship ko describe karte hain. Is technique ka main goal yeh hota hai ki in relationships mein jo statistical biases hain, unhe exploit karte hue secret key ko recover kiya ja sake.
    </p>
    <ul>
        <li><strong>Basic Concept:</strong> Linear cryptanalysis mein attacker linear equations create karta hai jo encryption process ko approximate karte hain. Yeh equations plaintext aur ciphertext ke specific bits ko key ke bits ke saath relate karte hain. Jab attacker in equations ko analyze karta hai, toh wo un patterns ko identify kar sakta hai jo key ke baare mein information deduce karne mein madadgar hote hain.</li>
        <li><strong>Objective:</strong> Is technique ka main objective yeh hota hai ki linear approximations dhoondhe jayein jo random chance se zyada probability ke saath true hote hain (50% se zyada). Jitni zyada baar yeh approximations true hote hain, utna zyada information attacker ko key ke baare mein milta hai.</li>
        <li><strong>Application to DES:</strong> Linear cryptanalysis ko DES par successfully apply kiya gaya hai, lekin jaise differential cryptanalysis ke case mein hota hai, yeh attack full 16 rounds ke DES encryption par effective nahi hota.</li>
    </ul>

    <h4>Steps in Linear Cryptanalysis:</h4>
    <ol>
        <li><strong>Collect Plaintext and Ciphertext Pairs:</strong> Sabse pehle attacker ko known plaintext-ciphertext pairs collect karne padte hain jo same secret key se encrypt kiye gaye hote hain. In pairs ki madad se attacker encryption process ko samajhne ki koshish karta hai.</li>
        <li><strong>Analyze the Data:</strong> Attackers collected data ko analyze karte hain aur dekhte hain ki kya koi linear patterns hain jo specific bits of plaintext aur ciphertext ko key ke bits ke saath relate karte hain.</li>
        <li><strong>Create Linear Approximation Equations:</strong> Ab attacker linear equations banata hai jo encryption process ko approximate karte hain. Har equation key ke ek chhote hissa ke baare mein clue deta hai.</li>
        <li><strong>Count Occurrences:</strong> Phir attacker yeh calculate karta hai ki yeh linear approximations collected data mein kitni baar true hoti hain. Agar yeh approximations 50% se zyada time true hoti hain, toh unhe useful samjha jata hai.</li>
        <li><strong>Guess the Key:</strong> Useful approximations ke basis par, attacker key ke bits ke baare mein educated guesses karta hai aur phir un guesses ko iteratively refine karta hai.</li>
    </ol>

    <p>
        Linear cryptanalysis differential cryptanalysis se thoda complex hai aur isko successfully apply karne ke liye attacker ko kaafi saari known plaintext-ciphertext pairs ki zarurat hoti hai. Phir bhi, yeh block ciphers ki security evaluate karte waqt ek important tool hai.
    </p>
</div>


            <div class="in">
                <h3>Comparison of Differential and Linear Cryptanalysis</h3>
                <p>
                    Both differential and linear cryptanalysis are powerful tools for breaking block ciphers, but they
                    use
                    different approaches:
                </p>
                <ul>
                    <li><strong>Differential Cryptanalysis:</strong> Focuses on analyzing how differences in input
                        affect
                        differences in output and looks for patterns in these differences.</li>
                    <li><strong>Linear Cryptanalysis:</strong> Focuses on creating linear approximations between the
                        input
                        and output and looks for statistical biases in these approximations.</li>
                </ul>
            </div>

            <p>
                Modern cryptographic algorithms are designed with defenses against these attacks, but understanding them
                is essential for evaluating the security of any cipher.
            </p>
        </div>
        <div class="wh">
            <h2>Block Cipher Design Principles</h2>
            <p>
                A <strong>block cipher</strong> is a method of encrypting text where a cryptographic key and algorithm
                are applied to a block of data (often 64 or 128 bits) as a single unit, rather than one bit at a time
                like in stream ciphers. The design of block ciphers is based on several principles that ensure the
                cipher is secure and resistant to various forms of cryptanalysis.
                <br><br>
                There are three important design principles when creating a block cipher: the number of rounds, the
                design of the function <strong>f</strong>, and the key schedule algorithm. These factors work together
                to ensure that the encryption is strong, difficult to break, and resistant to known cryptanalysis
                methods like differential and linear cryptanalysis.
            </p>
            <div class="in">
                <h3>1. Number of Rounds</h3>
                <p>
                    The <strong>number of rounds</strong> in a block cipher refers to how many times the encryption
                    process
                    is applied to the data. Each round consists of several transformations that increase the complexity
                    of
                    the ciphertext, making it harder for an attacker to reverse-engineer or guess the original
                    plaintext.
                </p>
                <ul>
                    <li><strong>Why Rounds Matter:</strong> The more rounds a cipher has, the more difficult it becomes
                        for
                        an attacker to break it. Each round scrambles the data further, adding layers of complexity. In
                        practice, ciphers like DES use 16 rounds, while more modern ciphers like AES can use 10, 12, or
                        14
                        rounds depending on the key size.</li>
                    <li><strong>Security vs. Efficiency:</strong> While more rounds increase security, they also make
                        encryption and decryption slower. The goal is to find a balance between security and
                        performance.
                    </li>
                    <li><strong>Role in Cryptanalysis Resistance:</strong> Block ciphers are designed with enough rounds
                        to
                        resist cryptanalysis methods like differential and linear cryptanalysis. Each round adds more
                        diffusion and confusion, which are key to making the encryption secure.</li>
                </ul>
                <p>
                    In general, the number of rounds should be large enough to ensure that attacks become
                    computationally
                    infeasible. Fewer rounds may leave the cipher vulnerable to certain attacks, while too many rounds
                    can
                    lead to unnecessary inefficiency.
                </p>
            </div>
            <div class="in">
                <h3>2. Design of Function f</h3>
                <p>
                    The <strong>function f</strong> is a critical component of many block ciphers, especially in
                    Feistel-based ciphers like DES. It is applied to part of the data and combined with the other half
                    using
                    operations like XOR. The security of the cipher heavily depends on how well the function f is
                    designed.
                </p>
                <ul>
                    <li><strong>Confusion and Diffusion:</strong> The function f should introduce confusion and
                        diffusion in
                        the data. Confusion refers to making the relationship between the key and ciphertext as complex
                        as
                        possible, while diffusion ensures that changes in the input are spread widely across the output.
                    </li>
                    <li><strong>Non-Linearity:</strong> The function f must be non-linear, meaning that it should be
                        difficult to express as a simple mathematical formula. Non-linearity helps prevent attackers
                        from
                        using algebraic methods to break the cipher.</li>
                    <li><strong>S-Boxes:</strong> In many block ciphers, function f includes substitution boxes
                        (S-boxes),
                        which map input bits to output bits in a complex, non-linear way. The design of S-boxes is
                        crucial
                        because weak S-boxes can lead to vulnerabilities.</li>
                    <li><strong>Permutation (P-Boxes):</strong> Some ciphers also include P-boxes (permutation boxes)
                        within
                        function f. P-boxes rearrange the bits in the data, spreading out the influence of individual
                        bits
                        across the block to provide better diffusion.</li>
                </ul>
                <p>
                    The design of function f must be carefully tested to ensure it resists all known attacks. It must
                    also
                    be efficient so that encryption and decryption can be performed quickly without sacrificing
                    security.
                </p>
            </div>
            <div class="in">
                <h3>3. Key Schedule Algorithm</h3>
                <p>
                    The <strong>key schedule algorithm</strong> is responsible for generating the subkeys used in each
                    round
                    of encryption. Instead of using the same key for every round, most block ciphers break the main key
                    into
                    several subkeys, which are then applied during the encryption process.
                </p>
                <ul>
                    <li><strong>Generating Subkeys:</strong> The key schedule algorithm takes the original encryption
                        key
                        and derives several subkeys from it. Each round uses a different subkey, which adds complexity
                        to
                        the encryption process.</li>
                    <li><strong>Security Considerations:</strong> The key schedule should ensure that the subkeys are
                        sufficiently different from one another. If subkeys are too similar, it could weaken the
                        encryption
                        and make it more susceptible to attacks.</li>
                    <li><strong>Role in Resisting Attacks:</strong> A strong key schedule algorithm helps protect
                        against
                        attacks like related-key attacks, where an attacker tries to exploit the relationship between
                        different subkeys. It also prevents weaknesses that could arise if the same key is reused in
                        every
                        round.</li>
                    <li><strong>Efficient Key Expansion:</strong> The key schedule must be efficient enough to generate
                        subkeys quickly without compromising security. In some algorithms like AES, the key schedule
                        includes both substitution and permutation steps to enhance security.</li>
                </ul>
                <p>
                    A well-designed key schedule algorithm ensures that the block cipher remains secure even if an
                    attacker
                    knows part of the plaintext or ciphertext. It adds an extra layer of protection by diversifying how
                    the
                    key is used in each round.
                </p>
            </div>
        </div>
        <div class="wh">
            <h2>Block Cipher Modes of Operation</h2>
            <p>
                Block cipher ek encryption technique hoti hai jo data ko fixed-size blocks (jaise 64 ya 128 bits) mein encrypt karti hai. Jab larger messages ko encrypt karna ho, toh block ciphers ko specific methods ki zarurat hoti hai jo ek block se zyada data ko handle kar sakein. In methods ko <strong>modes of operation</strong> kaha jata hai. Har mode yeh define karta hai ki blocks of plaintext ko kaise encrypt ya decrypt kiya jata hai, aur har mode ke apne strengths aur weaknesses hote hain, jo use case par depend karte hain.
            </p>
            <p>
                Sabse commonly used block cipher modes of operation hain:
            </p>
            <ol>
                <li>Electronic Codebook (ECB)</li>
                <li>Cipher Block Chaining (CBC)</li>
                <li>Cipher Feedback (CFB)</li>
                <li>Output Feedback (OFB)</li>
                <li>Counter Mode (CTR)</li>
            </ol>
        
            <div class="in">
                <h3>1. Electronic Codebook (ECB)</h3>
                <p>
                    <strong>Electronic Codebook (ECB)</strong> sabse simple mode hai jisme har plaintext block ko alag se encrypt kiya jata hai, aur har block ko same key se encrypt kiya jata hai.
                </p>
                <ul>
                    <li>Plaintext ko blocks mein divide kiya jata hai, aur har block ko alag se encrypt kiya jata hai using the block cipher. Har block ke liye wahi key use hoti hai, aur blocks ke beech koi link nahi hota.</li>
                </ul>
            </div>
        
            <div class="in">
                <h3>2. Cipher Block Chaining (CBC)</h3>
                <p>
                    <strong>Cipher Block Chaining (CBC)</strong> mode, ECB ko improve karta hai by introducing an initial random input called Initialization Vector (IV) aur har block ke encryption ko previous block ke saath link karte hai.
                </p>
                <ul>
                    <li>CBC mein, plaintext block ko XOR kiya jata hai previous ciphertext block ke saath pehle encryption karne se. Isse ensure hota hai ki har block ka encryption pehle wale block par depend kare, jo security badhata hai.</li>
                    <li>Pehla block, IV ke saath XOR hota hai taaki identical plaintext blocks identical ciphertext blocks na produce karen.</li>
                </ul>
            </div>
        
            <div class="in">
                <h3>3. Cipher Feedback (CFB)</h3>
                <p>
                    <strong>Cipher Feedback (CFB)</strong> mode block cipher ko stream cipher mein convert karta hai. Yeh chhote data units (jaise bits ya bytes) ko encrypt karne ki ability deta hai, blocks ke bajaye.
                </p>
                <ul>
                    <li>CFB kaam karta hai previous ciphertext block ko encrypt karte hue (ya first block ke liye IV ko encrypt karke) aur phir encrypted block ko plaintext ke saath XOR kiya jata hai. Isse agla ciphertext block milta hai.</li>
                    <li>Jaise CBC mein hota hai, CFB mein bhi IV ka use hota hai pehle block ke liye taaki security maintain ho sake, aur subsequent ciphertext blocks pehle wale block par depend karte hain.</li>
                </ul>
            </div>
        
            <div class="in">
                <h3>4. Output Feedback (OFB)</h3>
                <p>
                    <strong>Output Feedback (OFB)</strong> mode CFB ke similar hai, lekin ek key difference ke saath: OFB mein previous ciphertext block ko encrypt karne ki jagah, IV (ya uska output) ko continuously encrypt kiya jata hai taaki ek stream of key bits generate ho sake.
                </p>
                <ul>
                    <li>OFB mein, IV ko encrypt karte hain taaki ek keystream ban sake, jo phir plaintext ke saath XOR kiya jata hai taaki ciphertext produce ho. Yeh process har block ke liye continue hoti hai jab tak agla keystream output encrypt nahi ho jata.</li>
                    <li>Yeh mode effectively block cipher ko synchronous stream cipher mein convert kar deta hai.</li>
                </ul>
            </div>
        
            <div class="in">
                <h3>5. Counter Mode (CTR)</h3>
                <p>
                    <strong>Counter Mode (CTR)</strong> ek highly efficient mode hai jo block cipher ko stream cipher mein convert karta hai. Yeh mode parallel processing ke liye useful hai aur dusre modes ki comparison mein kaafi advantages provide karta hai.
                </p>
                <ul>
                    <li>CTR mein, counter value (har block ke liye unique number) ko encrypt kiya jata hai, aur phir result ko plaintext ke saath XOR kiya jata hai taaki ciphertext ban sake. Har block ke liye counter increment hota hai.</li>
                    <li>Counter yeh ensure karta hai ki har block alag key stream se encrypt ho, chahe plaintext blocks identical ho.</li>
                </ul>
            </div>
        </div>
        
        <div class="wh">
            <h2>Multiple DES</h2>
            <p>
                <strong>Multiple DES (Data Encryption Standard)</strong> ka matlab hai ki hum DES encryption ko ek se
                zyada baar apply karte hain taaki security ko badhaya ja sake. Jab standard DES me hum ek single 56-bit
                key ka use karte hain, tab Multiple DES me hum encryption process ko multiple times apply karte hain,
                lekin har baar alag key ka use karte hain. Is method ko introduce kiya gaya tha taaki single DES ke
                vulnerabilities ko door kiya ja sake.
            </p>
            <p>
                Ab, yeh samajhna zaroori hai ki DES encryption apne aap me ek purana aur kaafi simple encryption
                algorithm tha, jo time ke saath vulnerabilities ka shikar ho gaya. Matlab, agar ek attacker ke paas same
                key ho, toh woh encrypted data ko easily decrypt kar sakta tha. To is problem ko solve karne ke liye,
                humne Multiple DES ka concept introduce kiya jisme hum encryption process ko zyada secure banane ke liye
                repeat karte hain.
            </p>
            <p>
                Multiple DES ka use karne se security improve hoti hai, lekin itna simple bhi nahi hota ki koi bhi
                attacker easily decrypt kar sake. Isliye, Multiple DES ko do major variations me divide kiya gaya hai:
            </p>
            <ol>
                <li><strong>Double DES (2DES)</strong>: Isme DES ko do baar apply kiya jata hai. Matlab, ek data ko
                    pehle ek key se encrypt kiya jata hai aur phir dusri key se dobara encrypt kiya jata hai. Isse
                    security thodi better ho jati hai. Lekin, Double DES bhi kuch attacks ke liye vulnerable tha, jaise
                    meet-in-the-middle attack, jo iski security ko thoda compromise kar sakta hai.</li>
                <li><strong>Triple DES (3DES)</strong>: Yeh Double DES se bhi zyada secure hai. Isme data ko teen baar
                    encrypt kiya jata hai. Sabse pehle ek key se encrypt karte hain, phir dusri key se decrypt karte
                    hain (yeh decrypt kyunki hum encryption ka reverse bhi karte hain), aur phir third key se dobara
                    encrypt karte hain. Yeh process data ko kaafi secure bana deta hai aur isse 2DES ki comparison me
                    better protection milti hai.</li>
            </ol>
            <p>
                In short, Multiple DES ko introduce kiya gaya tha taaki hum DES ki security ko badha sake. Double DES
                aur Triple DES dono hi popular implementations hain, lekin Triple DES ko zyada secure maana jata hai,
                aur iski security level bhi kaafi high hai.
            </p>

            <div class="in">
                <h3>1. Double DES (2DES)</h3>
                <p>
                    <strong>Double DES</strong> mein hum DES encryption ko do baar apply karte hain, lekin har baar alag
                    keys use karte hain. Iska main goal yeh hai ki security ko improve kiya jaye aur DES ke original
                    56-bit key ko 112 bits tak badhaya jaye. Matlab, hum key ka length double kar dete hain taaki
                    encryption zyada secure ho sake.
                </p>
                <ul>
                    <li><strong>How It Works:</strong>
                        <ul>
                            <li>2DES mein pehle plaintext ko first key (K1) se encrypt kiya jata hai, aur jo ciphertext
                                milta hai usse fir second key (K2) se dubara encrypt karte hain. Matlab, ek hi data ko
                                do alag keys se encrypt karte hain taaki security increase ho sake.</li>
                            <li>Decryption ka process ulta hota hai: pehle hum K2 se decrypt karte hain, aur phir K1 se
                                decrypt karte hain. Is process ko reverse karne se hume original plaintext mil jata hai.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Double DES Process:</strong></li>
                    <img src="../../images/cry18.jpeg" alt="">
                    <li><strong>Advantages:</strong>
                        <ul>
                            <li>Yeh key length ko 56 bits se 112 bits tak badha deta hai, jo brute force attacks ke
                                against zyada resistant hota hai. Matlab, agar kisi attacker ko data ko crack karna ho
                                toh unhe kaafi zyada time lagta hai, kyunki key length badh gayi hai.</li>
                        </ul>
                    </li>
                    <li><strong>Disadvantages:</strong>
                        <ul>
                            <li>Double DES ab bhi kuch cryptographic attacks ke liye vulnerable hai, jaise
                                <strong>meet-in-the-middle attack</strong>, jo effectively key length ko 57 bits tak
                                reduce kar deta hai. Matlab, yeh attack security ko thoda compromise kar sakta hai, aur
                                isse Double DES utni secure nahi rehti jitni expected thi.
                            </li>
                            <li>Meet-in-the-middle attack ke wajah se, Double DES ka security improvement single DES ke
                                comparison mein utna significant nahi hota. Matlab, yeh attack key ko asani se reduce
                                kar sakta hai aur isse overall security ko weaken kar deta hai.</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>2. Triple DES (3DES)</h3>
                <p>
                    <strong>Triple DES</strong> (jo TDES ya 3DES ke naam se bhi jaana jaata hai) ko design kiya gaya tha
                    taaki security ko aur zyada enhance kiya ja sake. Isme hum DES ko teen baar apply karte hain, aur
                    har baar alag keys ya do keys ka use karte hain. Is process ke through hum ek bohot zyada strong
                    encryption method create karte hain jo Double DES se kaafi zyada secure hota hai.
                </p>
                <ul>
                    <li><strong>How It Works:</strong>
                        <ul>
                            <li>3DES mein pehle hum plaintext ko first key (K1) se encrypt karte hain, phir dusri key
                                (K2) se decrypt karte hain, aur phir teesri key (K3) se dobara encrypt karte hain. Yeh
                                triple application of DES process security ko kaafi enhance kar deta hai.</li>
                            <li>Agar hum do keys ka use kar rahe hain (matlab K1 = K3), toh bhi yeh process 3DES kehlata
                                hai, bas is case mein humare paas sirf do unique keys hote hain.</li>
                        </ul>
                    </li>
                    <li><strong>Triple DES Process:</strong></li>
                    <img src="../../images/cry19.jpeg" alt="">
                    <li><strong>Advantages:</strong>
                        <ul>
                            <li>3DES ka key length 168 bits tak badh jata hai, jo isse brute force attacks ke against
                                kaafi resistant bana deta hai. Matlab, agar koi attacker data ko crack karna chahe toh
                                unhe bohot zyada time lagta hai.</li>
                            <li>Teen stages of encryption aur decryption hone ki wajah se, security bhi kaafi stronger
                                ho jati hai. Matlab, yeh ek kaafi solid encryption method hai jo data ko bohot securely
                                encrypt karta hai.</li>
                        </ul>
                    </li>
                    <li><strong>Disadvantages:</strong>
                        <ul>
                            <li>3DES abhi bhi modern block ciphers jaise AES ke comparison mein thoda slow hai, kyunki
                                isme hum DES ko teen baar apply karte hain, jo time-consuming ho sakta hai.</li>
                            <li>Yeh kuch attacks ke liye still vulnerable hai, lekin 2DES ke comparison mein yeh kaafi
                                zyada secure hai.</li>
                        </ul>
                    </li>
                </ul>
            </div>

        </div>
        <div class="wh">
            <h2>Introduction to AES</h2>
            <p>
                <strong>Advanced Encryption Standard (AES)</strong> is a symmetric key encryption algorithm widely used
                to secure sensitive data. AES was introduced as a replacement for the Data Encryption Standard (DES),
                which became vulnerable to brute-force attacks due to its shorter key length. AES is known for its
                speed, security, and efficiency, making it the preferred standard for modern encryption.
            </p>

            <div class="in">
                <h3>Why AES Replaced DES</h3>
                <p>
                    DES, with its 56-bit key length, was susceptible to brute-force attacks. As computational power
                    increased, breaking DES became more feasible. To address these vulnerabilities, the National
                    Institute
                    of Standards and Technology (NIST) initiated a search for a stronger encryption algorithm. In 2001,
                    NIST
                    selected AES, which uses longer key lengths and is much harder to break than DES.
                </p>
            </div>

            <div class="in">
                <h3>AES Key Features</h3>
                <ul>
                    <li><strong>Key Length:</strong> AES supports key sizes of 128, 192, or 256 bits, offering stronger
                        security than DESâ€™s 56-bit key.</li>
                    <li><strong>Block Size:</strong> AES encrypts data in blocks of 128 bits, unlike DES, which uses
                        64-bit
                        blocks.</li>
                    <li><strong>Speed and Efficiency:</strong> AES is much faster than DES, especially on modern
                        hardware,
                        as it is designed for both software and hardware efficiency.</li>
                    <li><strong>Security:</strong> AES provides excellent security against all known cryptographic
                        attacks,
                        making it highly reliable for securing sensitive data.</li>
                </ul>
            </div>

            <div class="in">
                <h3>How AES Works</h3>
                <p>
                    AES is a block cipher that operates on fixed-size blocks of data (128 bits) and applies several
                    rounds
                    of encryption to transform the plaintext into ciphertext. The number of rounds depends on the key
                    length:
                </p>
                <ul>
                    <li>10 rounds for 128-bit keys</li>
                    <li>12 rounds for 192-bit keys</li>
                    <li>14 rounds for 256-bit keys</li>
                </ul>

                <h4>Main Steps of AES Encryption</h4>
                <ul>
                    <li><strong>1. Key Expansion:</strong> The original key is expanded into multiple round keys, one
                        for
                        each round of encryption.</li>
                    <li><strong>2. Initial Round (AddRoundKey):</strong> The initial key is XORed with the plaintext
                        block.
                    </li>
                    <li><strong>3. Rounds:</strong> Each round involves the following steps:
                        <ol>
                            <li><strong>SubBytes:</strong> A non-linear substitution step where each byte of the block
                                is
                                replaced using a substitution table (S-box).</li>
                            <li><strong>ShiftRows:</strong> The rows of the block are shifted cyclically to the left,
                                increasing diffusion.</li>
                            <li><strong>MixColumns:</strong> Columns of the block are mixed together using linear
                                algebra to
                                enhance security (not used in the final round).</li>
                            <li><strong>AddRoundKey:</strong> The current block is XORed with the round key generated
                                from
                                the original key.</li>
                        </ol>
                    </li>
                    <li><strong>4. Final Round:</strong> The last round omits the MixColumns step and consists of
                        SubBytes,
                        ShiftRows, and AddRoundKey operations.</li>
                </ul>
            </div>


            <div class="in">
                <h3>Security Strength of AES</h3>
                <p>
                    AES is highly secure due to its use of longer key lengths and more complex encryption rounds
                    compared to DES. Its strength lies in its resistance to various cryptographic attacks:
                </p>
                <ul>
                    <li><strong>Brute-Force Attacks:</strong> AESâ€™s key lengths (128, 192, and 256 bits) make
                        brute-force attacks impractical, even with modern computing power.</li>
                    <li><strong>Linear and Differential Cryptanalysis:</strong> AES is designed to resist both linear
                        and differential cryptanalysis, which are common methods for breaking symmetric ciphers.</li>
                    <li><strong>Side-Channel Attacks:</strong> While AES itself is secure, implementations of AES must
                        be protected against side-channel attacks, such as timing attacks and power analysis attacks.
                    </li>
                </ul>
            </div>
            <p>
                AES has become the global standard for symmetric key encryption due to its high security, efficiency,
                and flexibility. It is widely used in applications such as secure communications, data storage, and
                payment systems. Unlike DES, which had limitations due to its shorter key length and vulnerabilities to
                attacks, AES offers stronger encryption with more complex rounds, making it highly resistant to modern
                cryptographic threats.
            </p>

        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/watch?v=uVeChiA_yv0" target="_blank">Feistel Cipher Video Lecture
                    &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=QjSWXj4gKBw" target="_blank">DES Introduction, General
                    Structure, DES Function, DES Key Generation, DES Rounds video lecture &neArr;</a></li>
            <li><a href="https://chatgpt.com" target="_blank">ChatGPT - Guru &neArr;</a></li>
        </ul>
    </div>
    <script type="module" src="../../../../public/main.js"></script>
</body>

</html>
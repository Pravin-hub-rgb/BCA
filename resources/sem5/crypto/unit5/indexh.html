<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Function</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit4/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Hash Function</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Hash Function</h1>
        <p>Hash functions are fundamental building blocks in modern cryptography, playing a pivotal role in ensuring
            data security, integrity, and authentication across various digital systems. A hash function is a
            mathematical algorithm that takes an input, such as a message or file, and produces a fixed-length string of
            characters, known as a hash value or digest. This output is unique to the input data; even the slightest
            change in the input results in a completely different hash. This property makes hash functions essential for
            detecting unauthorized modifications to data, as any tampering becomes immediately apparent through a
            mismatch in hash values.</p>
        <p><strong>This topic is divided into several important areas for a deeper understanding:</strong></p>
        <ol>
            <li><strong>Message Authentication & Hash Functions:</strong> This section focuses on how hash functions are
                used to verify the authenticity and integrity of messages, ensuring that they come from a legitimate
                source and have not been altered in transit.
                <ul>
                    <li>Authentication Requirements: These outline the basic principles needed to establish trust in
                        communication systems. The primary goals include verifying the sender’s identity, ensuring the
                        message's content remains intact, and preventing unauthorized access or alterations.</li>
                    <li>Authentication Functions: These are specific techniques used to meet authentication
                        requirements. They often rely on cryptographic methods to ensure that the communication remains
                        secure and trustworthy.</li>
                    <li>Message Authentication Codes (MACs): A MAC is a cryptographic tool that combines a secret key
                        with the message to generate a code. This code ensures that both the sender and recipient can
                        verify the message’s authenticity and integrity, as only they possess the key required to
                        generate or verify the MAC.</li>
                    <li>Hash Functions: These are algorithms that provide a unique fingerprint for data. Hash functions
                        are widely used in systems where data integrity is critical, such as verifying file downloads,
                        securing passwords, and blockchain technology.</li>
                    <li>Security of Hash Functions and MACs: This subtopic addresses potential vulnerabilities in hash
                        functions and MACs, such as collision attacks (when two different inputs produce the same hash)
                        and key management issues. It also explores strategies to enhance their robustness against such
                        threats.</li>
                </ul>
            </li>
            <li><strong>Specific Hash Algorithms:</strong> Two widely recognized hash algorithms are discussed in
                detail:
                <ul>
                    <li>MD-5 (Message Digest Algorithm 5): This algorithm was once a popular choice for creating 128-bit
                        hash values. It played a significant role in the early days of cryptography by offering a fast
                        and efficient way to generate digests. However, its use has significantly declined due to
                        vulnerabilities, such as susceptibility to collision attacks, making it unsuitable for
                        high-security applications today.</li>
                    <li>Secure Hash Algorithm (SHA-512): A member of the Secure Hash Algorithm family, SHA-512 generates
                        a 512-bit hash value, offering a much higher level of security compared to older algorithms like
                        MD-5. It is widely adopted in modern cryptographic applications, including SSL/TLS certificates,
                        blockchain systems, and digital signatures, where robust data protection is critical.</li>
                </ul>
            </li>
            <li><strong>Digital Signatures: </strong>
                Digital signatures are advanced cryptographic tools used to verify the authenticity and integrity of
                messages or digital documents. They are the digital equivalent of handwritten signatures, providing a
                secure method for validating the identity of the sender and the originality of the data.
                <ul>
                    <li>Digital Signature Standard (DSS): This standard defines the framework for implementing secure
                        digital signature schemes, ensuring consistency and reliability across different systems. It
                        forms the basis for many digital signature protocols used today.</li>
                    <li>Authentication Protocol: This refers to the specific steps and procedures involved in using
                        digital signatures to validate the identity of a sender during communication. Authentication
                        protocols are critical in scenarios like secure email communication, online transactions, and
                        digital contract signing.</li>
                    <li>Digital Signature Algorithm (DSA): DSA is a widely used cryptographic algorithm for creating
                        digital signatures. It ensures that the signature is unique to the message and can be verified
                        by the recipient without compromising security. DSA plays a crucial role in maintaining trust in
                        digital interactions.</li>
                </ul>
            </li>
        </ol>
        <div class="wh">
            <h2>Message Authentication</h2>
            <ul>
                <li><strong>Message Authentication ka Matlab:</strong> Jab ek message receive hota hai, toh humein yeh
                    ensure karna hota hai ki yeh asli sender ne bheja hai aur beech mein message ke content ke saath koi
                    chedh-chaad nahi hui hai. Yaani, sender ki identity aur message ki integrity dono verify karni hoti
                    hai.</li>
                <li><strong>Ek Practical Scenario:</strong> Sochiye aap Organization XYZ ke ek employee hain aur aapko
                    Organization ABC se ek confidential message milta hai. Is situation mein aapko confirm karna hoga ki
                    yeh message ABC ke genuine person ne bheja hai aur transmission ke dauraan kisi third-party ne isse
                    modify nahi kiya.</li>
                <li><strong>Importance of Message Authentication:</strong> Sensitive information ko unauthorized access
                    aur tampering se bachane ke liye yeh bahut zaroori hai. Agar message authentication na ho, toh
                    attackers confidential data ko manipulate ya fake messages forward kar sakte hain, jo bahut bade
                    security risks create karta hai.</li>
                <li><strong>Authentication Kaise Hota Hai?</strong> Yeh ek authenticator ke zariye kiya jaata hai.
                    Authenticator basically ek code ya string hota hai jo message ke saath attach hota hai. Yeh
                    authenticator kuch bhi ho sakta hai, jaise:
                    <ul>
                        <li>Ek numerical code</li>
                        <li>Ek hash value</li>
                        <li>Ek alphabetic string</li>
                        <li>Ya ek alphanumeric code</li>
                    </ul>
                    Authenticator ka kaam hai message ki integrity aur sender ki authenticity ensure karna.
                </li>
                <li><strong>Authentication Functions:</strong> Yeh authenticators ek specific process ya function ke
                    zariye generate hote hain, jo message ko protect karte hain. In functions ka main goal hota hai data
                    integrity aur authenticity ko preserve karna. Teen primary authentication functions hote hain:
                    <ol>
                        <li>
                            <strong>Message Encryption:</strong>
                            Is technique mein pura message ko encrypt kiya jaata hai, taaki koi unauthorized person isse
                            samajh na sake. Encryption ensure karta hai ki message sirf intended receiver hi decode kar
                            sake. Yeh dono sender aur receiver ki identity ko bhi secure karta hai.
                        </li>
                        <li>
                            <strong>Message Authentication Code (MAC):</strong>
                            MAC ek special code hota hai jo message ke content ke saath attach hota hai. Receiver is
                            code ko verify karke confirm karta hai ki message tampered nahi hua hai. Yeh ek symmetric
                            key-based mechanism hota hai, yaani dono sender aur receiver ke paas ek shared secret key
                            hoti hai.
                        </li>
                        <li>
                            <strong>Hash Functions (H):</strong>
                            Hash function ek mathematical operation hai jo message ko ek fixed-size hash value mein
                            convert karta hai. Agar message mein ek bhi chhoti si change hoti hai, toh hash value
                            completely change ho jaati hai. Isse aap easily detect kar sakte hain ki message tampered
                            hua hai ya nahi. Yeh ek popular method hai kyunki yeh fast aur efficient hota hai.
                        </li>
                    </ol>
                </li>
            </ul>


            <div class="in">
                <h3>Message Encryption</h3>
                <ul>
                    <li>Encryption is the process of converting plaintext into ciphertext using an encryption algorithm
                        and a secret key.</li>
                    <li>In the context of message authentication, the encrypted message (ciphertext) serves as proof of
                        authenticity, as only the intended recipient (who has the decryption key) can read the message.
                    </li>
                    <li>This method ensures that even if the message is intercepted, an attacker cannot read it without
                        the decryption key, which can be used as an authenticator.</li>
                    <li>However, message encryption alone does not verify the source of the message, which is why
                        additional methods like MAC and hash functions are used for complete message authentication.
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Message Authentication Code (MAC)</h3>
                <ul>
                    <li>A Message Authentication Code (MAC) is a fixed-length code generated by an authentication
                        function, which takes the message and a secret key as inputs.</li>
                    <li>The MAC ensures both the integrity and authenticity of the message. If the message changes
                        during transmission, the MAC will not match when verified by the recipient.</li>
                    <li>The formula for a MAC is as follows: <code>C(MK) = MAC</code>, where:
                        <ul>
                            <li><strong>C</strong> represents the authentication function.</li>
                            <li><strong>M</strong> is the message being sent.</li>
                            <li><strong>K</strong> is the secret key shared between the sender and receiver.</li>
                            <li>The <strong>output (o/p)</strong> is the MAC code, which acts as a "signature" for the
                                message.</li>
                        </ul>
                    </li>
                    <li>MACs are commonly used in various security protocols like SSL/TLS to verify the authenticity and
                        integrity of transmitted messages.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Hash Functions (H)</h3>
                <ul>
                    <li>Hash functions are similar to MACs but do not use a secret key. Instead, they take the message
                        and produce a fixed-length hash code.</li>
                    <li>The output of a hash function is typically referred to as the hash value or hash code.</li>
                    <li>The formula for a hash function is as follows: <code>H(M) = h</code>, where:
                        <ul>
                            <li><strong>H</strong> represents the hash function.</li>
                            <li><strong>M</strong> is the message being sent.</li>
                            <li><strong>h</strong> is the resulting hash code, a fixed-length string representing the
                                message.</li>
                        </ul>
                    </li>
                    <li>The hash code serves as a fingerprint for the message. Even a small change in the message will
                        result in a completely different hash code, making it easy to detect any tampering.</li>
                    <li>Hash functions are widely used in digital signatures, blockchain technologies, and various
                        security protocols to ensure data integrity.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Comparison of Authentication Functions</h3>
                <ul>
                    <li><strong>Message Encryption</strong> provides confidentiality but does not authenticate the
                        sender. It ensures that only the intended recipient can read the message.</li>
                    <li><strong>MAC</strong> offers both authenticity and integrity. It ensures that the message has not
                        been altered and that it was sent by the claimed sender, provided the secret key remains secure.
                    </li>
                    <li><strong>Hash Functions</strong> ensure message integrity by producing a unique hash value for a
                        given message. They cannot verify the sender's identity unless combined with digital signatures
                        or other forms of authentication.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Hash Algorithms</h2>
            <div class="in">
                <h2>MD-5 (Message Digest Algorithm 5)</h2>
                <ul>
                    <li>
                        MD5 ek widely used cryptographic hash function hai jo ek 128-bit (16-byte) hash value produce karta hai. Yeh primarily data integrity verify karne ke liye aur checksums generate karne ke liye use hota hai. Hash function ek mathematical process hai jo kisi input data (message, file, etc.) ko ek fixed-size output mein convert karta hai. MD5 ka output hamesha 128-bit hota hai, chahe input ka size kuch bhi ho.
                        <br><em>Example:</em> Agar aap "Hello" ko MD5 ke through pass karenge, toh aapko ek unique 32-character hexadecimal string milegi.
                    </li>
                    <li>
                        MD5 ko 1991 mein Ron Rivest ne develop kiya tha, aur yeh purane hash functions jaise MD4 ke comparison mein behtar aur fast tha. Fast hone ki wajah se, yeh un applications ke liye ideal hai jahan quick hashing ki zarurat hoti hai. Lekin, iska 128-bit message digest aaj ke standards ke comparison mein chhota ho sakta hai.
                    </li>
                    <li>
                        MD5 ka major use file integrity check karna aur data verify karna hai. Jab aap koi file download karte hain, toh aap uske saath MD5 checksum bhi dekh sakte hain, jo aapko yeh verify karne mein madad karta hai ki file mein koi tampering nahi hui hai. Agar file ko modify kiya jaye, toh checksum change ho jata hai, aur yeh tampering ko detect karne mein madad karta hai.
                    </li>
                    <li>
                        MD5 ab secure nahi mana jata, especially collision attacks ke against. Collision attack ek aisi situation hoti hai jahan do alag-alag inputs same hash produce karte hain. Yeh dangerous ho sakta hai kyunki attacker kisi fake data ko original data ke jaise bana sakta hai, jo MD5 hash ke basis par match karega. Isliye MD5 ko critical aur sensitive applications mein use nahi kiya jata.
                    </li>
                    <li>
                        Halanki MD5 abhi bhi kuch basic hashing tasks mein use hota hai, lekin security ke high standards ke liye yeh recommended nahi hai. Aaj bhi file integrity checks aur quick hashing tasks ke liye MD5 ka use hota hai, lekin secure encryption aur password storage mein iska use nahi hota.
                    </li>
                </ul>
                

                <div class="wh">
                    <h3>Working Steps:</h3>
                    <ol>
                        <li>
                            <strong>Padding the Message:</strong>  
                            Sabse pehle, message ko MD5 ke processing requirements ke hisaab se adjust kiya jata hai. Iska matlab hai ki message ki length ko 512 bits ka multiple banane ke liye extra bits (padding) add ki jati hain. Lekin, last ke 64 bits agle step ke liye reserve hote hain. Yeh ensure karta hai ki MD5 message ko sahi tarike se process kar sake.
                            <br><em>Example:</em> Agar aapka message 400 bits ka hai, toh extra padding add karke usse 512 bits ka banaya jayega.
                        </li>
                        <li>
                            <strong>Adding the Original Length:</strong>  
                            Padding ke baad, message ki original length (padding ke pehle ki) ko message ke end mein 64-bit binary format mein add kiya jata hai. Yeh MD5 ko actual input ki length ka record rakhne mein madad karta hai.
                            <br><em>Example:</em> Agar original message 400 bits ka tha, toh yeh value as 64-bit binary format ke roop mein add ki jayegi.
                        </li>
                        <li>
                            <strong>Breaking into 512-bit Blocks:</strong>  
                            Ab padded message (original length ke saath) ko 512-bit ke chunks mein tod diya jata hai. Har chunk ek block ke roop mein treat hota hai aur sequentially process hota hai.
                            <br><em>Example:</em> Agar message 1024 bits ka ban gaya hai, toh yeh 2 blocks mein divide hoga.
                        </li>
                        <li>
                            <strong>Setting Up Variables:</strong>  
                            MD5 kuch predefined variables (A, B, C, D) ka use karta hai jo intermediate results ko store karte hain. In variables ko ek specific initial value se shuru kiya jata hai, aur processing ke dauraan update kiya jata hai.  
                            <br><em>Tip:</em> Yeh variables basically mathematical calculations ke base points hain.
                        </li>
                        <li>
                            <strong>Processing Each Block:</strong>  
                            Har 512-bit block ko process karne ke liye yeh steps follow hote hain:  
                            <ul>
                                <li>Block ko 16 chhoti pieces (32 bits har ek) mein tod diya jata hai.</li>
                                <li>Phir block 4 rounds ki calculations se guzarata hai, jo data ko mix aur transform karte hain mathematical aur logical operations ke zariye.</li>
                                <li>Har block ke process hone ke baad, results ko A, B, C, aur D ke initial values mein add karke update kiya jata hai, taaki agle block ke liye ready ho.</li>
                            </ul>
                            <em>Example:</em> Har round data ko transform karke ek naye form mein le jata hai, jo hash ke final output mein contribute karta hai.
                        </li>
                        <li>
                            <strong>Producing the Final Hash:</strong>  
                            Jab saare blocks process ho jate hain, toh A, B, C, aur D ke final values ko combine karke ek 128-bit ka hash banaya jata hai. Is hash ko phir ek 32-character hexadecimal string ke form mein represent kiya jata hai.  
                            <br><strong>Key Takeaway:</strong> MD5 hash ek digital fingerprint ki tarah hota hai. Agar input mein chhoti si bhi change hoti hai, toh hash completely alag hoga. Is wajah se yeh verification ke liye secure aur unique hota hai.
                            <br><em>Example:</em> "hello" aur "Hello" ka MD5 hash completely different hoga.
                        </li>
                    </ol>
                </div>
                
                
                
            </div>
            <div class="in">
                <h3>SHA (Secure Hash Algorithm)</h3>
<ul>
    <li><strong>MD5 ka Modified Version:</strong> SHA, MD5 algorithm ka ek improved version hai, jo MD5 ke vulnerabilities ko address karne aur zyada security dene ke liye design kiya gaya hai. MD5 ke kuch weaknesses jaise collision attacks ko dhyan mein rakhte hue, SHA ko is tarah se develop kiya gaya hai ki woh zyada secure aur reliable ho. Jab MD5 ko collision attacks ke against safe nahi mana gaya, tab SHA ka use badh gaya tha.
    </li>
    <li><strong>Output Length:</strong> MD5 ke comparison mein, jo sirf 128-bit output deta hai, SHA 160-bit output produce karta hai. Iska matlab hai ki SHA ka hash aur zyada complex hota hai aur usse reverse-engineer karna mushkil hota hai. Zyada bits hone ki wajah se, sha256 (SHA ka ek version) aur sha512 jese aur secure variants bhi exist karte hain jo aur zyada bits produce karte hain, aur inka use highly sensitive data ke liye hota hai.
    </li>
</ul>

<div class="wh">
    <h3>Working Steps</h3>
    <ol>
        <li>
            <strong>Padding the Message:</strong>
            Padding ko message mein add kiya jaata hai taaki message ka length 512 ke multiple ban sake. Yeh "1" bit add karke start hota hai, phir enough "0" bits add kiye jaate hain taaki total length required multiple tak pahunch sake.
        </li>
        <li>
            <strong>Adding the Original Length:</strong>
            Original message ka length (jo padding ke pehle tha) ko 64-bit ke format mein message ke end mein add kiya jaata hai. Yeh ensure karta hai ki final message ka length bilkul 512 bits ke multiple ho.
        </li>
        <li>
            <strong>Dividing the Message into 512-bit Blocks:</strong>
            Padding ke baad message ko 512-bit blocks mein divide kar diya jaata hai. Har ek block ko separately process kiya jaata hai during hashing.
        </li>
        <li>
            <strong>Initializing Chaining Variables:</strong>
            SHA algorithm five 32-bit variables ka use karta hai (A, B, C, D, aur E), jo calculation ko track karte hain. Yeh variables specific starting values se initialize hote hain.
        </li>
        <li>
            <strong>Processing Each Block:</strong>
            Har 512-bit block ko process karne ke liye yeh steps follow kiye jaate hain:
            <ol>
                <li><strong>Copy Variables:</strong> A, B, C, D, aur E ki current values ko temporary variables (a, b, c, d, e) mein copy kiya jaata hai.</li>
                <li><strong>Divide into Words:</strong> Block ko 16 chhote 32-bit pieces (W₀ se W₁₅) mein divide kiya jaata hai. Phir aur zyada words (W₁₆ se W₇₉) generate kiye jaate hain initial words par operations kar ke.</li>
                <li><strong>Perform Four Rounds:</strong> Har block pe 4 rounds hoti hain, har round mein 20 steps hote hain. Har round mein different functions, constants aur variables modify kiye jaate hain:
                    <ul>
                        <li><strong>Round 1:</strong> Basic logical operations jaise AND, OR, NOT.</li>
                        <li><strong>Round 2:</strong> Complex operations jaise XOR perform kiye jaate hain.</li>
                        <li><strong>Round 3:</strong> Data ko aur mix karne ke liye transformations hoti hain.</li>
                        <li><strong>Round 4:</strong> Final operations jisse data achhe se mix ho jaata hai.</li>
                    </ul>
                </li>
                <li><strong>Update Variables:</strong> Jab block process ho jaata hai, temporary variables (a, b, c, d, e) ko original variables (A, B, C, D, E) mein add kar liya jaata hai, changes incorporate karte hue.</li>
            </ol>
        </li>
        <li>
            <strong>Final Output:</strong>
            Jab saare blocks process ho jaate hain, to A, B, C, D, aur E ke final values ko concatenate karke final 160-bit hash generate kiya jaata hai. Yeh hash typically 40-character hexadecimal string ke form mein represent hota hai, jo original message ka unique identifier ban jaata hai.
        </li>
    </ol>
</div>


            </div>
        </div>
        <div class="wh">
            <h2>Digital Signature</h2>
            <ul>
                <li><strong>Real-World Relevance:</strong> Many of us are familiar with the concept of digital
                    signatures, as we often use them in secure digital transactions, document signing, and
                    authentication processes.</li>
                <li><strong>Based on Asymmetric Key Cryptography:</strong> Digital signatures utilize asymmetric key
                    cryptography, involving a pair of keys: a private key (kept secret) and a public key (shared
                    publicly).</li>
                <li><strong>Encryption and Decryption:</strong>
                    <ul>
                        <li><strong>Encryption:</strong> The private key is used to sign the message, creating the
                            digital signature.</li>
                        <li><strong>Decryption:</strong> The public key is used to verify the signature and validate the
                            authenticity of the message.</li>
                    </ul>
                </li>
                <li><strong>Primary Uses:</strong> Digital signatures serve two main purposes:
                    <ul>
                        <li><strong>Authentication:</strong> Ensures the message is from the intended sender.</li>
                        <li><strong>Non-Repudiation:</strong> Prevents the sender from denying the authenticity of the
                            signed message.</li>
                    </ul>
                </li>
                <li><strong>Signature:</strong> Acts as proof of identity, verifying whether the message genuinely
                    originated from the claimed sender.</li>
            </ul>
            <div class="in">
                <h3>Working of Digital Signature</h3>
                <img src="../../images/cry26.jpeg" alt="Digital Signature Workflow">
                <ul>
                    <li><strong>Sender's End (Encryption):</strong>
                        <ol>
                            <li>The sender (User A) uses their <strong>private key</strong> to encrypt the message. This
                                private key is unique to the sender and remains confidential.</li>
                            <li>The message and private key are passed through a <strong>Digital Signature Generation
                                    Algorithm</strong>, which produces the digital signature.</li>
                            <li>The generated digital signature is then combined with the original message, creating a
                                package containing both.</li>
                            <li>This package (message + signature) is sent to the receiver (User B).</li>
                        </ol>
                    </li>
                    <li><strong>Receiver's End (Decryption):</strong>
                        <ol>
                            <li>The receiver uses the sender's <strong>public key</strong> to decrypt and verify the
                                digital signature.</li>
                            <li>The package (message + signature) is passed through a <strong>Digital Signature
                                    Verification Algorithm</strong>, along with the sender's public key.</li>
                            <li>The algorithm compares the received message with the digital signature to verify its
                                validity:
                                <ul>
                                    <li>If the message matches the signature: The algorithm outputs
                                        <strong>Valid</strong>, confirming the sender's authenticity and message
                                        integrity.
                                    </li>
                                    <li>If the message does not match the signature: The algorithm outputs <strong>Not
                                            Valid</strong>, indicating potential tampering or authenticity issues.</li>
                                </ul>
                            </li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Digital Signature Standard (DSS)</h3>
                <ul>
                    <li><strong>Definition:</strong> The Digital Signature Standard (DSS) is a Federal Information
                        Processing Standard (FIPS) specifying algorithms for digital signature generation and
                        verification, primarily for ensuring data authenticity and integrity.</li>
                    <li><strong>Established By:</strong> National Institute of Standards and Technology (NIST).</li>
                    <li><strong>First Published:</strong> 1994 as FIPS PUB 186.</li>
                    <li><strong>Purpose:</strong> Provides a secure method for digital signatures using public-key
                        cryptography to authenticate the origin and integrity of digital data.</li>
                </ul>
                <div class="wh">
                    <h3>Key Features of DSS</h3>
                    <ul>
                        <li><strong>Algorithm:</strong> DSS defines the Digital Signature Algorithm (DSA) as its core
                            mechanism for generating and verifying digital signatures.</li>
                        <li>Ensures signatures are unique for each document, preventing forgery.</li>
                        <li>Does not encrypt data, only authenticates and verifies its integrity.</li>
                        <li>Uses hash functions (e.g., SHA-1, SHA-256) to generate a message digest.</li>
                        <li>Works with public-key cryptography, involving a pair of private and public keys.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Working of DSS</h3>
                    <ol>
                        <li><strong>Key Generation:</strong>
                            <ul>
                                <li>Generate a private key (<em>x</em>) and compute the corresponding public key
                                    (<em>y</em>).</li>
                                <li>These keys are derived using the DSA algorithm parameters, including a prime number
                                    (<em>p</em>), a subprime (<em>q</em>), and a generator (<em>g</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Signature Generation:</strong>
                            <ul>
                                <li>Hash the message to produce a fixed-length message digest.</li>
                                <li>Generate a random integer (<em>k</em>) and calculate two values:
                                    <ul>
                                        <li><em>r</em> = (<em>g<sup>k</sup> mod p</em>) mod <em>q</em>.</li>
                                        <li><em>s</em> = (<em>k<sup>-1</sup> (H(m) + xr)) mod q</em>, where
                                            <em>H(m)</em> is the message hash.
                                        </li>
                                    </ul>
                                </li>
                                <li>The signature is the pair (<em>r</em>, <em>s</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Signature Verification:</strong>
                            <ul>
                                <li>Receiver uses the sender’s public key to verify the signature:
                                    <ul>
                                        <li>Calculate the hash of the received message.</li>
                                        <li>Compute:
                                            <ul>
                                                <li><em>w</em> = <em>s<sup>-1</sup> mod q</em>.</li>
                                                <li><em>u1</em> = (<em>H(m)w</em>) mod <em>q</em>, <em>u2</em> =
                                                    (<em>rw</em>) mod <em>q</em>.</li>
                                                <li><em>v</em> = (<em>g<sup>u1</sup> * y<sup>u2</sup> mod p</em>) mod
                                                    <em>q</em>.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>If <em>v</em> equals <em>r</em>, the signature is valid.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                </div>
                <div class="wh">
                    <h3>Advantages of DSS</h3>
                    <ul>
                        <li>Ensures data authenticity and integrity without encrypting the data.</li>
                        <li>Relies on well-established mathematical principles for security.</li>
                        <li>Efficient for signing and verifying large amounts of data.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Applications of DSS</h3>
                    <ul>
                        <li>Used in secure email systems (e.g., S/MIME, PGP).</li>
                        <li>Verifies authenticity in software distribution and updates.</li>
                        <li>Commonly used in Public Key Infrastructure (PKI) systems for certificates.</li>
                        <li>Ensures secure communications in blockchain and financial transactions.</li>
                    </ul>
                </div>

            </div>
            <div class="in">
                <h3>Authentication Protocol</h3>
                <ul>
                    <li><strong>Definition:</strong> A set of rules and processes used to verify the identity of
                        entities (users, systems, or devices) communicating in a network.</li>
                    <li><strong>Purpose:</strong> Ensures secure access and communication by confirming the legitimacy
                        of the participating entities.</li>
                    <li><strong>Key Features:</strong>
                        <ul>
                            <li>Prevents unauthorized access.</li>
                            <li>Guards against impersonation and replay attacks.</li>
                            <li>Maintains confidentiality and integrity of communication.</li>
                        </ul>
                    </li>
                </ul>
                <div class="wh">
                    <h3>Types of Authentication Protocols</h3>
                    <ul>
                        <li><strong>Password-Based:</strong>
                            <ul>
                                <li>Relies on shared passwords or passphrases.</li>
                                <li>Vulnerable to dictionary attacks and password theft.</li>
                            </ul>
                        </li>
                        <li><strong>Challenge-Response Protocol:</strong>
                            <ul>
                                <li>Uses a challenge (e.g., random number) and a secret key to verify identity.</li>
                                <li>Prevents replay attacks as each session has a unique challenge.</li>
                            </ul>
                        </li>
                        <li><strong>Token-Based:</strong>
                            <ul>
                                <li>Utilizes physical or digital tokens for authentication.</li>
                                <li>Examples: OTP (One-Time Password) tokens, smart cards.</li>
                            </ul>
                        </li>
                        <li><strong>Biometric-Based:</strong>
                            <ul>
                                <li>Involves unique biological traits (e.g., fingerprints, retina scans).</li>
                                <li>Provides strong security but can be costly to implement.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Examples of Authentication Protocols</h3>
                    <ul>
                        <li><strong>Kerberos:</strong> A network authentication protocol using secret-key cryptography
                            and a trusted third party for secure communication.</li>
                        <li><strong>OAuth:</strong> A protocol for token-based authentication in web applications,
                            allowing third-party access without sharing credentials.</li>
                        <li><strong>SSL/TLS Handshake:</strong> Verifies the server and optionally the client during
                            secure web connections.</li>
                        <li><strong>RADIUS:</strong> Centralized authentication and authorization protocol for network
                            access.</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Digital Signature Algorithm (DSA)</h3>
                <ul>
                    <li><strong>Definition:</strong> A Federal Information Processing Standard (FIPS) for digital
                        signatures, introduced by the National Institute of Standards and Technology (NIST) in 1991.
                    </li>
                    <li><strong>Purpose:</strong> Ensures data authenticity and integrity by providing a secure digital
                        signature mechanism.</li>
                    <li><strong>Based On:</strong> Public key cryptography and modular arithmetic, similar to the
                        discrete logarithm problem.</li>
                </ul>
                <div class="wh">
                    <h3>Key Features of DSA</h3>
                    <ul>
                        <li>Used exclusively for generating and verifying digital signatures, not for encrypting data.
                        </li>
                        <li>Generates a pair of keys: private key (used for signing) and public key (used for
                            verification).</li>
                        <li>Produces a unique signature for every message, even if the same private key is used.</li>
                        <li>Relies on mathematical properties to ensure security and prevent forgery.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Working of DSA</h3>
                    <ol>
                        <li><strong>Key Generation:</strong>
                            <ul>
                                <li>Choose a prime number <em>p</em> and a number <em>q</em> (a prime divisor of
                                    <em>p-1</em>).
                                </li>
                                <li>Generate a number <em>g</em>, a generator of the subgroup of <em>p</em>.</li>
                                <li>Generate private key <em>x</em> (random number less than <em>q</em>).</li>
                                <li>Compute public key <em>y</em> = <em>g^x mod p</em>.</li>
                            </ul>
                        </li>
                        <li><strong>Signing Process:</strong>
                            <ul>
                                <li>Generate a random integer <em>k</em> (less than <em>q</em>).</li>
                                <li>Compute <em>r</em> = (<em>g^k mod p</em>) mod <em>q</em>.</li>
                                <li>Compute <em>s</em> = (<em>k<sup>-1</sup>(H(m) + xr)) mod q</em>, where <em>H(m)</em>
                                    is the hash of the message.</li>
                                <li>The digital signature is the pair (<em>r, s</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Verification Process:</strong>
                            <ul>
                                <li>Receiver verifies the signature using the sender's public key (<em>y</em>).</li>
                                <li>Compute two values:
                                    <ul>
                                        <li><em>w</em> = <em>s<sup>-1</sup> mod q</em>.</li>
                                        <li><em>u1</em> = (<em>H(m)w</em>) mod <em>q</em>, <em>u2</em> = (<em>rw</em>)
                                            mod <em>q</em>.</li>
                                    </ul>
                                </li>
                                <li>Compute <em>v</em> = (<em>g^u1 * y^u2 mod p</em>) mod <em>q</em>.</li>
                                <li>If <em>v</em> = <em>r</em>, the signature is valid; otherwise, it is invalid.</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                <div class="wh">
                    <h3>Advantages of DSA</h3>
                    <ul>
                        <li>Provides high security and ensures message integrity.</li>
                        <li>Efficient in signature generation and verification processes.</li>
                        <li>Widely used in applications requiring legal digital signatures (e.g., certificates).</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Applications of DSA</h3>
                    <ul>
                        <li>Used in secure email systems (e.g., PGP, S/MIME).</li>
                        <li>Implemented in digital certificates and Public Key Infrastructure (PKI).</li>
                        <li>Ensures authenticity in software distribution and updates.</li>
                        <li>Used in blockchain systems for transaction validation.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/watch?v=4lVaf-fCYdE" target="_blank">Message Authentication video
                    lecture &neArr;</a></li>
            <li><a href="https://youtu.be/7ZKwKVn4utw?si=mtkyZptk7XMrvDRl" target="_blank">MD-5 video lecture
                    &neArr;</a></li>
            <li><a href="https://youtu.be/YBZRHb1o8x0?si=WbUqAPT2XiuROMeN" target="_blank">SHA video lecture &neArr;</a>
            </li>
            <li><a href="https://youtu.be/xPRdrzo46HI?si=aLVPTDTFpyVhZ3fO" target="_blank">Digital Signature video
                    lecture &neArr;</a></li>
        </ul>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>
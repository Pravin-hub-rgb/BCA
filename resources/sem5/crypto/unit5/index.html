<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Function</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit4/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Hash Function</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Hash Function</h1>
        <p>Hash functions are fundamental building blocks in modern cryptography, playing a pivotal role in ensuring
            data security, integrity, and authentication across various digital systems. A hash function is a
            mathematical algorithm that takes an input, such as a message or file, and produces a fixed-length string of
            characters, known as a hash value or digest. This output is unique to the input data; even the slightest
            change in the input results in a completely different hash. This property makes hash functions essential for
            detecting unauthorized modifications to data, as any tampering becomes immediately apparent through a
            mismatch in hash values.</p>
        <p><strong>This topic is divided into several important areas for a deeper understanding:</strong></p>
        <ol>
            <li><strong>Message Authentication & Hash Functions:</strong> This section focuses on how hash functions are
                used to verify the authenticity and integrity of messages, ensuring that they come from a legitimate
                source and have not been altered in transit.
                <ul>
                    <li>Authentication Requirements: These outline the basic principles needed to establish trust in
                        communication systems. The primary goals include verifying the sender’s identity, ensuring the
                        message's content remains intact, and preventing unauthorized access or alterations.</li>
                    <li>Authentication Functions: These are specific techniques used to meet authentication
                        requirements. They often rely on cryptographic methods to ensure that the communication remains
                        secure and trustworthy.</li>
                    <li>Message Authentication Codes (MACs): A MAC is a cryptographic tool that combines a secret key
                        with the message to generate a code. This code ensures that both the sender and recipient can
                        verify the message’s authenticity and integrity, as only they possess the key required to
                        generate or verify the MAC.</li>
                    <li>Hash Functions: These are algorithms that provide a unique fingerprint for data. Hash functions
                        are widely used in systems where data integrity is critical, such as verifying file downloads,
                        securing passwords, and blockchain technology.</li>
                    <li>Security of Hash Functions and MACs: This subtopic addresses potential vulnerabilities in hash
                        functions and MACs, such as collision attacks (when two different inputs produce the same hash)
                        and key management issues. It also explores strategies to enhance their robustness against such
                        threats.</li>
                </ul>
            </li>
            <li><strong>Specific Hash Algorithms:</strong> Two widely recognized hash algorithms are discussed in
                detail:
                <ul>
                    <li>MD-5 (Message Digest Algorithm 5): This algorithm was once a popular choice for creating 128-bit
                        hash values. It played a significant role in the early days of cryptography by offering a fast
                        and efficient way to generate digests. However, its use has significantly declined due to
                        vulnerabilities, such as susceptibility to collision attacks, making it unsuitable for
                        high-security applications today.</li>
                    <li>Secure Hash Algorithm (SHA-512): A member of the Secure Hash Algorithm family, SHA-512 generates
                        a 512-bit hash value, offering a much higher level of security compared to older algorithms like
                        MD-5. It is widely adopted in modern cryptographic applications, including SSL/TLS certificates,
                        blockchain systems, and digital signatures, where robust data protection is critical.</li>
                </ul>
            </li>
            <li><strong>Digital Signatures: </strong>
                Digital signatures are advanced cryptographic tools used to verify the authenticity and integrity of
                messages or digital documents. They are the digital equivalent of handwritten signatures, providing a
                secure method for validating the identity of the sender and the originality of the data.
                <ul>
                    <li>Digital Signature Standard (DSS): This standard defines the framework for implementing secure
                        digital signature schemes, ensuring consistency and reliability across different systems. It
                        forms the basis for many digital signature protocols used today.</li>
                    <li>Authentication Protocol: This refers to the specific steps and procedures involved in using
                        digital signatures to validate the identity of a sender during communication. Authentication
                        protocols are critical in scenarios like secure email communication, online transactions, and
                        digital contract signing.</li>
                    <li>Digital Signature Algorithm (DSA): DSA is a widely used cryptographic algorithm for creating
                        digital signatures. It ensures that the signature is unique to the message and can be verified
                        by the recipient without compromising security. DSA plays a crucial role in maintaining trust in
                        digital interactions.</li>
                </ul>
            </li>
        </ol>
        <div class="wh">
            <h2>Message Authentication</h2>
            <ul>
                <li>Message authentication is the process of verifying the identity of the sender and ensuring the
                    integrity of the message.</li>
                <li>For example, if you work in Organization XYZ and receive a message from someone in Organization ABC,
                    you need to verify that the message actually came from that person in ABC and was not altered during
                    transmission.</li>
                <li>Message authentication is crucial for preventing unauthorized access or tampering of sensitive
                    information.</li>
                <li>How is this done? Through an authenticator, which can be a number, a hash code, an alphabetic
                    string, or an alphanumeric string.</li>
                <li>These authenticators are generated by an authentication function to ensure both message integrity
                    and sender authenticity.</li>
                <li>There are three main types of authentication functions:
                    <ol>
                        <li><strong>Message Encryption</strong></li>
                        <li><strong>Message Authentication Code (MAC)</strong></li>
                        <li><strong>Hash Functions (H)</strong></li>
                    </ol>
                </li>
            </ul>

            <div class="in">
                <h3>Message Encryption</h3>
                <ul>
                    <li>Encryption is the process of converting plaintext into ciphertext using an encryption algorithm
                        and a secret key.</li>
                    <li>In the context of message authentication, the encrypted message (ciphertext) serves as proof of
                        authenticity, as only the intended recipient (who has the decryption key) can read the message.
                    </li>
                    <li>This method ensures that even if the message is intercepted, an attacker cannot read it without
                        the decryption key, which can be used as an authenticator.</li>
                    <li>However, message encryption alone does not verify the source of the message, which is why
                        additional methods like MAC and hash functions are used for complete message authentication.
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Message Authentication Code (MAC)</h3>
                <ul>
                    <li>A Message Authentication Code (MAC) is a fixed-length code generated by an authentication
                        function, which takes the message and a secret key as inputs.</li>
                    <li>The MAC ensures both the integrity and authenticity of the message. If the message changes
                        during transmission, the MAC will not match when verified by the recipient.</li>
                    <li>The formula for a MAC is as follows: <code>C(MK) = MAC</code>, where:
                        <ul>
                            <li><strong>C</strong> represents the authentication function.</li>
                            <li><strong>M</strong> is the message being sent.</li>
                            <li><strong>K</strong> is the secret key shared between the sender and receiver.</li>
                            <li>The <strong>output (o/p)</strong> is the MAC code, which acts as a "signature" for the
                                message.</li>
                        </ul>
                    </li>
                    <li>MACs are commonly used in various security protocols like SSL/TLS to verify the authenticity and
                        integrity of transmitted messages.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Hash Functions (H)</h3>
                <ul>
                    <li>Hash functions are similar to MACs but do not use a secret key. Instead, they take the message
                        and produce a fixed-length hash code.</li>
                    <li>The output of a hash function is typically referred to as the hash value or hash code.</li>
                    <li>The formula for a hash function is as follows: <code>H(M) = h</code>, where:
                        <ul>
                            <li><strong>H</strong> represents the hash function.</li>
                            <li><strong>M</strong> is the message being sent.</li>
                            <li><strong>h</strong> is the resulting hash code, a fixed-length string representing the
                                message.</li>
                        </ul>
                    </li>
                    <li>The hash code serves as a fingerprint for the message. Even a small change in the message will
                        result in a completely different hash code, making it easy to detect any tampering.</li>
                    <li>Hash functions are widely used in digital signatures, blockchain technologies, and various
                        security protocols to ensure data integrity.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Comparison of Authentication Functions</h3>
                <ul>
                    <li><strong>Message Encryption</strong> provides confidentiality but does not authenticate the
                        sender. It ensures that only the intended recipient can read the message.</li>
                    <li><strong>MAC</strong> offers both authenticity and integrity. It ensures that the message has not
                        been altered and that it was sent by the claimed sender, provided the secret key remains secure.
                    </li>
                    <li><strong>Hash Functions</strong> ensure message integrity by producing a unique hash value for a
                        given message. They cannot verify the sender's identity unless combined with digital signatures
                        or other forms of authentication.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Hash Algorithms</h2>
            <div class="in">
                <h2>MD-5 (Message Digest Algorithm 5)</h2>
                <ul>
                    <li>
                        MD5 is a widely used cryptographic hash function that produces a 128-bit (16-byte) hash value.
                        It is
                        primarily used for verifying data integrity and generating checksums for data comparison.
                    </li>
                    <li>Developed by Ron Rivest in 1991 as an improvement over previous hash functions like MD4.</li>
                    <li>It is fast, making it ideal for applications requiring quick hashing, but it produces a 128-bit
                        message digest, which is relatively short by modern standards.</li>
                    <li>Although MD5 is still used in some contexts, it is no longer considered secure against collision
                        attacks due to vulnerabilities discovered over time. However, it is still widely used for file
                        integrity checks and basic hashing tasks.</li>
                </ul>
                <div class="wh">
                    <h3>Working Steps:</h3>
                    <ol>
                        <li>
                            <strong>Padding the Message:</strong>
                            The first step is to adjust the message length so it fits MD5’s requirements. Extra bits
                            (padding) are added to the message to make its total length a multiple of 512 bits (minus 64
                            bits reserved for the next step). This ensures MD5 can process the message properly.
                        </li>
                        <li>
                            <strong>Adding the Original Length:</strong>
                            Once padding is done, the original length of the message (before padding) is added at the
                            end in a 64-bit binary format. This helps MD5 keep track of the actual length of the
                            original input.
                        </li>
                        <li>
                            <strong>Breaking into 512-bit Blocks:</strong>
                            The padded message, along with the added length, is split into chunks of 512 bits. These
                            blocks are processed one by one.
                        </li>
                        <li>
                            <strong>Setting Up Variables:</strong>
                            MD5 uses four predefined variables (A, B, C, D) to store intermediate results. These
                            variables start with specific values and are updated during processing.
                        </li>
                        <li>
                            <strong>Processing Each Block:</strong>
                            Each 512-bit block goes through the following steps:
                            <ul>
                                <li>Split into 16 smaller pieces (32 bits each).</li>
                                <li>Processed in four rounds of calculations that mix and transform the data using
                                    mathematical and logical operations.</li>
                                <li>After processing, the results are added to the initial values of A, B, C, and D,
                                    updating them for the next block.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Producing the Final Hash:</strong>
                            After all blocks are processed, the final values of A, B, C, and D are combined to create a
                            128-bit hash. This hash is then represented as a 32-character hexadecimal string.
                            <br><strong>Key Takeaway:</strong> The MD5 hash is like a digital fingerprint of the input.
                            Even a tiny change in the input creates a completely different hash, making it unique and
                            secure for verification purposes.
                        </li>
                    </ol>
                </div>


            </div>
            <div class="in">
                <h3>SHA (Secure Hash Algorithm)</h3>
                <ul>
                    <li><strong>Modified Version of MD5:</strong> SHA is an improved version of the MD5 algorithm, designed to address MD5's vulnerabilities and provide more security. Considering some of MD5's weaknesses, such as collision attacks, SHA was developed to be more secure and reliable. When MD5 was considered unsafe against collision attacks, the use of SHA increased.</li>
<li><strong>Output Length:</strong> Compared to MD5, which produces only a 128-bit output, SHA produces a 160-bit output. This means that SHA's hash is more complex and harder to reverse-engineer. Due to the increased number of bits, more secure variants like sha256 (a version of SHA) and sha512 exist, which produce even more bits and are used for highly sensitive data.</li>
                </ul>

                <div class="wh">
                    <h3>Working Steps:</h3>
                    <ol>
                        <li>
                            <strong>Padding the Message:</strong>
                            Padding is added to the message so that its length is 64 bits less than a multiple of 512.
                            This is done by first adding a "1" bit, followed by enough "0" bits to reach the required
                            length.
                        </li>
                        <li>
                            <strong>Adding the Original Length:</strong>
                            The original length of the message (before padding) is added as a 64-bit value to the end of
                            the message. This ensures that the final message length is a perfect multiple of 512 bits.
                        </li>
                        <li>
                            <strong>Dividing the Message into 512-bit Blocks:</strong>
                            The padded message is split into 512-bit blocks. These blocks are processed one by one
                            during the hashing process.
                        </li>
                        <li>
                            <strong>Initializing Chaining Variables:</strong>
                            SHA uses five 32-bit variables (A, B, C, D, and E) to keep track of the calculation. These
                            variables are initialized with specific starting values.
                        </li>
                        <li>
                            <strong>Processing Each Block:</strong>
                            Each 512-bit block goes through these steps:
                            <ol>
                                <li><strong>Copy Variables:</strong> The current values of A, B, C, D, and E are copied
                                    into temporary variables (a, b, c, d, e).</li>
                                <li><strong>Divide into Words:</strong> The block is split into 16 smaller 32-bit pieces
                                    (W₀ to W₁₅). Then, more words (W₁₆ to W₇₉) are generated using operations on the
                                    initial words.</li>
                                <li><strong>Perform Four Rounds:</strong> There are four rounds of operations on the
                                    words, each consisting of 20 steps. Each round involves applying functions, adding
                                    constants, and modifying the variables:
                                    <ul>
                                        <li><strong>Round 1:</strong> Basic logical operations like AND, OR, and NOT.
                                        </li>
                                        <li><strong>Round 2:</strong> More complex operations, including XOR.</li>
                                        <li><strong>Round 3:</strong> Further transformations to mix the data.</li>
                                        <li><strong>Round 4:</strong> Final operations to ensure the data is well-mixed.
                                        </li>
                                    </ul>
                                </li>
                                <li><strong>Update Variables:</strong> After the block is processed, the temporary
                                    variables (a, b, c, d, e) are added back to the original variables (A, B, C, D, E),
                                    incorporating the changes.</li>
                            </ol>
                        </li>
                        <li>
                            <strong>Final Output:</strong>
                            After all the blocks have been processed, the final values of A, B, C, D, and E are
                            concatenated to produce the final 160-bit hash value. This hash is typically represented as
                            a 40-character hexadecimal string, which serves as a unique identifier for the original
                            message.
                        </li>
                    </ol>
                </div>


            </div>
        </div>
        <div class="wh">
            <h2>Digital Signature</h2>
<ul>
    <li><strong>Real-World Relevance:</strong> You’ve probably come across digital signatures in everyday life, especially when you're signing documents online, making secure transactions, or authenticating yourself for various services. They play an important role in ensuring that everything is secure and trustworthy in the digital world.</li>
    
    <li><strong>Based on Asymmetric Key Cryptography:</strong> Digital signatures are built on something called asymmetric key cryptography. This means they use two different keys: one private key, which you keep secret, and one public key, which is shared with others. The private key is used for signing messages, and the public key is used to check if the signature is valid.</li>
    
    <li><strong>Encryption and Decryption:</strong>
        <ul>
            <li><strong>Encryption:</strong> To create a digital signature, the private key is used to "sign" the message. Think of it like putting your signature on a paper document—this helps prove that the message came from you.</li>
            <li><strong>Decryption:</strong> On the other side, the public key is used to verify the digital signature. This step checks if the message was really signed by the private key holder and if it hasn’t been altered in any way.</li>
        </ul>
    </li>
    
    <li><strong>Primary Uses:</strong> Digital signatures are mainly used for two things:
        <ul>
            <li><strong>Authentication:</strong> It helps make sure that the message you’re receiving actually came from the person or entity it claims to be from. This ensures the sender’s identity is verified.</li>
            <li><strong>Non-Repudiation:</strong> Once a message is signed, the sender cannot deny having sent it. In other words, they can’t say later that they didn’t sign the message—this makes the process more trustworthy.</li>
        </ul>
    </li>
    
    <li><strong>Signature:</strong> A digital signature acts like proof of identity. It helps to confirm that the message really came from the person who is claimed to have sent it, just like how a handwritten signature works on paper to verify identity.</li>
</ul>

            <div class="in">
                <h3>Working of Digital Signature</h3>
                <img src="../../images/cry26.jpeg" alt="Digital Signature Workflow">
                <ul>
                    <li><strong>Sender's End (Encryption):</strong>
                        <ol>
                            <li>The sender (User A) uses their <strong>private key</strong> to encrypt the message. This
                                private key is unique to the sender and remains confidential.</li>
                            <li>The message and private key are passed through a <strong>Digital Signature Generation
                                    Algorithm</strong>, which produces the digital signature.</li>
                            <li>The generated digital signature is then combined with the original message, creating a
                                package containing both.</li>
                            <li>This package (message + signature) is sent to the receiver (User B).</li>
                        </ol>
                    </li>
                    <li><strong>Receiver's End (Decryption):</strong>
                        <ol>
                            <li>The receiver uses the sender's <strong>public key</strong> to decrypt and verify the
                                digital signature.</li>
                            <li>The package (message + signature) is passed through a <strong>Digital Signature
                                    Verification Algorithm</strong>, along with the sender's public key.</li>
                            <li>The algorithm compares the received message with the digital signature to verify its
                                validity:
                                <ul>
                                    <li>If the message matches the signature: The algorithm outputs
                                        <strong>Valid</strong>, confirming the sender's authenticity and message
                                        integrity.
                                    </li>
                                    <li>If the message does not match the signature: The algorithm outputs <strong>Not
                                            Valid</strong>, indicating potential tampering or authenticity issues.</li>
                                </ul>
                            </li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Digital Signature Standard (DSS)</h3>
                <ul>
                    <li><strong>Definition:</strong> The Digital Signature Standard (DSS) is a Federal Information
                        Processing Standard (FIPS) specifying algorithms for digital signature generation and
                        verification, primarily for ensuring data authenticity and integrity.</li>
                    <li><strong>Established By:</strong> National Institute of Standards and Technology (NIST).</li>
                    <li><strong>First Published:</strong> 1994 as FIPS PUB 186.</li>
                    <li><strong>Purpose:</strong> Provides a secure method for digital signatures using public-key
                        cryptography to authenticate the origin and integrity of digital data.</li>
                </ul>
                <div class="wh">
                    <h3>Key Features of DSS</h3>
                    <ul>
                        <li><strong>Algorithm:</strong> DSS defines the Digital Signature Algorithm (DSA) as its core
                            mechanism for generating and verifying digital signatures.</li>
                        <li>Ensures signatures are unique for each document, preventing forgery.</li>
                        <li>Does not encrypt data, only authenticates and verifies its integrity.</li>
                        <li>Uses hash functions (e.g., SHA-1, SHA-256) to generate a message digest.</li>
                        <li>Works with public-key cryptography, involving a pair of private and public keys.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Working of DSS</h3>
                    <ol>
                        <li><strong>Key Generation:</strong>
                            <ul>
                                <li>Generate a private key (<em>x</em>) and compute the corresponding public key
                                    (<em>y</em>).</li>
                                <li>These keys are derived using the DSA algorithm parameters, including a prime number
                                    (<em>p</em>), a subprime (<em>q</em>), and a generator (<em>g</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Signature Generation:</strong>
                            <ul>
                                <li>Hash the message to produce a fixed-length message digest.</li>
                                <li>Generate a random integer (<em>k</em>) and calculate two values:
                                    <ul>
                                        <li><em>r</em> = (<em>g<sup>k</sup> mod p</em>) mod <em>q</em>.</li>
                                        <li><em>s</em> = (<em>k<sup>-1</sup> (H(m) + xr)) mod q</em>, where
                                            <em>H(m)</em> is the message hash.
                                        </li>
                                    </ul>
                                </li>
                                <li>The signature is the pair (<em>r</em>, <em>s</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Signature Verification:</strong>
                            <ul>
                                <li>Receiver uses the sender’s public key to verify the signature:
                                    <ul>
                                        <li>Calculate the hash of the received message.</li>
                                        <li>Compute:
                                            <ul>
                                                <li><em>w</em> = <em>s<sup>-1</sup> mod q</em>.</li>
                                                <li><em>u1</em> = (<em>H(m)w</em>) mod <em>q</em>, <em>u2</em> =
                                                    (<em>rw</em>) mod <em>q</em>.</li>
                                                <li><em>v</em> = (<em>g<sup>u1</sup> * y<sup>u2</sup> mod p</em>) mod
                                                    <em>q</em>.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>If <em>v</em> equals <em>r</em>, the signature is valid.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                </div>
                <div class="wh">
                    <h3>Advantages of DSS</h3>
                    <ul>
                        <li>Ensures data authenticity and integrity without encrypting the data.</li>
                        <li>Relies on well-established mathematical principles for security.</li>
                        <li>Efficient for signing and verifying large amounts of data.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Applications of DSS</h3>
                    <ul>
                        <li>Used in secure email systems (e.g., S/MIME, PGP).</li>
                        <li>Verifies authenticity in software distribution and updates.</li>
                        <li>Commonly used in Public Key Infrastructure (PKI) systems for certificates.</li>
                        <li>Ensures secure communications in blockchain and financial transactions.</li>
                    </ul>
                </div>

            </div>
            <div class="in">
                <h3>Authentication Protocol</h3>
                <ul>
                    <li><strong>Definition:</strong> A set of rules and processes used to verify the identity of
                        entities (users, systems, or devices) communicating in a network.</li>
                    <li><strong>Purpose:</strong> Ensures secure access and communication by confirming the legitimacy
                        of the participating entities.</li>
                    <li><strong>Key Features:</strong>
                        <ul>
                            <li>Prevents unauthorized access.</li>
                            <li>Guards against impersonation and replay attacks.</li>
                            <li>Maintains confidentiality and integrity of communication.</li>
                        </ul>
                    </li>
                </ul>
                <div class="wh">
                    <h3>Types of Authentication Protocols</h3>
                    <ul>
                        <li><strong>Password-Based:</strong>
                            <ul>
                                <li>Relies on shared passwords or passphrases.</li>
                                <li>Vulnerable to dictionary attacks and password theft.</li>
                            </ul>
                        </li>
                        <li><strong>Challenge-Response Protocol:</strong>
                            <ul>
                                <li>Uses a challenge (e.g., random number) and a secret key to verify identity.</li>
                                <li>Prevents replay attacks as each session has a unique challenge.</li>
                            </ul>
                        </li>
                        <li><strong>Token-Based:</strong>
                            <ul>
                                <li>Utilizes physical or digital tokens for authentication.</li>
                                <li>Examples: OTP (One-Time Password) tokens, smart cards.</li>
                            </ul>
                        </li>
                        <li><strong>Biometric-Based:</strong>
                            <ul>
                                <li>Involves unique biological traits (e.g., fingerprints, retina scans).</li>
                                <li>Provides strong security but can be costly to implement.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Examples of Authentication Protocols</h3>
                    <ul>
                        <li><strong>Kerberos:</strong> A network authentication protocol using secret-key cryptography
                            and a trusted third party for secure communication.</li>
                        <li><strong>OAuth:</strong> A protocol for token-based authentication in web applications,
                            allowing third-party access without sharing credentials.</li>
                        <li><strong>SSL/TLS Handshake:</strong> Verifies the server and optionally the client during
                            secure web connections.</li>
                        <li><strong>RADIUS:</strong> Centralized authentication and authorization protocol for network
                            access.</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Digital Signature Algorithm (DSA)</h3>
                <ul>
                    <li><strong>Definition:</strong> A Federal Information Processing Standard (FIPS) for digital
                        signatures, introduced by the National Institute of Standards and Technology (NIST) in 1991.
                    </li>
                    <li><strong>Purpose:</strong> Ensures data authenticity and integrity by providing a secure digital
                        signature mechanism.</li>
                    <li><strong>Based On:</strong> Public key cryptography and modular arithmetic, similar to the
                        discrete logarithm problem.</li>
                </ul>
                <div class="wh">
                    <h3>Key Features of DSA</h3>
                    <ul>
                        <li>Used exclusively for generating and verifying digital signatures, not for encrypting data.
                        </li>
                        <li>Generates a pair of keys: private key (used for signing) and public key (used for
                            verification).</li>
                        <li>Produces a unique signature for every message, even if the same private key is used.</li>
                        <li>Relies on mathematical properties to ensure security and prevent forgery.</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Working of DSA</h3>
                    <ol>
                        <li><strong>Key Generation:</strong>
                            <ul>
                                <li>Choose a prime number <em>p</em> and a number <em>q</em> (a prime divisor of
                                    <em>p-1</em>).
                                </li>
                                <li>Generate a number <em>g</em>, a generator of the subgroup of <em>p</em>.</li>
                                <li>Generate private key <em>x</em> (random number less than <em>q</em>).</li>
                                <li>Compute public key <em>y</em> = <em>g^x mod p</em>.</li>
                            </ul>
                        </li>
                        <li><strong>Signing Process:</strong>
                            <ul>
                                <li>Generate a random integer <em>k</em> (less than <em>q</em>).</li>
                                <li>Compute <em>r</em> = (<em>g^k mod p</em>) mod <em>q</em>.</li>
                                <li>Compute <em>s</em> = (<em>k<sup>-1</sup>(H(m) + xr)) mod q</em>, where <em>H(m)</em>
                                    is the hash of the message.</li>
                                <li>The digital signature is the pair (<em>r, s</em>).</li>
                            </ul>
                        </li>
                        <li><strong>Verification Process:</strong>
                            <ul>
                                <li>Receiver verifies the signature using the sender's public key (<em>y</em>).</li>
                                <li>Compute two values:
                                    <ul>
                                        <li><em>w</em> = <em>s<sup>-1</sup> mod q</em>.</li>
                                        <li><em>u1</em> = (<em>H(m)w</em>) mod <em>q</em>, <em>u2</em> = (<em>rw</em>)
                                            mod <em>q</em>.</li>
                                    </ul>
                                </li>
                                <li>Compute <em>v</em> = (<em>g^u1 * y^u2 mod p</em>) mod <em>q</em>.</li>
                                <li>If <em>v</em> = <em>r</em>, the signature is valid; otherwise, it is invalid.</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                <div class="wh">
                    <h3>Advantages of DSA</h3>
                    <ul>
                        <li>Provides high security and ensures message integrity.</li>
                        <li>Efficient in signature generation and verification processes.</li>
                        <li>Widely used in applications requiring legal digital signatures (e.g., certificates).</li>
                    </ul>
                </div>
                <div class="wh">
                    <h3>Applications of DSA</h3>
                    <ul>
                        <li>Used in secure email systems (e.g., PGP, S/MIME).</li>
                        <li>Implemented in digital certificates and Public Key Infrastructure (PKI).</li>
                        <li>Ensures authenticity in software distribution and updates.</li>
                        <li>Used in blockchain systems for transaction validation.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/watch?v=4lVaf-fCYdE" target="_blank">Message Authentication video
                    lecture &neArr;</a></li>
            <li><a href="https://youtu.be/7ZKwKVn4utw?si=mtkyZptk7XMrvDRl" target="_blank">MD-5 video lecture
                    &neArr;</a></li>
            <li><a href="https://youtu.be/YBZRHb1o8x0?si=WbUqAPT2XiuROMeN" target="_blank">SHA video lecture &neArr;</a>
            </li>
            <li><a href="https://youtu.be/xPRdrzo46HI?si=aLVPTDTFpyVhZ3fO" target="_blank">Digital Signature video
                    lecture &neArr;</a></li>
        </ul>
    </div>
    <script type="module" src="../../../../public/main.js"></script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Public Key Encryption</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit5/index.html" class="link">Next Topic &rarr;</a>
                <a href="../unit3/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Public Key Encryption</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Public Key Encryption</h1>
        <p>Public Key Encryption, also known as Asymmetric Key Cryptography, is a foundational concept in modern
            cryptography that enables secure communication over insecure channels. Unlike Symmetric Key Cryptography,
            where the same key is used for both encryption and decryption, Public Key Encryption uses a pair of keys: a
            public key (used for encryption) and a private key (used for decryption). This revolutionary concept has
            made it possible for individuals and organizations to securely exchange sensitive information without the
            need for a pre-shared secret key, making it an essential tool for secure online transactions, email
            encryption, and digital signatures.</p>
        <p><strong>This topic is divided into several critical areas, each building upon the concept of public key
                encryption and its various applications:</strong></p>
        <ol>
            <li>Difference Between Symmetric and Asymmetric Key Cryptosystems: This section explores the fundamental
                differences between symmetric (or secret-key) cryptosystems and asymmetric (or public-key)
                cryptosystems. Symmetric systems use a single key for both encryption and decryption, which requires
                secure key exchange mechanisms. In contrast, asymmetric systems solve this problem by using two keys: a
                public key, which can be freely shared, and a private key, which remains confidential. Understanding
                these differences is crucial for grasping the strengths and limitations of each approach in real-world
                cryptographic applications.</li>
            <li>Public-Key Cryptography: The heart of the topic, public-key cryptography, encompasses the principles
                that underpin asymmetric encryption systems. Public-key systems rely on the mathematical properties of
                numbers and their operations to create secure systems. This section covers key cryptosystems used in
                real-world applications:
                <ul>
                    <li>Principles of Public-Key Cryptosystems: These are the core concepts that explain how asymmetric
                        encryption works, including how public and private keys interact, and the role of mathematical
                        functions in providing security.</li>
                    <li>RSA Algorithm: One of the most widely used public-key cryptosystems, RSA relies on the
                        difficulty of factoring large prime numbers. It is the basis for securing web traffic (e.g.,
                        SSL/TLS), digital signatures, and more.</li>
                    <li>Rabin Cryptosystem: A less well-known but important cryptosystem, Rabin's method is based on the
                        difficulty of extracting square roots modulo large primes, and its security parallels RSA in
                        some ways.</li>
                    <li>ElGamal Cryptosystem: Another key public-key cryptosystem, ElGamal is based on the
                        Diffie-Hellman key exchange and provides both encryption and digital signatures.</li>
                </ul>
            </li>
            <li>Key Management: Key management refers to the processes and techniques involved in creating,
                distributing, storing, and updating cryptographic keys in a secure manner. Proper key management is
                crucial for maintaining the security of a cryptographic system, as the security of encrypted data is
                only as strong as the protection of the keys used to encrypt it.</li>
            <li>Public Key Distribution: Public key distribution deals with the problem of securely sharing public keys
                across an insecure network. Even though the public key is not secret, it must be delivered in such a way
                that an attacker cannot substitute a fake key. Various methods, such as certificates issued by a trusted
                Certificate Authority (CA), are used to ensure that the recipient is truly receiving the intended public
                key.</li>
            <li>Mathematical Foundations: The security of public-key cryptosystems is deeply rooted in number theory,
                particularly in the use of certain mathematical theorems that make encryption difficult to break:
                <ul>
                    <li>Fermat’s Theorem: Fermat's Little Theorem provides the basis for many public-key algorithms,
                        such as RSA, by asserting properties of numbers in modular arithmetic, particularly in prime
                        number fields.</li>
                    <li>Euler’s Theorem: This theorem extends Fermat’s work and is used in algorithms like RSA for key
                        generation, ensuring that decryption works correctly by defining the relationship between the
                        totient of a number and modular exponentiation.</li>
                </ul>
            </li>
        </ol>
        <div class="wh">
            <h2>Difference Between Symmetric and Asymmetric Key Cryptosystems</h2>
            <ul>
                <li>We know that <strong>Cryptography</strong> is all about keeping information safe and secure. Suppose
                    you want to send a secret message to your friend without anyone else being able to read it. This is
                    where cryptosystems come in. A cryptosystem is basically a framework or a set of rules, tools, and
                    techniques used to protect information. It includes methods to encrypt (convert readable data into
                    an unreadable format) and decrypt (turn the unreadable format back into readable data) messages. At
                    the heart of every cryptosystem are keys, which act as the "special codes" that lock and unlock this
                    information.</li>
                <li>Now, there are two main types of cryptosystems based on how these keys are used: symmetric key
                    cryptosystems and asymmetric key cryptosystems. Both are like tools in a toolkit designed to solve
                    the same problem keeping data secure but they work in very different ways.</li>
                <li>A <strong>symmetric key cryptosystem</strong> is the simpler of the two. It’s like sharing the same
                    key to lock and unlock a box. Both you and your friend have the exact same key, which you use to
                    encrypt (lock) and decrypt (unlock) messages. This method is straightforward and fast, making it
                    ideal for situations where speed is critical, like encrypting files or databases. However, there’s a
                    catch: you need to ensure the key remains secret. If anyone else gets their hands on it, they can
                    read all the messages. Plus, securely sharing the key with someone else can be tricky, especially if
                    they’re far away.</li>
                <li>On the other hand, an <strong>asymmetric key cryptosystem</strong> is a bit more advanced. It uses
                    two keys: a public key and a private key. Think of it like a mailbox. The public key is like the
                    slot where anyone can drop letters (encrypt messages), but only you, with your private key, can open
                    the mailbox and read those letters (decrypt them). This makes it perfect for secure communication
                    over the internet, where you don’t have to worry about someone intercepting the key. Even if someone
                    knows your public key, they can’t use it to decrypt messages because they don’t have the matching
                    private key.</li>
                <li>So, in summary, cryptosystems are the backbone of secure communication. Symmetric systems are fast
                    and efficient but rely on keeping one key secret, while asymmetric systems are slower but far more
                    secure, especially for sharing information over untrusted networks. Each has its strengths, and they
                    are often used together to create a robust and secure system.</li>
            </ul>
            <img src="../../images/cry27.jpeg" alt="">
            <br>
            <img src="../../images/cry28.jpeg" alt="">
        </div>
        <div class="wh">
            <h2>Understanding the RSA Algorithm</h2>
            <p>The RSA algorithm is a cornerstone of modern cryptography. It’s widely used to ensure secure
                communication, especially over the internet. Named after its inventors—Ron Rivest, Adi Shamir, and
                Leonard Adleman—it is a method of asymmetric encryption. Unlike symmetric systems where one key is
                shared between the sender and receiver, RSA works with two keys: a public key and a private key. This
                separation of keys adds an extra layer of security and makes RSA one of the most trusted encryption
                methods in use today.</p>

            <div class="in">
                <h3>What is the RSA Algorithm?</h3>
                <ul>
                    <li>RSA is a cryptographic algorithm that uses the mathematical properties of prime numbers to
                        secure information.</li>
                    <li>It relies on two keys:
                        <ul>
                            <li><strong>Public Key:</strong> Used to encrypt messages and shared openly.</li>
                            <li><strong>Private Key:</strong> Used to decrypt messages and kept secret by the owner.
                            </li>
                        </ul>
                    </li>
                    <li>The security of RSA lies in the difficulty of prime factorization, making it extremely hard to
                        reverse-engineer the original primes used to generate the keys.</li>
                </ul>
            </div>

            <div class="in">
                <h3>How Does RSA Work?</h3>
                <p>To understand RSA, let’s break it into three main stages: <strong>Key Generation</strong>,
                    <strong>Encryption</strong>, and <strong>Decryption</strong>. Each stage involves some fascinating
                    mathematical principles that make RSA both secure and effective.
                </p>

                <h4>1. Key Generation</h4>
                <ul>
                    <li><strong>Step 1: Choose Two Large Prime Numbers</strong>
                        <ul>
                            <li>Select two large prime numbers \( p \) and \( q \). These primes should be random,
                                unique, and very large (hundreds of digits long for modern security).</li>
                            <li>Example: \( p = 61 \), \( q = 53 \).</li>
                        </ul>
                    </li>
                    <li><strong>Step 2: Compute \( n \)</strong>
                        <ul>
                            <li>Multiply \( p \) and \( q \) to get \( n \):
                                \[
                                n = p \times q
                                \]</li>
                            <li>\( n \) is a part of both the public and private keys. It defines the range of possible
                                values for encryption and decryption.</li>
                            <li>Example: \( n = 61 \times 53 = 3233 \).</li>
                        </ul>
                    </li>
                    <li><strong>Step 3: Compute \( \phi(n) \)</strong>
                        <ul>
                            <li>\( \phi(n) \), called Euler’s Totient Function, is calculated as:
                                \[
                                \phi(n) = (p - 1) \times (q - 1)
                                \]</li>
                            <li>Example: \( \phi(3233) = (61 - 1) \times (53 - 1) = 3120 \).</li>
                        </ul>
                    </li>
                    <li><strong>Step 4: Choose an Encryption Exponent (\( e \))</strong>
                        <ul>
                            <li>Select a number \( e \) that is relatively prime to \( \phi(n) \), meaning they share no
                                common factors other than 1.</li>
                            <li>Common choices for \( e \): 3, 17, or 65537.</li>
                            <li>Example: Let \( e = 17 \).</li>
                        </ul>
                    </li>
                    <li><strong>Step 5: Calculate the Decryption Exponent (\( d \))</strong>
                        <ul>
                            <li>Find \( d \), the modular multiplicative inverse of \( e \) modulo \( \phi(n) \),
                                satisfying:
                                \[
                                (d \times e) \mod \phi(n) = 1
                                \]</li>
                            <li>Example: \( d = 2753 \).</li>
                        </ul>
                    </li>
                    <li><strong>Final Output:</strong>
                        <ul>
                            <li>Public Key: \( (e, n) = (17, 3233) \).</li>
                            <li>Private Key: \( (d, n) = (2753, 3233) \).</li>
                        </ul>
                    </li>
                </ul>

                <h4>2. Encryption</h4>
                <ul>
                    <li>Represent the message \( M \) as a number smaller than \( n \). For example, \( A = 1, B = 2,
                        ..., Z = 26 \).</li>
                    <li>Encrypt \( M \) using the public key \( (e, n) \):
                        \[
                        C = M^e \mod n
                        \]</li>
                    <li>Example: Let \( M = 65 \). Encrypt:
                        \[
                        C = 65^{17} \mod 3233 = 2790
                        \]</li>
                    <li>The ciphertext \( C = 2790 \) is sent to the receiver.</li>
                </ul>

                <h4>3. Decryption</h4>
                <ul>
                    <li>Use the private key \( (d, n) \) to decrypt the ciphertext \( C \):
                        \[
                        M = C^d \mod n
                        \]</li>
                    <li>Example: Decrypt \( C = 2790 \):
                        \[
                        M = 2790^{2753} \mod 3233 = 65
                        \]</li>
                    <li>The receiver restores the original message \( M = 65 \).</li>
                </ul>
            </div>

            <div class="in">
                <h3>Strengths and Weaknesses of RSA</h3>
                <ul>
                    <li><strong>Strengths:</strong>
                        <ul>
                            <li>Provides strong security through its asymmetric key system.</li>
                            <li>Compatible with a wide range of systems and use cases.</li>
                            <li>Facilitates secure communication without prior key sharing.</li>
                        </ul>
                    </li>
                    <li><strong>Weaknesses:</strong>
                        <ul>
                            <li>Slower than symmetric encryption algorithms.</li>
                            <li>Requires larger key sizes (2048 bits or more) for adequate security.</li>
                            <li>Vulnerable to potential quantum computing advancements in the future.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Applications of RSA</h3>
                <ul>
                    <li>Secure Web Browsing: Used in SSL/TLS for HTTPS.</li>
                    <li>Email Encryption: Protects sensitive emails (e.g., PGP).</li>
                    <li>Digital Signatures: Verifies the authenticity of documents and software.</li>
                    <li>Key Exchange: Helps securely share symmetric keys.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Understanding the Rabin Cryptosystem</h2>
            <p>
                The Rabin Cryptosystem is another form of asymmetric encryption. It’s named after its inventor, Michael
                Rabin, who introduced it in 1979. Like the RSA algorithm, the Rabin Cryptosystem uses public and private
                keys to ensure secure communication, but the mathematical principles behind it are slightly different.
            </p>
            <p>
                The Rabin Cryptosystem is based on quadratic residues and the difficulty of factoring large numbers. Its
                security is grounded in the assumption that it is computationally hard to solve the quadratic
                residuosity problem, which is believed to be a difficult problem for computers to solve, similar to how
                RSA depends on the difficulty of factoring large integers.
            </p>
            <p>
                Let's break it down step by step so you can fully grasp how it works.
            </p>
            <div class="in">
                <h3>What is the Rabin Cryptosystem?</h3>
                <ul>
                    <li>The Rabin Cryptosystem is an asymmetric encryption algorithm that relies on the mathematical
                        concept of quadratic residues. In simple terms, quadratic residues are numbers that are the
                        result of squaring integers modulo some number.</li>
                    <li>The Rabin Cryptosystem works by exploiting the fact that, given a number \(y\), finding its
                        square root modulo a large prime number \(p\) is hard (this is the quadratic residuosity
                        problem).</li>
                    <li>The key idea behind Rabin’s system is that it uses modular arithmetic with prime numbers and is
                        somewhat similar to RSA in its key generation process, but it operates differently when it comes
                        to encryption and decryption.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Why is the Rabin Cryptosystem Important?</h3>
                <ul>
                    <li>Like RSA, the Rabin Cryptosystem enables secure communication over untrusted networks. However,
                        Rabin’s system has a more efficient encryption process because it uses a smaller number of
                        operations to encrypt messages, making it faster in some cases.</li>
                    <li>It’s also simpler than RSA in terms of its mathematical operations.</li>
                    <li>But, while RSA is widely used for general encryption purposes, the Rabin Cryptosystem has
                        limitations, especially with decryption ambiguity (which we will explain shortly). It’s less
                        commonly used in practice but is an important theoretical system in the study of cryptography.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>How Does the Rabin Cryptosystem Work?</h3>
                <ul>
                    <li><strong>Key Generation:</strong> The first step is generating the public and private keys. The
                        process goes like this:
                        <ul>
                            <li><strong>Step 1:</strong> Choose a large prime \( p \). Select a large prime number \( p
                                \). This number should be large enough (at least 512 bits) to ensure security. Example:
                                \( p = 3233 \).</li>
                            <li><strong>Step 2:</strong> Calculate the Public Key. The public key in Rabin’s system
                                consists of the prime number \( p \) that you’ve selected. The public key is simply \( p
                                \). Public Key: \( (p) \).</li>
                            <li><strong>Step 3:</strong> Compute the Private Key. The private key is computed by
                                selecting a number \( x \) that is the square root modulo \( p \). This \( x \) is kept
                                secret. To find \( x \), solve the equation \( x^2 \equiv m \pmod{p} \) for some message
                                \( m \), where \( m \) is a number between 0 and \( p-1 \). This step is mathematically
                                challenging, which is why this system works on the assumption that finding square roots
                                modulo a large prime is computationally difficult. Private Key: \( x \).</li>
                        </ul>
                    </li>
                    <li><strong>Encryption:</strong> Encryption in the Rabin Cryptosystem is done using the public key.
                        Here’s how encryption works:
                        <ul>
                            <li><strong>Step 1:</strong> Represent the Message. The message to be encrypted, \( m \), is
                                represented as a number. This number should be less than \( p \). Example: Suppose we
                                want to encrypt \( m = 123 \).</li>
                            <li><strong>Step 2:</strong> Compute the Ciphertext. The ciphertext \( C \) is computed as
                                the square of the message \( m \) modulo \( p \):
                                \[
                                C = m^2 \mod p
                                \]
                                Example: Suppose \( p = 3233 \) and \( m = 123 \), then the ciphertext is:
                                \[
                                C = 123^2 \mod 3233 = 15129 \mod 3233 = 2130
                                \]
                                The ciphertext \( C = 2130 \) is then sent to the receiver.</li>
                        </ul>
                    </li>
                    <li><strong>Decryption:</strong> Decryption is where things get interesting in the Rabin
                        Cryptosystem. Here’s the tricky part: while encryption is simple, decryption can result in
                        multiple possible messages because of the properties of squaring numbers.
                        <ul>
                            <li><strong>Step 1:</strong> Use the Private Key to Find the Square Root. The receiver,
                                using their private key, tries to compute the square roots of the ciphertext modulo \( p
                                \). Since squaring is a many-to-one function (i.e., multiple numbers can have the same
                                square modulo \( p \)), the decryption process might yield two possible values for the
                                original message. This ambiguity means there are two possible messages for each
                                ciphertext, which is a problem in certain situations.
                                Example: Suppose the ciphertext is \( C = 2130 \). The receiver calculates the square
                                roots of \( C \) modulo \( p \). This process may yield two values, say \( m_1 \) and \(
                                m_2 \), both of which could be potential original messages.</li>
                            <li><strong>Step 2:</strong> Handle the Ambiguity. In the Rabin Cryptosystem, decryption
                                typically results in two possible values for the original message. The receiver needs to
                                rely on other means (e.g., context, checksums, or error-correction codes) to figure out
                                which one is the correct message.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Why is the Rabin Cryptosystem Secure?</h3>
                <ul>
                    <li>The Rabin Cryptosystem’s security is based on the quadratic residuosity problem. Given a number
                        \( y \), it’s computationally hard to find an integer \( x \) such that:
                        \[
                        x^2 \equiv y \pmod{p}
                        \]
                        where \( p \) is a large prime number. This makes it extremely difficult for an attacker to
                        reverse the encryption without knowing the private key.</li>
                    <li>The strength of the Rabin Cryptosystem comes from the fact that solving quadratic equations
                        modulo large primes is computationally infeasible, especially as the size of \( p \) increases.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Strengths of the Rabin Cryptosystem</h3>
                <ul>
                    <li><strong>Efficiency:</strong> The encryption process is very fast because squaring a number
                        modulo a large prime is computationally efficient.</li>
                    <li><strong>Simplicity:</strong> The mathematical operations involved (square modulo a prime) are
                        relatively simple compared to more complex systems like RSA.</li>
                    <li><strong>Theoretical Significance:</strong> It provides an alternative to RSA based on a
                        different hard problem (quadratic residuosity).</li>
                </ul>
            </div>
            <div class="in">
                <h3>Weaknesses of the Rabin Cryptosystem</h3>
                <ul>
                    <li><strong>Decryption Ambiguity:</strong> The most significant issue is that decryption leads to
                        two possible plaintexts. This means that the system isn’t fully reliable for general encryption
                        unless additional measures are taken to handle this ambiguity.</li>
                    <li><strong>Limited Use:</strong> Due to the ambiguity in decryption, Rabin is less commonly used
                        than RSA. It’s mainly of interest in theoretical cryptography or in special cases where the
                        ambiguity can be managed.</li>
                    <li><strong>Key Size:</strong> Like RSA, Rabin requires large prime numbers for security, which
                        increases computational costs for key generation.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Applications of the Rabin Cryptosystem</h3>
                <ul>
                    <li><strong>Research in Cryptography:</strong> Though not widely used in practice, it’s an important
                        theoretical cryptosystem in the study of number-theoretic problems and public-key cryptography.
                    </li>
                    <li><strong>Hybrid Systems:</strong> Rabin could potentially be used in conjunction with other
                        cryptosystems for specialized tasks, where its decryption ambiguity can be mitigated.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>ElGamal Cryptosystem</h2>
            <ul>
                <li>The ElGamal Cryptosystem is an asymmetric encryption algorithm that was introduced by Taher ElGamal
                    in 1985. Like RSA and the Rabin Cryptosystem, ElGamal uses a pair of keys: a public key for
                    encryption and a private key for decryption. What sets ElGamal apart is its reliance on the
                    mathematical problem of discrete logarithms, which is a well-known mathematical problem believed to
                    be computationally hard.</li>
                <li>The ElGamal system is widely used in various cryptographic applications, especially in digital
                    signatures and public-key encryption. It is known for being probabilistic, which means it adds
                    randomness to the encryption process, making it more secure compared to deterministic systems like
                    RSA.</li>
                <li>At its core, the ElGamal Cryptosystem provides secure communication by using the principles of
                    public-key cryptography. It works by transforming a plaintext message into ciphertext in a way
                    that’s computationally difficult to reverse without knowing the private key.</li>
            </ul>
            <div class="in">
                <h3>Why is the ElGamal Cryptosystem Important?</h3>
                <ul>
                    <li>The ElGamal Cryptosystem is significant because it offers semantic security, which means that
                        even if an attacker intercepts the ciphertext, they cannot gain any meaningful information about
                        the original message without the private key.</li>
                    <li>What makes ElGamal important?
                        <ol>
                            <li>Security Foundation: The security of ElGamal is based on the discrete logarithm problem,
                                which is considered difficult to solve, making the system secure.</li>
                            <li>Versatility: ElGamal is used not only for encryption but also for creating digital
                                signatures. This means it can be employed in a wide range of cryptographic applications.
                            </li>
                            <li>Foundation for Other Systems: ElGamal has laid the groundwork for other cryptographic
                                protocols like the Digital Signature Algorithm (DSA), and is used in hybrid systems
                                combining asymmetric and symmetric encryption techniques.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>How Does the ElGamal Cryptosystem Work?</h3>
                <p>The ElGamal Cryptosystem consists of three main stages: Key Generation, Encryption, and Decryption.
                    Each of these stages uses modular arithmetic, and it relies on the difficulty of solving the
                    discrete logarithm problem. Let’s go through them in detail:</p>
                    <div class="in">
                        <h3>1. Key Generation</h3>
                        <p>The first step in the ElGamal Cryptosystem is generating the public and private keys. Here’s how the key generation process works:</p>
                        <ul>
                            <li><strong>Step 1: Choose a Large Prime \( p \)</strong>
                                <ul>
                                    <li>Select a large prime number \( p \), which will serve as the modulus for the system. The size of \( p \) determines the strength of the cryptosystem.</li>
                                    <li>Example: \( p = 353 \).</li>
                                </ul>
                            </li>
                            <li><strong>Step 2: Choose a Primitive Root \( g \) Modulo \( p \)</strong>
                                <ul>
                                    <li>Select a number \( g \) (called a generator or primitive root) that is a generator of the multiplicative group of integers modulo \( p \). This means that \( g \) has the property that its powers generate all the integers from 1 to \( p-1 \) when taken modulo \( p \).</li>
                                    <li>Example: If \( p = 353 \), then \( g = 3 \) might be a valid primitive root modulo \( p \).</li>
                                </ul>
                            </li>
                            <li><strong>Step 3: Choose a Secret Private Key \( x \)</strong>
                                <ul>
                                    <li>Select a private key \( x \), which is a secret random number. This key will be kept private by the user.</li>
                                    <li>Example: \( x = 123 \).</li>
                                </ul>
                            </li>
                            <li><strong>Step 4: Compute the Public Key</strong>
                                <ul>
                                    <li>Calculate the public key \( h \) using the formula:
                                        \[
                                        h = g^x \mod p
                                        \]
                                    </li>
                                    <li>The public key consists of the triplet \( (p, g, h) \), where \( p \) is the prime modulus, \( g \) is the primitive root, and \( h \) is the result of raising \( g \) to the power of the private key \( x \).</li>
                                    <li>Example:
                                        \[
                                        h = 3^{123} \mod 353 = 179
                                        \]
                                        Public Key: \( (p, g, h) = (353, 3, 179) \).<br>
                                        Private Key: \( x = 123 \).
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div class="in">
                        <h3>2. Encryption</h3>
                        <p>Once the public key is available, encryption can be done by anyone who wants to send a message securely. Here’s how encryption works:</p>
                        <ul>
                            <li><strong>Step 1: Represent the Message</strong>
                                <ul>
                                    <li>Convert the message \( m \) into a number \( m \) such that \( m \) is smaller than \( p \). This can be done by converting text to ASCII codes or using other encoding schemes.</li>
                                    <li>Example: Let’s say the message \( m = 42 \).</li>
                                </ul>
                            </li>
                            <li><strong>Step 2: Choose a Random Number \( y \)</strong>
                                <ul>
                                    <li>Select a random number \( y \) that is less than \( p-1 \). This random number adds probabilistic encryption, meaning it will make each encryption of the same message result in a different ciphertext.</li>
                                    <li>Example: \( y = 67 \).</li>
                                </ul>
                            </li>
                            <li><strong>Step 3: Compute the Ciphertext</strong>
                                <ul>
                                    <li>The ciphertext consists of two components, \( C_1 \) and \( C_2 \), which are computed as:
                                        \[
                                        C_1 = g^y \mod p
                                        \]
                                        \[
                                        C_2 = m \cdot h^y \mod p
                                        \]
                                    </li>
                                    <li>\( C_1 \) is the result of raising \( g \) to the power of the random number \( y \) modulo \( p \), and \( C_2 \) is the product of the message \( m \) and \( h^y \mod p \), where \( h \) is part of the public key.</li>
                                    <li>Example:
                                        \[
                                        C_1 = 3^{67} \mod 353 = 268
                                        \]
                                        \[
                                        C_2 = 42 \cdot 179^{67} \mod 353 = 144
                                        \]
                                        The ciphertext is then \( (C_1, C_2) = (268, 144) \), which is sent to the recipient.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div class="in">
                        <h3>3. Decryption</h3>
                        <p>Decryption in the ElGamal Cryptosystem is done by the receiver using their private key. Here’s how the decryption process works:</p>
                        <ul>
                            <li><strong>Step 1: Compute the Shared Secret</strong>
                                <ul>
                                    <li>The receiver uses their private key \( x \) and the received \( C_1 \) to compute a shared secret \( s \) as:
                                        \[
                                        s = C_1^x \mod p
                                        \]
                                    </li>
                                    <li>Example:
                                        \[
                                        s = 268^{123} \mod 353 = 179
                                        \]
                                        Notice that \( s \) is the same as \( h^y \mod p \) from the encryption step.
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Step 2: Compute the Inverse of \( s \)</strong>
                                <ul>
                                    <li>The receiver computes the modular inverse of \( s \) modulo \( p \), denoted \( s^{-1} \), which is used to recover the original message.</li>
                                    <li>Example:
                                        \[
                                        s^{-1} = 179^{-1} \mod 353 = 319
                                        \]
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Step 3: Recover the Original Message</strong>
                                <ul>
                                    <li>The original message \( m \) is recovered by multiplying \( C_2 \) with the inverse of \( s \):
                                        \[
                                        m = C_2 \cdot s^{-1} \mod p
                                        \]
                                    </li>
                                    <li>Example:
                                        \[
                                        m = 144 \cdot 319 \mod 353 = 42
                                        \]
                                        The original message \( m = 42 \) is successfully recovered.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
            </div>
            <div class="in">
                <h3>Why is the ElGamal Cryptosystem Secure?</h3>
                <ul>
                    <li>The security of ElGamal is based on the discrete logarithm problem. Given a large prime \( p \), a generator \( g \), and a number \( h = g^x \mod p \), it is computationally difficult to find the exponent \( x \) that satisfies this equation. This difficulty makes ElGamal resistant to attacks.</li>
                    <li>The probabilistic nature of ElGamal encryption means that even if an attacker intercepts multiple ciphertexts, they cannot easily deduce any information about the messages.</li>
                </ul>
            </div>
        </div>
    </div>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
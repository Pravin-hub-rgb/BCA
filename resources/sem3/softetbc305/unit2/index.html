<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Requirement Engineering</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <style>
        body {
            background: #0f0c29;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* Chrome 10-25, Safari 5.1-6 */
            background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
            color: white;
        }
    </style>
</head>

<body>
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#" class="link"></a>
        <div class="botbut">
            <a href="" class="link">Next Topic &rarr;</a>
            <a href="" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Software Requirement Engineering</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Software Requirement Engineering</h1>

        <p>
            <strong>Software Requirement Engineering (SRE)</strong> is a critical phase in the software development
            lifecycle that focuses on identifying, documenting, and managing the requirements of a software project. It
            is an essential discipline that lays the foundation for the entire software development process.
        </p>

        <p>
            <strong>Importance of Software Requirement Engineering:</strong><br>
            SRE is of paramount importance because it serves as the bridge between the needs and expectations of
            stakeholders (clients, users, and developers) and the final software product. It helps ensure that the
            resulting software system meets the intended purpose and satisfies user requirements.
        </p>

        <p>
            <strong>Key Objectives of Software Requirement Engineering:</strong><br>
            SRE has several key objectives, including:
        </p>
        <ul>
            <li>Understanding and documenting user needs, system functionality, and constraints.</li>
            <li>Creating clear and unambiguous software requirements specifications.</li>
            <li>Managing and prioritizing requirements effectively throughout the development lifecycle.</li>
            <li>Ensuring that requirements remain consistent and traceable as the project progresses.</li>
        </ul>

        <p>
            <strong>The Software Requirement Engineering Process:</strong><br>
            The SRE process typically encompasses the following stages:
        </p>
        <ul>
            <li><strong>Requirement Elicitation:</strong> Gathering requirements through interviews, surveys, workshops,
                and other techniques.</li>
            <li><strong>Requirement Analysis:</strong> Analyzing and refining gathered requirements for clarity,
                feasibility, and completeness.</li>
            <li><strong>Requirement Specification:</strong> Documenting requirements using structured documents,
                diagrams, and models.</li>
            <li><strong>Requirement Validation:</strong> Verifying that documented requirements align with stakeholder
                needs and expectations.</li>
            <li><strong>Requirement Management:</strong> Tracking changes, managing dependencies, and ensuring
                requirements traceability.</li>
        </ul>

        <p>
            Successful Software Requirement Engineering is a collaborative effort involving project stakeholders,
            business analysts, and development teams. It helps mitigate project risks, prevent scope creep, and ensure
            that the resulting software system aligns with business goals and user requirements.
        </p>
        <div class="wh">
            <h2>Requirement Elicitation</h2>

            <p>
                <strong>Requirement Elicitation</strong> is a vital phase in software development that focuses on
                identifying, gathering, and documenting requirements from clients and stakeholders. To understand this
                process fully, it's essential to first explore <strong>Requirement Engineering</strong>, a foundational
                step in the journey of software development.
            </p>
            <div class="in">
                <h3>1) Requirement Engineering</h3>
                <p>
                    <strong>Requirement Engineering</strong> is a crucial phase in software development that involves
                    collecting, analyzing, and documenting requirements from clients. It's a four-step process:
                </p>
                <ul>
                    <li>
                        <h3>1.1 Feasibility Study</h3>
                        <p>
                            In the <strong>Feasibility Study</strong> phase:
                        </p>
                        <ul>
                            <li>Analysts assess the initial feasibility of the desired software functions.</li>
                            <li>This involves a detailed study to determine if the system's functionality is feasible to
                                develop.</li>
                        </ul>
                    </li>

                    <li>
                        <h3>1.2 Requirement Gathering</h3>
                        <p>
                            If the feasibility report is positive:
                        </p>
                        <ul>
                            <li>The next phase is <strong>Requirement Gathering</strong>.</li>
                            <li>Analysts and engineers communicate with clients and end-users to understand the features
                                they want in the software.</li>
                        </ul>
                    </li>

                    <li>
                        <h3>1.3 Software Requirement Specification (SRS)</h3>
                        <p>
                            After collecting requirements:
                        </p>
                        <ul>
                            <li>An <strong>Software Requirement Specification (SRS)</strong> document is created.</li>
                            <li>It defines how the software interacts with hardware, interfaces, speed of operation,
                                response time, portability, security, quality, and limitations.</li>
                            <li>This transforms client requirements into technical language.</li>
                        </ul>
                    </li>

                    <li>
                        <h3>1.4 Software Requirement Validation</h3>
                        <p>
                            Once requirement specifications are developed:
                        </p>
                        <ul>
                            <li><strong>Software Requirement Validation</strong> takes place.</li>
                            <li>It ensures that requirements are valid and free from illegal or impractical solutions.
                            </li>
                            <li>This step helps prevent cost overruns and misinterpretations.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>2) Requirement Elicitation Process</h3>
                <p>
                    The Requirement Elicitation Process involves several key steps for effectively gathering and
                    managing
                    requirements:
                </p>
                <ul>
                    <li>
                        <h3>Requirements Gathering</h3>
                        <p>
                            <strong>Requirements Gathering</strong> is where developers:
                        </p>
                        <ul>
                            <li>Discuss expectations with clients and end-users to collect detailed requirements.</li>
                        </ul>
                    </li>

                    <li>
                        <h3>Organizing Requirements</h3>
                        <p>
                            Developers prioritize and arrange requirements:
                        </p>
                        <ul>
                            <li>Based on their importance, urgency, and convenience to maintain project focus.</li>
                        </ul>
                    </li>

                    <li>
                        <h3>Negotiation & Discussion</h3>
                        <p>
                            If there are ambiguities or conflicts in requirements:
                        </p>
                        <ul>
                            <li>They are <strong>negotiated and discussed</strong> with stakeholders to ensure clarity.
                            </li>
                        </ul>
                    </li>

                    <li>
                        <h3>Documentation</h3>
                        <p>
                            <strong>Documentation</strong> involves:
                        </p>
                        <ul>
                            <li>Recording all formal and informal, functional and non-functional requirements for future
                                reference and processing in the development lifecycle.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Requirement Elicitation Techniques</h2>

            <p>
                <strong>Requirement elicitation</strong> is the vital process of gathering and discovering the needs and
                expectations of stakeholders for a software system. It's like uncovering the puzzle pieces that will
                help build the right software. There are several techniques to accomplish this, each tailored to
                different situations and preferences:
            </p>

            <div class="in">
                <h3>Interviews</h3>
                <p>
                    <strong>Interviews</strong> are like friendly conversations with key people involved in the project.
                    They are a powerful way to collect requirements because they allow you to directly interact with
                    stakeholders. There are different types of interviews to choose from:
                </p>
                <ul>
                    <li><strong>Structured (closed) interviews:</strong> These interviews follow a predetermined set of
                        questions. They are like a checklist and ensure that specific information is collected.</li>
                    <li><strong>Non-structured (open) interviews:</strong> In these interviews, you don't have a fixed
                        script. You let the conversation flow, which can lead to unexpected insights and ideas.</li>
                    <li><strong>Oral interviews:</strong> These are spoken conversations where you discuss requirements
                        in person or over the phone.</li>
                    <li><strong>Written interviews:</strong> You provide a list of questions in writing, and
                        stakeholders respond in writing as well.</li>
                    <li><strong>One-to-one interviews:</strong> These are one-on-one conversations with individual
                        stakeholders, ensuring their unique needs are addressed.</li>
                    <li><strong>Group interviews:</strong> Multiple stakeholders are brought together for discussions.
                        It can be an efficient way to gather input from several people at once.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Surveys</h3>
                <p>
                    <strong>Surveys</strong> are like questionnaires sent out to a larger group of people. They are
                    useful
                    when you want to gather information from many stakeholders efficiently. You send out a set of
                    questions,
                    and people fill them out and return them.
                </p>
            </div>

            <div class="in">
                <h3>Questionnaires</h3>
                <p>
                    <strong>Questionnaires</strong> are a bit like surveys, but they typically involve multiple-choice
                    questions. Respondents select answers from predefined options, making it easier to analyze their
                    responses.
                </p>
            </div>

            <div class="in">
                <h3>Domain Analysis</h3>
                <p>
                    <strong>Domain Analysis</strong> is about seeking help from experts who understand the specific
                    field
                    related to the software. These experts have deep knowledge of the domain, and their insights can be
                    invaluable in identifying requirements that may not be obvious to others.
                </p>
            </div>

            <div class="in">
                <h3>Brainstorming</h3>
                <p>
                    <strong>Brainstorming</strong> is a creative session where various stakeholders come together for a
                    free-flowing discussion. It's like a brainstorming party for ideas! All inputs and ideas are
                    recorded,
                    and it's a great way to encourage creativity.
                </p>
            </div>

            <div class="in">
                <h3>Prototyping</h3>
                <p>
                    <strong>Prototyping</strong> involves creating a basic model of the software and showing it to users
                    and
                    analysts. Think of it as a sneak peek. By seeing and interacting with the prototype, stakeholders
                    can
                    provide feedback on what they like or need changed.
                </p>
            </div>

            <div class="in">
                <h3>Observation</h3>
                <p>
                    <strong>Observation</strong> is like being a detective. A team of experts visits the client's
                    workplace
                    to observe how their current systems work. They watch the flow of tasks, how problems are solved,
                    and
                    take notes. These observations help understand what the new software needs to address.
                </p>
            </div>
        </div>
        <div class="wh">
            <h2>Problem Analysis</h1>

                <p>Problem analysis is a crucial step in software development that aims to understand the needs of
                    clients
                    and users. Analysts take on the role of consultants, helping clients identify their requirements.
                    This
                    process involves breaking down complex problems into manageable subproblems and understanding their
                    relationships.</p>

                <p><b>Methods for Problem Analysis</b></p>
                <ol>
                    <li>Informal Approach</li>
                    <li>The Structured Analysis Method</li>
                    <li>Data dictionary</li>
                </ol>
                <div class="in">
                    <h3>Informal Approach (3.1)</h3>
                    <ul>
                        <li>The informal approach to problem analysis is flexible and doesn't rely on predefined
                            methodologies.</li>
                        <li>It involves direct interactions with clients, end-users, questionnaires, studying existing
                            documents, and brainstorming.</li>
                        <li>Analysts build a mental model of the problem and system, translating their understanding
                            into the Software Requirements Specification (SRS).</li>
                        <li>This often includes a series of meetings where clients explain their work, environment, and
                            needs, with the analyst acting as a listener and later as an explainer.</li>
                        <li>An initial draft of the SRS may be created in the final meetings.</li>
                    </ul>

                </div>
                <div class="in">
                    <h3>The Structured Analysis Method (3.2)</h3>
                    <ul>
                        <li>The structured analysis method views the system as a transformation function that takes
                            inputs from the environment and produces outputs.</li>
                        <li>For complex systems, this function is divided into sub-functions to improve
                            understanding.</li>
                        <li>Sub-functions can be further partitioned until each becomes easily understandable.</li>
                        <li>Data Flow Modeling and Data Flow Diagrams (DFDs) play a key role in this approach.</li>
                    </ul>
                </div>
                <div class="in">
                    <h3>Data FLow Modeling</h3>
                    <p>
                    <p>Data Flow Modeling is a structured analysis technique that focuses on function-based
                        decomposition of
                        a
                        problem. It helps in understanding how a system functions by showing the flow of data. In a DFD,
                        a
                        system is seen as a function that transforms inputs into outputs.</p>
                    </p>
                    <div class="wh">
                        <p><b>Data Flow Diagram (DFD)</b></p>
                        <p>Data Flow Diagrams (DFDs), also called data flow graphs, are used during problem analysis.
                            DFDs are
                            very
                            useful in understanding a system. They visually represent the flow of data in a system and
                            view it
                            as a
                            function that transforms inputs into outputs.</p>
                    </div>
                    <div class="wh">
                        <p><b>Components of DFD</b></p>
                        <p>
                            It consists of 4 symbols that represents: data flows, data stores, processes,
                            and sources/sinks (or external entities).
                            <br><img src="../../images/dfddiagram.svg" alt="" class="wb">
                        </p>
                        <ul>
                            <li><strong>Data Flow:</strong> Represents the movement of data in the system, shown with
                                arrows.
                                The
                                arrow's tail indicates the source, and the head is the destination.</li>
                            <li><strong>Data Store:</strong> Denotes data storage, often a database, shown as a
                                rectangle with
                                both
                                smaller sides missing.</li>
                            <li><strong>Process:</strong> Represents tasks performed on data and is depicted as a circle
                                (sometimes
                                as a rectangle).</li>
                            <li><strong>Source/Sink (Entities):</strong> The origin or destination of data; sometimes
                                referred
                                to as
                                external entities.</li>
                        </ul>
                    </div>
                    <div class="wh">
                        <h2>Rules for Creating DFD</h2>
                        <ul>
                            <li>The entity names should be clear and easily understandable without additional
                                explanations.</li>
                            <li>Processes should be numbered or listed in an ordered manner for easy reference.</li>
                            <li>DFDs should maintain consistency across all levels.</li>
                            <li>A single DFD can have a maximum of 9 and a minimum of 3 processes.</li>
                        </ul>
                    </div>
                </div>
        </div>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exception Handling & Multithread Programming</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Exceptions in Java</a>
        <a href="#t2" class="link">Exception Handling</a>
        <a href="#t3" class="link">Exception Hierarchy in Java</a>
        <a href="#t4" class="link">Try & Catch blocks</a>
        <a href="#t5" class="link">"throw" keyword</a>
        <a href="#t6" class="link">"throws" keyword</a>
        <a href="#t7" class="link">finally block</a>
        <a href="#t9" class="link">Multithreading in Java</a>
        <a href="#tpyq" class="link">Previous Year Questions</a>
        <div class="botbut">
            <a href="" class="link">Next Topic &rarr;</a>
            <a href="../unit1/index.html" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Exception Handling & Multithread Programming</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Exception Handling & Multithread Programming</h1>
        <div id="t1" class="wh">
            <h2>Exceptions in Java</h2>
            <p>
                In Java, exceptions are events that occur during the execution of a program that disrupt the normal flow
                of instructions. Exceptions can occur for various reasons, such as division by zero, trying to access an
                array element that doesn't exist, or attempting to open a file that doesn't exist.
                <br>
                In Java, exceptions are a vital concept used to manage and handle runtime errors gracefully. They play a
                crucial role in achieving the goal of a robust programming language. Let's delve deeper into the world
                of exceptions:
            </p>
            <ul>
                <li><strong>Runtime Error Management:</strong> Exceptions are primarily used to tackle runtime errors.
                    These errors can occur during program execution and might disrupt the normal flow of the
                    application.</li>
                <li><strong>Robust Language:</strong> Java's exception handling mechanism is one of the reasons it's
                    considered a robust language. It allows programs to continue running smoothly even in the presence
                    of errors.</li>
                <li><strong>Flow Control:</strong> Exception handling helps maintain the flow of a program. It ensures
                    that the program doesn't terminate abruptly when errors occur but instead gracefully handles them.
                </li>
                <li><strong>General Errors:</strong> In a broader sense, exceptions represent various types of runtime
                    errors, making it easier to identify and address issues.</li>
            </ul>
        </div>

        <div id="t2" class="wh">
            <h2>Exception Handling</h2>
            <p>
                Exception handling is a fundamental aspect of Java programming that empowers developers to deal with
                runtime errors systematically. Java provides built-in support for exception handling, making it easier
                to write robust and reliable code. Here's a closer look at exception handling in Java:
            </p>
            <ul>
                <li><strong>Automatic Handling:</strong> Java has a built-in mechanism for handling exceptions. When an
                    exception occurs, Java automatically looks for an appropriate handler to manage the situation.</li>
                <li><strong>Example:</strong> Consider this example where an attempt to divide by zero results in an
                    exception. Java's automatic handling ensures that the program doesn't crash but rather reports the
                    issue.</li>
            </ul>
            <pre>
                <code>
int x = 10; 
int ans = x / 0; // Automatically handled by Java
String s1 = null; // also an exception
                </code>
            </pre>
            <ul>
                <li><strong>Preventing Abnormal Termination:</strong> Exception handling prevents programs from
                    abnormally terminating due to runtime errors. This is especially crucial when creating software, as
                    unhandled exceptions can lead to unpredictable outcomes, including system crashes.</li>
                <li><strong>Essential OOP Feature:</strong> Exception handling is a fundamental feature of
                    object-oriented programming (OOP). It allows developers to encapsulate error-handling logic and
                    maintain clean and modular code.</li>
                <li><strong>Respective Handlers:</strong> In Java, exceptions are handled by methods or classes
                    specifically designed for that purpose. These handlers determine how different types of errors are
                    managed and what error messages to display.</li>
            </ul>
        </div>
        <div id="t3" class="wh">
            <h2>Exception Hierarchy in Java</h2>

            <p>In Java, exceptions are organized into a hierarchy of classes through inheritance. The
                <strong>java.lang.Throwable</stro> class serves as the root of this hierarchy.
            </p>
            <img src="../../images/exceptioninjava.svg" alt="" class="wb">
            <h3>Throwable (Root Class)</h3>
            <p>The <strong>Throwable</strong> class is the root class of the exception hierarchy in Java. It has two
                main
                subclasses:</p>

            <div class="in">
                <h3>Error</h3>
                <p><strong>Error</strong> represents serious, unrecoverable system-level errors, often caused by the JVM
                    or
                    underlying hardware. Developers usually don't handle these exceptions, and they typically lead to
                    program termination.</p>
                <ul>
                    <li><strong>StackOverflowError:</strong> Occurs when the call stack (method call history) exceeds
                        its
                        limit.</li>
                    <li><strong>OutOfMemoryError:</strong> Indicates that the JVM has exhausted available memory.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Exception</h3>
                <p><strong>Exception</strong> represents exceptions that can be caught and handled by application code.
                    <br>
                    In Java, exceptions are classified into two main categories: checked exceptions and unchecked
                    exceptions.
                    These distinctions help developers handle and manage exceptions effectively in their code.
                </p>
                <div class="wh">
                    <h3>Checked Exceptions</h3>
                    <ul>
                        <li><strong>Definition:</strong> Checked exceptions, also known as compile-time exceptions, are
                            exceptions that the Java compiler mandates to be caught or declared in the code. This means
                            that if
                            a method can potentially throw a checked exception, it must be either caught using a
                            try-catch block
                            or declared using the 'throws' keyword in the method signature.</li>
                        <li><strong>Examples:</strong> Common checked exceptions include 'IOException',
                            'FileNotFoundException',
                            and 'SQLException'. These exceptions typically occur in situations where external resources
                            or
                            external systems are involved, and the developer needs to handle potential issues
                            gracefully.</li>
                        <li><strong>Handling:</strong> Developers are required to handle checked exceptions explicitly
                            in their
                            code, either by using try-catch blocks to catch and process the exception or by declaring
                            the
                            exception using 'throws' in the method signature.</li>
                    </ul>

                    <h3>Unchecked Exceptions</h3>
                    <ul>
                        <li><strong>Definition:</strong> Unchecked exceptions, also known as runtime exceptions, are
                            exceptions
                            that do not require explicit handling using try-catch blocks or 'throws' declarations. These
                            exceptions can be caught and handled, but it's not mandatory by the compiler.</li>
                        <li><strong>Examples:</strong> Common unchecked exceptions include 'NullPointerException',
                            'ArrayIndexOutOfBoundsException', and 'ArithmeticException'. These exceptions usually result
                            from
                            programming errors or invalid operations and are not related to external factors.</li>
                        <li><strong>Handling:</strong> While unchecked exceptions can be caught and handled if desired,
                            developers are not required to do so. It is often recommended to address the root cause of
                            these
                            exceptions during development and not rely solely on catching them in code.</li>
                    </ul>

                    <p>Understanding the difference between checked and unchecked exceptions is crucial for effective
                        exception
                        handling in Java. Checked exceptions help ensure that developers handle potential issues that
                        may arise
                        when interacting with external resources, while unchecked exceptions primarily address
                        programming
                        errors and invalid operations.</p>
                </div>
            </div>

            <p>The <code>Throwable</code> class, along with its subclasses <code>Error</code> and
                <code>Exception</code>, forms the foundation of Java's exception handling system. Developers can create
                their custom exceptions by extending the <code>Exception</code> class or one of its subclasses.
            </p>

            <p>When handling exceptions in Java, it's essential to catch specific exceptions based on the situation,
                which allows for more precise error handling and recovery.</p>
        </div>

        <div id="t4" class="wh">
            <h2>Try & Catch Blocks in Exception Handling</h2>
            <p>
                Exception handling in Java involves several essential keywords, including try, catch, finally, throw,
                and throws. Let's dive into the details of how these keywords play a crucial role in managing
                exceptions:
            </p>
            <ul>
                <li><strong>Keywords Overview:</strong> Exception handling in Java is facilitated by specific keywords:
                    <ul>
                        <li>try</li>
                        <li>catch</li>
                        <li>finally</li>
                        <li>throw</li>
                        <li>throws</li>
                    </ul>
                    These keywords allow programmers to handle exceptions manually, providing more control over the
                    error-handling process.
                </li>
                <li><strong>Optionality of Keywords:</strong> Among these keywords, finally, throw, and throws are
                    optional. You can choose to use them based on the specific requirements of your code.
                    <ul>
                        <li>finally: This block contains code that executes regardless of whether an exception occurs.
                            It's often used for cleanup operations.</li>
                        <li>throw: It's used to explicitly throw an exception within your code when certain conditions
                            are met.</li>
                        <li>throws: This keyword is used in method declarations to indicate that the method may throw a
                            particular type of exception. It's particularly useful when defining custom exception
                            classes.</li>
                    </ul>
                </li>
                <li><strong>Levels of Exception Handling:</strong> Exception handling can be categorized into different
                    levels:
                    <ul>
                        <li><strong>Level 1:</strong> At this level, Java's default error-handling mechanisms come into
                            play. The JVM handles these exceptions without programmer intervention.</li>
                        <li><strong>Level 2:</strong> The try and catch blocks are used by programmers to handle
                            exceptions more specifically. It allows developers to define their own logic for dealing
                            with exceptions.</li>
                        <li><strong>Level 3:</strong> Finally, throw, and throws come into play at this level. The
                            finally block ensures essential cleanup code is executed, throw is used to explicitly raise
                            exceptions, and throws is employed for specifying potential exceptions that a method may
                            throw.</li>
                    </ul>
                </li>
                <li><strong>Effectiveness of Try, Catch, and Throws:</strong> In practice, approximately 90% of
                    exceptions are effectively handled using try, catch, and throws blocks. These mechanisms offer a
                    robust approach to exception management.</li>
                <li><strong>Best Practice:</strong> Handling exceptions with 'throws' is considered a best practice,
                    especially in situations where a programmer possesses in-depth knowledge of Java. It allows for more
                    precise and controlled exception handling, particularly when dealing with user-defined exceptions.
                </li>
                <li><strong>Usage of 'throws':</strong> The 'throws' keyword is primarily used for declaring
                    user-defined exceptions in method signatures. It indicates that a method may throw specific types of
                    exceptions, providing valuable information to other developers using the method.</li>
            </ul>
            <div class="in">
                <h3>Handling Exceptions by the User Using Try and Catch Blocks</h3>
                <p>Example &darr;</p>
                <pre>
                    <code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        
        ans = v1 / v2;
        System.out.println(ans);
    }
}
                    </code>
                </pre>
                <ul>
                    <li>In the above code, when we provide v2 = 0, we will get a 'DivideByZero' error, which is
                        correctly handled by Java.</li>
                    <li>As we can see, the program is correct, but when v2 = 0, the code after that won't get executed
                        because Java doesn't handle it, and that's why it gets terminated.</li>
                    <li>Now, if we want to handle it by the user, we will use the try-catch block.
                        <ul>
                            <li>Try block: Used for handling exceptions by the user. In the try block, we put the code
                                that might generate an exception. If an exception is generated by the try block, it
                                switches to the catch block, which is the exception handler.</li>
                        </ul>
                    </li>
                    <li>If we are not sure which part will give an exception, then put the whole code inside the try
                        block. Only the content that might generate an exception will be part of the try block, not any
                        method.</li>
                </ul>
                <pre><code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        try {
            Scanner sc = new Scanner(System.in);
            int v1, v2, ans;
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();
            ans = v1 / v2;
            System.out.println(ans);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        }
    }
}
                </code></pre>
                <ul>
                    <li>Remember, try without catch won't work.</li>
                    <li>If we want to find which line caused the error and get its name, we can do the following:</li>
                </ul>
                <pre><code>
catch (Exception e) {
    System.out.println("Error occurred at line: " + e.getStackTrace()[0].getLineNumber());
    System.out.println("Error message: " + e.getMessage());
}
// This provides full details about the error.
                </code></pre>

            </div>
            <div class="in">
                <h3>Try with Multiple Catch Blocks</h3>
                <ul>
                    <li>We can even put a try block inside another try block.</li>
                </ul>
                <pre>
                    <code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        try {
            ans = v1 / v2;
            System.out.println(ans);
        }
        catch (NumberFormatException e1) {
            System.out.println("Exception due to wrong input datatype");
        }
        catch (ArithmeticException e2) {
            System.out.println("Exception due to dividing by zero");
        }
        catch (Exception e) { // Default, if we don't exactly know what can be the exception.
            System.out.println("Error: " + e);
        }
    }
}
                    </code>
                </pre>

            </div>
            <div class="in">
                <h3>Multiple Try with Multiple Catch</h3>
                <p>Exception handling in Java is a critical aspect of ensuring that your programs can gracefully handle
                    unexpected situations. Java provides several mechanisms for handling exceptions, including:</p>
                <ul>
                    <li>Automatic handling by the Java Virtual Machine (JVM)</li>
                    <li>Using the <code>try/catch</code> block</li>
                    <li>Using <code>try</code> with multiple <code>catch</code> blocks</li>
                </ul>
                <p>Let's dive deeper into the concept of multiple <code>try</code> with multiple <code>catch</code>
                    blocks.</p>

                <h4>Objectives of Try and Catch Blocks:</h4>
                <p>When dealing with exceptions, <code>try</code> and <code>catch</code> blocks serve two main
                    objectives:</p>
                <ol>
                    <li>Provide user-defined error messages for better diagnostics.</li>
                    <li>Allow the continuation of code execution even in the presence of exceptions. This ensures that
                        other parts of the code can still run.</li>
                </ol>

                <p>There is no strict limitation on the number of <code>try</code> and <code>catch</code> blocks you can
                    use in your code. However, it's essential to consider code complexity as it may increase with a
                    higher number of exception-handling blocks.</p>

                <h4>Continuation of Program:</h4>
                <ul>
                    <li>Continuation of program flow is achieved using multiple <code>try</code> and <code>catch</code>
                        blocks.</li>
                    <li>This approach is particularly useful when you know the class names of the exceptions you expect
                        to handle.</li>
                    <li>Deciding how many <code>try</code> and <code>catch</code> blocks to use can be based on grouping
                        the code into logical sections. Here are three common groups:</li>
                    <ul>
                        <li>Input processing</li>
                        <li>Calculation</li>
                        <li>Display</li>
                    </ul>
                    <p>Both the input and calculation sections have a higher chance of encountering exceptions, so it's
                        beneficial to place separate <code>try</code> and <code>catch</code> blocks for each group.</p>
                </ul>

                <h4>Example:</h4>
                <pre>
        <code>
import java.util.Scanner;

class ExceptionHandlingExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 
        System.out.println("Enter two numbers: ");
        try { // input
            v1 = sc.nextInt();
            v2 = sc.nextInt();
        } catch (NumberFormatException e1) {
            System.out.println("Error due to wrong input");
        }

        try { // calculation
            ans = v1 / v2;
            System.out.println("Division Result: " + ans);
        } catch (ArithmeticException e2) {
            System.out.println("Error due to division by zero");
        }

        try { // independent calculation
            sub = v1 - v2;
            System.out.println("Subtraction Result: " + sub);
        } catch (ArithmeticException e3) {
            System.out.println("Error due to subtraction");
        }
    }
}
        </code>
    </pre>

                <ul>
                    <li>It's a good practice to declare all variables before the first <code>try</code> block to ensure
                        they have a broader scope.</li>
                    <li>If you don't know the specific exception class name, you can use the generic
                        <code>Exception</code> class to catch and handle exceptions.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Nested Try-Catch Blocks in Java</h3>
                <p>In Java, when dealing with complex situations that involve multiple layers of exception handling,
                    nested `try` and `catch` blocks can be employed. These blocks allow for a finer level of detail in
                    handling exceptions at different levels of your code.</p>

                <h4>Understanding Nested Try-Catch Blocks:</h4>
                <p>Nested `try` and `catch` blocks involve placing one or more `try` blocks inside another. This
                    approach is useful when certain operations within a `try` block can themselves trigger exceptions
                    that need to be handled separately.</p>

                <h4>Example:</h4>
                <pre>
                    <code>
try {
    // Outer try block
    // Perform some operations
    try {
        // Inner try block
        // Perform more specific operations
    } catch (SpecificException e) {
        // Handle the specific exception from the inner block
    }
    // Continue with operations
} catch (GeneralException e) {
    // Handle a more general exception from the outer block
}
                    </code>
                </pre>

                <p>In the example above, the outer `try` block handles more general exceptions, while the inner `try`
                    block handles exceptions specific to its operations. This way, you can provide specialized
                    error-handling for different parts of your code.</p>

                <h4>Nesting for Specificity:</h4>
                <p>The key benefit of nested `try` and `catch` blocks is the ability to address specific exceptions
                    without affecting the entire code block. It allows you to provide more specific error-handling
                    strategies at different levels of your code.</p>

                <h4>Caution:</h4>
                <p>While nesting can be powerful for precise error handling, it can also make your code more complex.
                    It's essential to strike a balance between specificity and code readability. Avoid excessive
                    nesting, which can lead to code that's challenging to maintain.</p>

                <h4>Best Practices:</h4>
                <ul>
                    <li>Use nested `try` and `catch` blocks when there's a genuine need to handle exceptions at
                        different levels with varying levels of detail.</li>
                    <li>Keep your code organized and maintainable by providing clear comments and documentation.</li>
                    <li>Avoid deeply nested blocks when possible; instead, break down your code into smaller, more
                        manageable functions or methods.</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <button class='ac'>Example program </button>
                    <div class='panel'>
                        <pre>
                            <code>
import java.util.Scanner;

public class NestedTryCatchExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 

        try {
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();

            try {
                ans = v1 / v2;
                System.out.println("Division Result: " + ans);
            } catch (ArithmeticException e2) {
                System.out.println("Error: Division by zero is not allowed.");
            }

            try {
                sub = v1 - v2;
                System.out.println("Subtraction Result: " + sub);
            } catch (ArithmeticException e3) {
                System.out.println("Error: Subtraction operation resulted in an error.");
            }
        } catch (java.util.InputMismatchException e1) {
            System.out.println("Error: Invalid input. Please enter valid numbers.");
        }
    }
}
                            </code>
                        </pre>
                    </div>
                </div>
            </div>
        </div>
        <div id="t5" class="wh">
            <h2>Understanding the "throw" Keyword in Java</h2>
            <ul>
                <li>In Java, the "throw" keyword is a mechanism used to create and raise custom exceptions during
                    program execution.</li>
                <li>User-Defined Exceptions (UDEs) are exceptions that programmers create to handle specific conditions
                    or situations within their code.</li>
                <li>While Java provides built-in exceptions for common error scenarios (e.g.,
                    ArrayIndexOutOfBoundsException or InputMismatchException), the "throw" keyword allows developers to
                    define and signal custom exceptions tailored to their application's requirements.</li>
                <li>For example, consider a situation where age verification is needed in a program. If a condition like
                    "age < 18" is met, the programmer can use the "throw" keyword to raise a custom exception,
                        specifying how this condition should be handled within the code.</li>
                <li>Similarly, if a program encounters an unexpected odd result that doesn't cause a runtime error but
                    needs special attention, the "throw" keyword can be employed to create a custom exception and define
                    how this unique situation should be managed.</li>
                <li>Essentially, the "throw" statement is used to communicate exceptional conditions or custom-defined
                    situations within the program, enabling developers to implement specific handling procedures for
                    these scenarios.</li>
            </ul>
            <div class="in">
                <h3>Handling the 'Divide by Zero' Exception Using the "throw" Keyword without Try-Catch Blocks</h3>
                <pre>
                    <code>
import java.util.*;

class Test
{
    public static void main(String[] args)
    {
        int ans = 0;
        int v1 = 10;
        int v2 = 0;
        if(v2 == 0)
        {
            throw new ArithmeticException("Division by zero is not allowed.");
            // Alternatively, you can create an ArithmeticException object and then throw it:
            // ArithmeticException obj = new ArithmeticException("Division by zero is not allowed.");
            // throw obj;
        }
        else 
        {
            ans = v1 / v2;
        }
        System.out.println(ans);
    }
}
                </code>
            </pre>
                <p>In the example above, we used the concept of anonymous objects.</p>
                <pre>
                    <code>
class A
{
    public void sum(int v1)
    {
        System.out.println(v1 + 10);
    }
}
public static void main(String[] args) 
{
    (new A()).sum(5);
    // This is similar to the following:
    // A obj = new A();
    // obj.sum(5);
}
                </code>
            </pre>
            </div>
            <div class="in">
                <h3>Throwing Our Own Custom Exception</h3>
                <p>Example: If a number is even, throw a custom exception.</p>
                <pre>
    <code>
class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            throw new MyException("Number is even.");
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
    </code>
</pre>
                <h3>Steps to Create and Throw Our Custom Exception</h3>
                <ol>
                    <li>Inherit from the "Exception" class to create our custom exception class.</li>
                    <li>Create a constructor for the custom exception class.</li>
                </ol>
                <pre>
                    <code>
// Step 1: Inheriting from Exception class to create our custom exception class
class MyException extends Exception
{
    // Step 2: Creating a constructor that takes a custom error message
    MyException(String str)
    {
        super(str);
    }
}

class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            MyException customException = new MyException("Number is even.");
            System.out.println(customException.getMessage());
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
                    </code>
                </pre>
                <ul>
                    <li>the getMessage method is a standard method provided by the Throwable class in Java, which is the
                        superclass of all exceptions, including custom exceptions. This method allows you to retrieve
                        the error message associated with an exception.
                        <br>we could also simply do the following &darr;
                    </li>
                </ul>
                <pre>
        <code>
System.out.println(customException);
        </code>
    </pre>

            </div>
            <div class="in">
                <h3>Understanding the 'super' Keyword in Java</h3>
                <p><strong>Definition of the 'super' Keyword:</strong></p>

                <p>In Java, the 'super' keyword is a special word used to refer to the <em>superclass</em> or the
                    <em>parent
                        class</em> of the current class. It helps you access members (like variables or methods) from
                    the
                    superclass, especially when there are similarly named members in both the superclass and the
                    subclass.
                    The 'super' keyword is primarily used to handle conflicts and interact with superclass members in an
                    inheritance hierarchy.
                </p>

                <p><strong>Simple Example for Beginners:</strong></p>

                <p>Let's illustrate the 'super' keyword with a straightforward example involving two classes: a
                    superclass
                    called <code>Animal</code> and a subclass called <code>Dog</code>. We'll show how 'super' can be
                    used to
                    access the constructor and method of the superclass.</p>

                <pre>
                <code>
<!-- Superclass -->
class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void sound() {
        System.out.println("Animal makes a sound");
    }
}

<!-- Subclass -->
class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        <!-- Using 'super' to call the superclass constructor -->
        super(name);
        this.breed = breed;
    }

    void sound() {
        <!-- Using 'super' to call the superclass method -->
        super.sound();
        System.out.println("Dog barks");
    }
}

<!-- Main Program -->
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Labrador");
        System.out.println("Name: " + myDog.name);
        System.out.println("Breed: " + myDog.breed);
        myDog.sound();
    }
}
            </code>
        </pre>

                <p>In this example, 'super' is used within the <code>Dog</code> constructor to call the constructor of
                    the
                    <code>Animal</code> superclass, passing the <code>name</code> parameter. It's also used within the
                    <code>sound</code> method of the <code>Dog</code> class to call the <code>sound</code> method of the
                    <code>Animal</code> class before adding specific behavior for the <code>Dog</code> class.
                </p>

                <p>When you run this program, it demonstrates how 'super' allows you to use and extend functionality
                    from
                    the superclass when creating subclasses, promoting code reusability and organization in
                    object-oriented
                    programming.</p>
            </div>
        </div>
        <div id="t6" class="wh">
            <h2>throws keyword</h2>
            <ul>
                <li><strong>Proper Definition:</strong> The 'throws' keyword is used to indicate exceptions that may
                    occur in a program. For example, we know that the 'public static void main()' function might throw
                    'ArrayIndexOutOfBoundsException' and 'NullPointerException'.</li>
                <li><strong>'throws' Usage:</strong> 'throws' is used along with a method when we are defining it.</li>
                <li><strong>Benefits:</strong> It makes our exception handling easier.</li>
                <li><strong>Usage with Any Method:</strong> It can be used with any method, including 'main'.</li>
                <li><strong>Usage in the Thread Class:</strong> It is also used in the 'Thread' class (we will learn
                    more about this later).
                    <br><code>Thread.sleep(1000);</code> might throw 'IOException'. If we use this, we will get an error
                    because Java gives warnings before many classes and suggests good exception handling practices. So,
                    only those who are familiar with exception handling should use these classes.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
    <code>
public void myMethod() throws ExceptionType1, ExceptionType2 
{
    // Method body
}
    </code>
</pre>
            <ul>
                <li><strong>Expertise and Diagnosis:</strong> If we do not specify all the exception classes, it
                    indicates that we may not be experts, and our error diagnosis skills may be weak.</li>
                <li><strong>Efficiency in Searching:</strong> Mentioning all the exception classes helps save time in
                    Java error handling.</li>
            </ul>
            <pre>
                <code>
public void myMethod() throws Exception // Parent class; mentioning this may consume more memory.
{
    // Method implementation
}
                </code>
            </pre>
            <ul>
                <li><strong>Throwing an Exception Outside the Method:</strong> The 'throws' clause is used to indicate
                    that a method may throw an exception.</li>
                <li><strong>'throws' Clause Usage:</strong> The 'throws' clause is used when declaring a method.</li>
            </ul>
            <div class="in">
                <h3>throw vs. throws</h3>
                <ol>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is used to explicitly throw an exception
                                object
                                within a method. This means that when a specific exceptional condition is encountered
                                within the
                                method, you can use 'throw' to create and throw an exception object, indicating that
                                something
                                has gone wrong.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() {
    throw new ArithmeticException();
}
                                    </code>
                                </pre>
                                In this example, we throw an 'ArithmeticException' explicitly, signaling that an
                                arithmetic
                                error has occurred.
                            </li>
                            <li><strong>throws:</strong> The 'throws' keyword, on the other hand, is used in a method's
                                signature to declare that the method may potentially throw one or more specific
                                exceptions. This
                                declaration allows the method to pass the responsibility of handling these exceptions to
                                its
                                caller. When a method is declared with 'throws,' it means that the method is warning the
                                caller
                                that it might encounter certain exceptions during execution, and the caller needs to
                                handle
                                them.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() throws ArithmeticException {
    // Method code
}
                                    </code>
                                </pre>
                                Here, 'throws' indicates that this method may throw an 'ArithmeticException,' and it's
                                the
                                caller's responsibility to handle it if necessary.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is always used inside the method body to
                                explicitly
                                throw an exception. It is typically used when an exceptional condition is detected
                                within the
                                method, and you want to trigger an exception immediately.
                            </li>
                            <li><strong>throws:</strong> In contrast, the 'throws' keyword is always used in the
                                method's
                                signature to declare exceptions that the method might propagate to the caller. It
                                doesn't create
                                or throw exception instances within the method but rather specifies the potential
                                exceptions the
                                method can raise.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> With 'throw,' you can throw only one exception at a time. Each
                                'throw'
                                statement is responsible for throwing a specific exception.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
throw new ArithmeticException();
                                    </code>
                                </pre>
                                This line throws an 'ArithmeticException.'
                            </li>
                            <li><strong>throws:</strong> With 'throws,' you can declare and handle multiple exceptions
                                simultaneously. This is especially useful when a method can potentially encounter
                                different
                                types of exceptions.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() throws ArithmeticException, ArrayIndexOutOfBoundsException {
    // Method code
}
                                    </code>
                                </pre>
                                Here, the 'throws' keyword declares that 'm1' may throw either an 'ArithmeticException'
                                or an
                                'ArrayIndexOutOfBoundsException.'
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is followed by an instance of an exception
                                class,
                                indicating that you are creating and throwing a specific exception object. This allows
                                you to
                                customize the exception with details about the error.
                            </li>
                            <li><strong>throws:</strong> In contrast, the 'throws' keyword is followed by the names of
                                exception
                                classes. It doesn't create or throw exception instances directly but rather informs the
                                caller
                                of the potential exceptions that may be thrown by the method. The caller is then
                                responsible for
                                handling these exceptions as needed.
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>
        <div id="t7" class="wh">
            <h2>finally Block</h2>
            <ul>
                <li><strong>Optional:</strong> The <code>finally</code> block is an optional part of Java's exception
                    handling mechanism.</li>
                <li><strong>Mandatory Execution:</strong> It contains code that needs to be executed regardless of
                    whether an exception was thrown or not. This makes it suitable for tasks like resource cleanup,
                    closing files, or releasing system resources.</li>
                <li><strong>Always a Part of Try and Catch Blocks:</strong> The <code>finally</code> block should always
                    be associated with a <code>try</code> and <code>catch</code> block. It ensures that the code within
                    the <code>finally</code> block is executed after the <code>try</code> block, and potentially the
                    <code>catch</code> block, no matter what happens in the preceding code.
                </li>
                <li><strong>Cannot Be Used Without Try and Catch:</strong> You cannot use the <code>finally</code> block
                    on its own; it must be used in conjunction with a <code>try</code> and <code>catch</code> block.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
                <code>
try {
    // Code that may throw exceptions
}
catch (Exception e) {
    // Exception handling code
}
finally {
    // Code that always executes, whether or not an exception was thrown
}
                </code>
            </pre>

        </div>
        <div class="wh">
            <h2>Programs</h2>
            <div class='code'>
                <div class='dotc'></div>
                <button class='ac'>Program to demonstrate the use of InputMismatchException & NumberFormatException.
                    (try and catch)</button>
                <div class='panel'>
                    <pre>
                        <code>
import java.util.InputMismatchException;
import java.util.Scanner;

class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num1 = 0;
        int num2 = 0;
        
        try {
            System.out.println("Enter first number: ");
            num1 = sc.nextInt();
            
            System.out.println("Enter second number: ");
            num2 = sc.nextInt();
        } catch (InputMismatchException e) {
            System.out.println("InputMismatchException: " + e.getMessage());
            // Clear the invalid input
            sc.next();
        }

        try {
            String str = "123Human";
            int num3 = Integer.parseInt(str);
        } catch (NumberFormatException e) {
            System.out.println("NumberFormatException: " + e.getMessage());
        }

        // Rest of your code
        int sum = num1 + num2;
        System.out.println("Sum: " + sum);
    }
}

                        </code>
                    </pre>
                </div>
            </div>
            <div class='code'>
                <div class='dotc'></div>
                <button class='ac'>Program to demonstrate the use of InputMismatchException & NumberFormatException.
                    (try and catch)</button>
                <div class='panel'>
                    <pre>
                        <code>
            
                        </code>
                    </pre>
                </div>
            </div>
        </div>
        <div id="t9" class="wh">
            <h2>Multithreading in Java</h2>
            <p>Before delving into multithreading, it's essential to understand the concept of multitasking in
                computing.</p>

            <ul>
                <li><strong>Multitasking:</strong> Multitasking is the concurrent execution of multiple tasks or
                    processes by a computer's operating system. It allows a computer to perform multiple activities
                    simultaneously.</li>
                <li><strong>Types of Multitasking:</strong> Multitasking can be categorized into two main types:</li>
                <ol>
                    <li><strong>Process-Based Multitasking:</strong> In process-based multitasking, multiple independent
                        processes run concurrently. Each process has its own memory space and resources, and they can
                        communicate with each other through inter-process communication (IPC) mechanisms.
                        <br><strong>Example:</strong> Imagine a computer running a web browser, a word processor, and a
                        music player as separate processes. These processes can run concurrently, allowing the user to
                        browse the web, edit documents, and listen to music simultaneously.
                    </li>
                    <li><strong>Thread-Based Multitasking:</strong> In thread-based multitasking, multiple threads of a
                        single process run concurrently. Threads within the same process share the same memory space and
                        resources, which makes communication between them easier but also requires careful
                        synchronization to avoid conflicts.
                        <br><strong>Example:</strong> Consider a word processing application that uses threads to
                        simultaneously check for spelling errors, format text, and save the document in the background
                        while the user continues typing. These threads work together to enhance the user experience
                        without creating separate processes.
                    </li>
                </ol>
            </ul>

            <p>Now, let's explore the concept of a "thread" in more detail:</p>

            <h3>Threads in Computing</h3>
            <p>A thread is the smallest unit of execution within a program. It represents a sequence of instructions
                that can be scheduled and executed independently by the computer's CPU. Threads within a process share
                the same memory space and resources, allowing them to work together to accomplish tasks concurrently.
            </p>

            <p>Threads are commonly used to perform multiple operations simultaneously, enhance program responsiveness,
                and efficiently utilize modern multi-core processors.</p>

            <p>Java provides extensive support for thread-based multitasking through its multithreading capabilities.
                Understanding threads and multithreading is crucial for building responsive and efficient Java
                applications that can perform multiple tasks concurrently.</p>


            <p>Java provides extensive support for thread-based multitasking through its multithreading capabilities.
                Understanding multithreading is crucial for building responsive and efficient Java applications that can
                perform multiple tasks concurrently.</p>

            <div class="in">
                <h3>What is Multithreading?</h3>
                <p>Multithreading is a concurrent execution process where multiple threads run independently at the same
                    time without dependency on each other. In Java, it allows you to execute multiple threads within a
                    single process, enhancing program performance and responsiveness by making efficient use of the CPU.
                </p>
                <ul>
                    <li>Multithreading Saves Time and Enhances Performance:</li>
                    <p>Multithreading is used to save time and increase the performance of Java applications. By
                        dividing tasks into multiple threads, a program can execute multiple operations simultaneously,
                        taking advantage of modern multi-core processors.</p>

                    <li>Applications in Animation and Game Development:</li>
                    <p>Java is commonly used in animation and game development, where multithreading allows multiple
                        animated characters or game elements to appear on the screen simultaneously. Each character or
                        element can be controlled by a separate thread, enabling concurrent and independent actions.</p>
                </ul>
            </div>

            <div class="in">
                <h3>What is a Thread?</h3>
                <p>A thread is a fundamental unit of execution in a program. It represents a sequence of instructions
                    that can run independently and concurrently with other threads. In Java, threads are instances of
                    the pre-defined `Thread` class, available in the `java.lang` package.</p>
                <ul>
                    <li>Basic Unit of CPU and Independent Execution:</li>
                    <p>Threads are often referred to as the basic units of a CPU because they can be scheduled and
                        executed independently. Each thread shares the same memory space and resources within a process,
                        enabling them to perform tasks simultaneously.</p>
                </ul>
            </div>

            <div class="in">
                <h3>How to Create Threads in Java?</h3>
                <p>In Java, you can create threads in two main ways:</p>
                <ol>
                    <li>By Extending the Thread Class:</li>
                    <p>You can create a new thread by extending the `Thread` class and overriding its `run()` method.
                        This approach allows you to define the thread's behavior within the `run()` method.</p>
                    <li>By Implementing the Runnable Interface:</li>
                    <p>Another way to create threads is by implementing the `Runnable` interface. This approach
                        separates the thread's behavior from the thread object itself. You need to provide the
                        implementation of the `run()` method in a separate class that implements `Runnable` and then
                        create a `Thread` object that executes the `Runnable` instance.</p>
                </ol>
            </div>

            <div class="in">
                <h3>Multitasking vs. Multithreading</h3>
                <p>It's important to distinguish between multitasking and multithreading:</p>
                <ul>
                    <li>Multitasking:</li>
                    <p>Multitasking refers to the concurrent execution of multiple processes or applications by the
                        operating system. These processes can be entirely independent and may or may not share
                        resources.</p>
                    <li>Multithreading:</li>
                    <p>Multithreading, on the other hand, involves concurrent execution within a single process.
                        Multiple threads within the same process share the same memory space and resources, allowing
                        them to work together to achieve parallelism and perform tasks simultaneously.</p>
                </ul>
            </div>
            <div class="in">
                <h3>Defining Threads by Extending the Thread Class</h3>
                <ul>
                    <li><strong>Introduction:</strong></li>
                    <p>In Java, you can create threads by extending the `Thread` class. This approach allows you to
                        define your thread's behavior by overriding the `run()` method. Threads created using this
                        method are also known as "child threads," and they run concurrently with the main thread of the
                        program.</p>
                </ul>

                <pre>
                    <code>
class A extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}

class B {
    public static void main(String[] args) {
        A t = new A();
        t.start(); // Starting the child thread

        // Code below is part of the main thread, while the code above is part of the child thread
        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}
                    </code>
                </pre>

                <ul>
                    <li><strong>The `run` Method in Thread Class:</strong></li>
                    <p>The `run` method is already defined in the `Thread` class, but you can override it to provide
                        your custom implementation. When you start a thread, the JVM automatically calls its `run`
                        method.</p>

                    <li><strong>Concurrency:</strong></li>
                    <p>When you run the program, the order in which the threads run is not guaranteed. Each time you
                        execute the program, the output sequence may differ. However, what is certain is that both the
                        main thread and the child thread run concurrently.</p>
                </ul>

                <p>If you want to introduce a delay between the output, you can use the `Thread.sleep(1000)` method.
                    However, you need to handle exceptions since `Thread.sleep()` can throw an `InterruptedException`.
                    Here's an example:</p>

                <pre>
                    <code>
class A extends Thread {
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Hello");
                Thread.sleep(1000); // Pause for 1 second
            }
        } catch (InterruptedException e) {
            // Handle the interrupted exception
        }
    }
}

class B {
    public static void main(String[] args) throws InterruptedException {
        A t = new A();
        t.start(); // Starting the child thread

        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Defining Threads Using the Runnable Interface</h3>
                <ul>
                    <li><strong>Introduction:</strong></li>
                    <p>In Java, you can create threads by implementing the `Runnable` interface. This approach provides
                        more flexibility compared to extending the `Thread` class because it allows you to separate the
                        thread's behavior from the thread object. Threads created using the `Runnable` interface are
                        also known as "runnable threads."</p>
                </ul>

                <p><strong>Syntax to Define a Thread:</strong></p>
                <pre>
    <code>
class A implements Runnable {
    public void run() {
        // Define the thread's job or task here
    }
}

class B {
    public static void main(String[] args) {
        A obj = new A();
        // obj.start(); // This won't work because we need a Thread object to start a thread
        Thread t = new Thread(obj); // Create a Thread object with obj as a reference
        t.start(); // Now the thread will execute the run() method defined in class A
    }
}
    </code>
</pre>

                <p><strong>Example:</strong></p>
                <pre>
    <code>
class A implements Runnable {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("My child Thread");
        }
    }
}

class B {
    public static void main(String[] args) {
        A r = new A(); // Create an instance of class A, which implements Runnable

        Thread t = new Thread(r); // Create a Thread object with the Runnable instance r
        t.start(); // Start the child thread

        // The main thread is responsible for running the following code
        for (int i = 1; i <= 5; i++) {
            System.out.println("My main Thread");
        }
    }
}
    </code>
</pre>
            </div>
            <div class="in">
                <h3>What is a Thread Scheduler?</h3>
                <ul>
                    <li>A Thread Scheduler is a crucial part of the Java Virtual Machine (JVM) responsible for executing
                        multiple threads
                        on a single processor in a seemingly random manner. It manages when and how much time each
                        thread will be allocated
                        for execution.</li>
                    <li>Within the Thread Scheduler, various algorithms are employed to make these decisions. The
                        scheduler determines
                        which thread to execute first and how much time each thread will receive. For instance, if there
                        are three threads
                        that each require 5 units of execution time, the Thread Scheduler may select one thread for
                        execution, allowing
                        it to run only 4 times. The remaining execution time is then allocated to other threads. This
                        decision-making
                        process is governed by algorithms such as First-Come-First-Serve (FCFS), Shortest Job First
                        (SJF), and Round Robin.</li>
                </ul>

                <p>Here's an example to demonstrate the use of a Thread Scheduler:</p>
                <pre>
                        <code>
class A extends Thread {
    public void run() {
        String name = Thread.currentThread().getName();
        for (int i = 1; i <= 3; i++) {
            System.out.println(name);
        }
    }
}

class Test {
    public static void main(String[] args) {
        A t1 = new A();
        A t2 = new A();
        A t3 = new A();

        t1.setName("Thread 1");
        t2.setName("Thread 2");
        t3.setName("Thread 3");

        t1.start();
        t2.start();
        t3.start();

        String mainThreadName = Thread.currentThread().getName();
        for (int i = 1; i <= 3; i++) {
            System.out.println(mainThreadName);
        }
    }
}
                    </code>
                </pre>
                <p>Explanation of functions used in the program:</p>
                <ul>
                    <li><code>Thread.currentThread().getName()</code>: This function retrieves the name of the current
                        thread.</li>
                    <li><code>Thread.start()</code>: This method is used to start the execution of a thread. When
                        called, it invokes the <code>run()</code> method of the thread.</li>
                    <li><code>run()</code>: This method is overridden in the <code>A</code> class and defines the task
                        that the thread will perform when started.</li>
                    <li><code>setName(String name)</code>: This method sets the name of a thread, making it easier to
                        identify when multiple threads are running concurrently.</li>
                    <li><code>System.out.println()</code>: This function is used to print messages to the console.</li>
                </ul>

                <p>The program demonstrates the use of multiple threads (t1, t2, t3) running concurrently and
                    independently alongside the main thread. Each thread prints its name multiple times, and the main
                    thread also prints its name, showing the concurrent execution of threads.</p>


                <p>When to Use Multithreading and Why?</p>
                <ul>
                    <li>Multithreading is employed when there are independent tasks that can execute concurrently. For
                        example, in the program
                        above, threads t1, t2, and t3 are assigned the independent task of setting their respective
                        names. The order in
                        which they set their names is not critical, and they can work concurrently. Thus, when multiple
                        independent tasks
                        exist, multithreading is a suitable choice.</li>
                    <li>In the program, there are a total of four threads: t1, t2, t3, and the main thread. Each of
                        these threads can
                        execute independently and concurrently.</li>
                    <li><strong>Advantages of the Main Thread:</strong></li>
                    <ul>
                        <li>The main thread serves as the entry point for the Java program. It's responsible for
                            initiating the program's
                            execution.</li>
                        <li>It can be used for performing tasks that need to be coordinated with the program's start and
                            end.</li>
                        <li>The main thread is essential for tasks like user interface initialization, resource
                            allocation, and program
                            termination.</li>
                    </ul>
                </ul>
            </div>
            <div class="in">
                <h3>What is Thread Life Cycle?</h3>
                <p>A thread has a well-defined life cycle during which it can transition through different states, each
                    serving a specific purpose in the execution process:</p>
                <ul>
                    <li><strong>New State (Born):</strong> In this initial state, a thread is created but has not yet
                        started its execution. To create a new thread, we use the 'new' keyword and create an instance
                        of a thread class.</li>
                    <li><strong>Runnable State (Ready):</strong> After the thread is created, it transitions to the
                        runnable state when we invoke the <code>t.start()</code> method. In this state, the thread is
                        ready to be executed but is waiting for the thread scheduler to assign it CPU time.</li>
                    <li><strong>Running State (Execution):</strong> When the thread is selected by the thread scheduler,
                        it moves into the running state. During this phase, the thread's code is actively being
                        executed, and it performs its designated tasks.</li>
                    <li><strong>Waiting State (Blocked):</strong> Threads can enter the waiting state when certain
                        conditions are met. For instance, a thread can transition to the waiting state if we use methods
                        like <b>t.join()</b>, <b>t.sleep()</b>, <b>t.wait()</b>, or
                        <b>t.suspend()</b>. These methods cause the thread to temporarily pause its execution and
                        move to the waiting state. It can later return to the ready state if picked by the thread
                        scheduler.
                        <ul>
                            <li>When using <b>join</b>, <b>sleep</b>, or <b>wait</b> methods, the
                                thread moves directly from the blocked state back to the ready state after a specific
                                time period, which is usually specified in milliseconds. For example,
                                <b>sleep(1000)</b> would make the thread sleep for 1 second before returning to
                                the ready state.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Dead State (Exit):</strong> The final state in a thread's life cycle is the dead state.
                        A thread reaches this state when it has completed its execution. To explicitly terminate a
                        thread and send it to the dead state, we can use the <b>t.stop()</b> method, although it's
                        important to note that this method is not recommended due to its potential for abrupt
                        termination and resource leaks.</li>
                </ul>
                <img src="../../images/threadjava.svg" alt="" class="wb">
                <p>The thread life cycle provides a structured model for understanding the various phases a thread goes
                    through during its execution, from creation to completion.</p>
            </div>
            <div class="in">
                <h3>Thread Transitions in Multithreading</h3>

                <p><b>Understanding Thread Transitions</b></p>

                <p>In multithreading, thread transitions refer to the various states that a thread can move through
                    during its lifecycle. Threads in a multithreaded program can transition between different states as
                    they are created, started, paused, resumed, and terminated. Understanding these thread states is
                    crucial for managing and controlling the execution of threads effectively.</p>

                <p><b>Thread States:</b></p>

                <p>Threads in Java can exist in several states, including:</p>

                <ol>
                    <li><b>New:</b> The thread has been created but has not yet started executing.</li>
                    <li><b>Runnable:</b> The thread is ready to run and waiting for its turn to be scheduled by the
                        thread scheduler.</li>
                    <li><b>Running:</b> The thread is currently executing its code.</li>
                    <li><b>Blocked:</b> The thread is temporarily suspended because it's waiting for a particular
                        condition, such as acquiring a lock or input/output operation.</li>
                    <li><b>Waiting:</b> The thread is in a waiting state and will remain so until another thread
                        notifies it to resume its execution.</li>
                    <li><b>Timed Waiting:</b> Similar to the waiting state, but the thread will automatically transition
                        out of this state after a specified time interval.</li>
                    <li><b>Terminated:</b> The thread has completed its execution and has terminated. It cannot be
                        restarted.</li>
                </ol>

                <p><b>Thread Transition Example:</b></p>

                <p>Here's a simplified example illustrating thread transitions:</p>

                <pre>
                <code>
public class ThreadTransitionsExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1: Running");
        });

        Thread thread2 = new Thread(() -> {
            System.out.println("Thread 2: Running");
        });

        thread1.start(); // Thread 1 transitions from "New" to "Runnable" to "Running."
        thread2.start(); // Thread 2 transitions from "New" to "Runnable" to "Running."

        Thread.sleep(1000);

        // Note: The following methods (suspend, resume, and stop) are deprecated and not recommended for modern multithreaded programming.
        // Instead, use interrupt and join for better control over thread execution.
        
        thread1.suspend(); // Thread 1 transitions to "Blocked." (Deprecated)
        thread2.resume(); // Thread 2 transitions to "Running."

        Thread.sleep(1000);

        thread1.resume(); // Thread 1 transitions back to "Running." (Deprecated)
        thread1.stop();   // Thread 1 transitions to "Terminated." (Deprecated)

        System.out.println("Thread 1 state: " + thread1.getState());
        System.out.println("Thread 2 state: " + thread2.getState());
    }
}
            </code>
            </pre>

                <p>In this example, two threads (<b>thread1</b> and <b>thread2</b>) are created and go
                    through various thread state transitions, including starting, suspending (deprecated), resuming
                    (deprecated), and stopping (deprecated).
                </p>

                <p>Understanding thread transitions is essential for designing reliable multithreaded applications and
                    ensuring that threads behave as expected throughout their lifecycles.</p>

                <p>The following code has been updated to remove the use of deprecated methods:</p>

                <pre>
                        <code>
public class Test {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1: Running");
        });

        Thread thread2 = new Thread(() -> {
            System.out.println("Thread 2: Running");
        });

        thread1.start(); // Thread 1 transitions from "New" to "Runnable" to "Running."
        thread2.start(); // Thread 2 transitions from "New" to "Runnable" to "Running."

        Thread.sleep(1000);

        thread1.interrupt(); // Thread 1 transitions to "Blocked" if asleep, or "Runnable" if not interrupted.
        Thread.sleep(1000);

        thread1.join(); // Wait for Thread 1 to finish its execution.
        thread2.join(); // Wait for Thread 2 to finish its execution.

        System.out.println("Thread 1 state: " + thread1.getState());
        System.out.println("Thread 2 state: " + thread2.getState());
    }
}
                        </code>
                    </pre>

            </div>
            <div class="in">
                <h3>What is the Sleep Method?</h3>
                <ul>
                    <li>The `sleep` method is a static method of the `Thread` class in Java, and it can throw a
                        checked exception known as `InterruptedException`.</li>
                    <li>Its primary purpose is to temporarily pause or put a thread into a waiting state for a
                        specified duration.</li>
                </ul>
                <p><strong>Syntax:</strong></p>
                <pre>
                    <code>
Thread.sleep(milliseconds);  <!-- Example syntax -->
// OR
Thread t = new Thread();
t.sleep(milliseconds);
                    </code>
                </pre>
                <p>
                    The `milliseconds` represent the duration in milliseconds for which the thread should sleep.
                </p>
                <p><strong>Example Program:</strong></p>
                <pre>
                    <code>
class A extends Thread {
    public void run() {
        String threadName = Thread.currentThread().getName();
        try {
            for (int i = 1; i <= 3; i++) {
                System.out.println("From: " + threadName + " -- " + i);
                Thread.sleep(1000); // Sleep for 1 second
            }
        } catch (InterruptedException e) {
            System.out.println(e);
        }
    }
}

class Test {
    public static void main(String[] args) {
        A t1 = new A();
        A t2 = a new A();
        A t3 = new A();

        t1.setName("Thread 1");
        t2.setName("Thread 2");
        t3.setName("Thread 3");

        t1.start();
        t2.start();
        t3.start();
    }
}
                    </code>
                </pre>
                <p>
                    In this example, the `sleep` method is used to introduce delays while printing messages from
                    multiple threads.
                </p>
                <p><strong>Handling InterruptedException:</strong></p>
                <ul>
                    <li>The `try-catch` block is used to catch `InterruptedException` because the `sleep` method
                        can throw this exception if the thread is interrupted by another thread.</li>
                    <li>This exception allows the sleeping thread to handle interruptions gracefully in
                        multi-threaded programs.</li>
                </ul>
            </div>
            <div class="in">
                <h3>join() Method in Java</h3>
                <ul>

                    <li>The <b>join()</b> method in Java is a fundamental method for managing threads. It is used to
                        ensure that a thread, in which the <b>join()</b> method is called, completes its execution
                        before other threads can proceed. This method is particularly useful when you need to coordinate
                        the
                        execution of multiple threads.</li>

                    <li>The main purpose of the <b>join()</b> method is to put the calling thread into a temporary
                        waiting state until the thread on which <b>join()</b> is called finishes its execution. This
                        ensures that the calling thread waits for the specified thread to complete.</li>

                    <li>Additionally, the <b>join()</b> method can throw a checked exception, namely
                        <b>InterruptedException</b>. This exception typically occurs if the thread waiting with
                        <b>join()</b> is interrupted while waiting for the target thread to complete. Proper exception
                        handling is essential when using <b>join()</b>.
                    </li>
                </ul>

                <p>Here is an example of how the <b>join()</b> method can be used:</p>
                <pre>
                    <code>
class A extends Thread {
    public void run() {
        String threadName = Thread.currentThread().getName();
        for (int i = 1; i <= 3; i++) {
            System.out.println("From " + threadName + ": " + i);
        }
    }
}

class Test {
    public static void main(String[] args) {
        A t1 = new A();
        A t2 = new A();
        A t3 = new A();

        t1.setName("Thread 1");
        t2.setName("Thread 2");
        t3.setName("Thread 3");

        t2.start(); // Start Thread 2
        try {
            t2.join(); // Wait for Thread 2 to complete
        } catch (InterruptedException e) {
            System.out.println(e);
        }
        t1.start(); // Start Thread 1
        t3.start(); // Start Thread 3
    }
}
                </code>
            </pre>

                <p>In this example, we create three threads (<code>t1</code>, <code>t2</code>, and <code>t3</code>). We
                    start <code>t2</code> and then call <code>t2.join()</code>, which causes the main thread to wait
                    until <code>t2</code> completes its execution. This ensures that the output from <code>t2</code> is
                    printed before <code>t1</code> and <code>t3</code> start running.</p>

            </div>
            <div class="in">
                <h3>Difference between sleep() and join() methods in Java</h3>
                <p>Java provides two methods, <strong>sleep()</strong> and <strong>join()</strong>, for managing the
                    execution of threads in a multi-threaded application. While both methods involve temporarily
                    suspending the execution of a thread, they serve different purposes and are used in distinct
                    scenarios:</p>

                <ul>
                    <li>
                        <strong>Sleep():</strong> The <code>sleep()</code> method is used to put a thread into a
                        temporary waiting state for a specified amount of time. During this waiting period, the thread
                        releases the CPU, allowing other threads to execute. After the specified time elapses, the
                        thread re-enters the <em>ready</em> state and competes for CPU time with other threads.
                    </li>
                    <li>
                        <strong>Join():</strong> The <code>join()</code> method is used to put the <em>parent
                            thread</em> into a temporary waiting state until the <em>completion</em> of a specified
                        <em>child thread</em>. When a parent thread invokes <code>join()</code> on a child thread, it
                        waits for the child thread to finish its execution before proceeding further. This is
                        particularly useful when you want to coordinate the execution order of threads or ensure that
                        certain tasks are completed before moving on.
                    </li>
                </ul>

                <p>Here's an example to demonstrate the use of both <code>sleep()</code> and <code>join()</code>:</p>

                <pre>
                    <code>
class MyRunnable implements Runnable {
    @Override
    public void run() {
        try {
            // Simulate some work in the child thread
            Thread.sleep(2000); // Sleep for 2 seconds
            System.out.println("Child thread has completed.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        // Create an instance of the Runnable implementation
        Runnable myRunnable = new MyRunnable();

        // Create a Thread and pass the Runnable to it
        Thread childThread = new Thread(myRunnable);

        // Start the child thread
        childThread.start();

        try {
            // Parent thread waits for the child thread to complete
            childThread.join(); // Wait for the child thread to finish
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Parent thread continues.");
    }
}
                    </code>
                </pre>

                <p>In this example, the parent thread starts a child thread, which simulates some work using `sleep()`.
                    The
                    parent thread then uses `join()` to wait for the child thread to finish. As a result, the "Child
                    thread
                    has completed." message is guaranteed to be printed before the "Parent thread continues." message,
                    demonstrating the coordination achieved with the `join()` method.</p>

            </div>
            <div class="in">
                <h3>Suspend() and Resume() Methods in Java (Deprecated)</h3>

                <p>In Java, the <b>suspend()</b> and <b>resume()</b> methods were historically used to control the
                    execution of threads. However, it is crucial to understand that these methods are <b>deprecated
                        since Java 2</b> and are strongly discouraged for use in modern multithreaded applications. The
                    reason for deprecation is their inherent shortcomings, including the potential for thread
                    <b>deadlock</b> and <b>other synchronization issues</b>. Instead, Java offers more reliable and
                    safer mechanisms for thread control and coordination, such as the <b>wait()</b> and <b>notify()</b>
                    methods, or higher-level concurrency utilities provided by the Java concurrency framework.
                </p>

                <p>Below, we'll briefly discuss the deprecated <b>suspend()</b> and <b>resume()</b> methods and provide
                    an example:</p>

                <h4>Suspend() Method (Deprecated)</h4>

                <ul>
                    <li>The main purpose of the <b>suspend()</b> method was to put a thread from the running state to
                        the waiting state. When a thread was suspended, it was temporarily halted in its current state.
                    </li>
                </ul>

                <p>Example:</p>

                <pre>
                    <code>
A t1 = new A();
A t2 = new A();
A t3 = new A();

t1.start();
t2.start();
t3.start();

t2.suspend(); // Thread t2 is suspended and will not be executed.
                    </code>
                </pre>

                <ul>
                    <li>In the example above, <b>t2</b> is suspended using the <b>suspend()</b> method, which caused it
                        to stop executing.</li>
                    <li>To resume a suspended thread, you would typically use the <b>resume()</b> method (deprecated).
                    </li>
                </ul>

                <h4>Resume() Method (Deprecated)</h4>

                <ul>
                    <li>The <b>resume()</b> method (deprecated) was used to resume a suspended thread, transitioning it
                        from the waiting state back to the runnable state, allowing it to continue execution.</li>
                </ul>

                <pre>
                    <code>
t2.resume(); // Thread t2 is resumed and can continue executing (deprecated).
                    </code>
                </pre>

                <p>Given the issues associated with the <b>suspend()</b> and <b>resume()</b> methods, it is strongly
                    recommended that you avoid using them in your code. Instead, consider using more modern and safer
                    synchronization mechanisms and concurrency utilities provided by Java, such as the <b>wait()</b> and
                    <b>notify()</b> methods or the higher-level <b>java.util.concurrent</b> classes, for effective
                    thread control and coordination.
                </p>
                <h3>Wait() and Notify() Methods in Java</h3>

                <p>In Java, the <b>wait()</b> and <b>notify()</b> methods are essential for thread synchronization and
                    coordination. These methods are considered fundamental in multithreaded programming and are
                    recommended for managing thread execution.</p>

                <h4>wait() Method</h4>

                <ul>
                    <li>The <b>wait()</b> method is used to make a thread temporarily release its lock on an object and
                        enter a waiting state. This is typically used when a thread needs to wait for a specific
                        condition to be met before proceeding.</li>
                </ul>

                <p>Example:</p>

                <pre>
                    <code>
class SharedResource {
    private boolean condition = false;

    synchronized void waitForCondition() throws InterruptedException {
        while (!condition) {
            wait(); // Release the lock and wait for the condition to be true.
        }
    }

    synchronized void setConditionTrue() {
        condition = true;
        notify(); // Notify a waiting thread that the condition has been met.
    }
}
                    </code>
                </pre>

                <h4>notify() Method</h4>

                <ul>
                    <li>The <b>notify()</b> method is used to notify a waiting thread that the condition it was waiting
                        for has been met. It allows one waiting thread to continue its execution.</li>
                </ul>

                <p>Example:</p>

                <pre>
                    <code>
class ExampleThread extends Thread {
    private SharedResource resource;

    public ExampleThread(SharedResource resource) {
        this.resource = resource;
    }

    public void run() {
        try {
            Thread.sleep(1000); // Simulate some work.
            resource.setConditionTrue(); // Set the condition to true and notify waiting threads.
        } catch (InterruptedException e) {
            System.out.println(e);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        ExampleThread thread = new ExampleThread(resource);

        thread.start();

        try {
            resource.waitForCondition(); // Wait for the condition to be true.
            System.out.println("Condition is now true. Continuing execution.");
        } catch (InterruptedException e) {
            System.out.println(e);
        }
    }
}
                    </code>
                </pre>

                <p>In the example above, the <b>wait()</b> and <b>notify()</b> methods are used to coordinate the
                    execution of two threads. The main thread waits for the condition to be set to true by the
                    <b>ExampleThread</b>, and when the condition is met, it continues its execution.
                </p>

                <p>Using <b>wait()</b> and <b>notify()</b> methods, you can create more robust and predictable
                    multithreaded applications by allowing threads to communicate and synchronize their actions
                    effectively.</p>

            </div>
            <div class="in">
                <h3>What is Thread Priority in Java?</h3>

                <p>In Java, thread priority is a way to influence the order in which threads are scheduled to run by the
                    thread scheduler. Each thread has a priority assigned to it, and threads with higher priority values
                    have a better chance of being executed before threads with lower priority values. However, it's
                    important to note that thread priority should be used judiciously, as it doesn't guarantee precise
                    execution order and can vary depending on the underlying system.</p>

                <p>Here are some key points about thread priority:</p>

                <ul>
                    <li>If you don't explicitly set the priority of a thread, it will be assigned a default priority by
                        the JVM, which is typically 5.</li>
                    <li>You can manually set the priority of a thread using the methods <b>setPriority()</b> and
                        retrieve its priority using <b>getPriority()</b>.</li>
                    <li>The <b>Thread</b> class provides three predefined final static variables for priority, with
                        values ranging from 1 to 10:
                        <ul>
                            <li><b>Thread.MIN_PRIORITY</b> with a value of 1, representing the lowest priority.</li>
                            <li><b>Thread.NORM_PRIORITY</b> with a value of 5, representing the default or normal
                                priority.</li>
                            <li><b>Thread.MAX_PRIORITY</b> with a value of 10, representing the highest priority.</li>
                        </ul>
                    </li>
                </ul>

                <p>It's important to use thread priority carefully, as relying solely on priority for thread
                    synchronization and coordination can lead to unpredictable behavior. Thread priority should be
                    considered as a hint to the thread scheduler, and other synchronization mechanisms should be used
                    for precise control over thread execution.</p>

                <p>Example:</p>

                <pre>
                    <code>
class PriorityExample extends Thread {
    public void run() {
        System.out.println("Thread " + Thread.currentThread().getName() + " with priority " + Thread.currentThread().getPriority() + " is running.");
    }

    public static void main(String[] args) {
        PriorityExample thread1 = new PriorityExample();
        PriorityExample thread2 = new PriorityExample();

        thread1.setPriority(Thread.MAX_PRIORITY);
        thread2.setPriority(Thread.MIN_PRIORITY);

        thread1.start();
        thread2.start();
    }
}
                    </code>
                </pre>

                <p>In this example, we create two threads with different priorities using the <b>setPriority()</b>
                    method. Thread 1 is set to <b>MAX_PRIORITY</b>, and Thread 2 is set to <b>MIN_PRIORITY</b>. The
                    output may vary depending on the thread scheduler, but Thread 1 has a higher chance of running
                    before Thread 2 due to its higher priority.</p>

            </div>
            <div class="in">
                <h3>yield() Method in Java</h3>

                <p>In Java, the <b>yield()</b> method is a part of the Thread class and is used to allow other threads
                    with equal or higher priority to have a chance to run. It essentially temporarily pauses the
                    execution of the current thread, giving way to other threads in the same priority range. However,
                    it's important to understand that the effectiveness of the <b>yield()</b> method may vary depending
                    on the operating system and the thread scheduler.</p>

                <p>Here's how the <b>yield()</b> method works:</p>

                <ul>
                    <li>When a thread calls <b>yield()</b>, it voluntarily relinquishes the CPU, indicating that it has
                        no objection to other threads running.</li>
                    <li>The scheduler then determines which thread to execute next, considering factors like thread
                        priority and the specific scheduling algorithm.</li>
                    <li>Threads with higher priority may be favored, but it ultimately depends on the underlying
                        scheduling policy.</li>
                </ul>

                <p>Example:</p>

                <pre>
                    <code>
class A extends Thread {
    public void run() {
        String threadName = Thread.currentThread().getName();
        for (int i = 1; i <= 3; i++) {
            System.out.println("From " + threadName + ": " + i);
        }
    }
}

class Test {
    public static void main(String[] args) {
        A t1 = new A();
        A t2 = new A();
        A t3 = new A();

        t1.setName("Thread 1");
        t2.setName("Thread 2");
        t3.setName("Thread 3");

        t1.setPriority(Thread.MIN_PRIORITY); // Lower priority
        t2.setPriority(Thread.MAX_PRIORITY); // Highest priority
        t3.setPriority(Thread.NORM_PRIORITY); // Default priority

        t1.start();
        t2.start();
        t3.start();

        t2.yield(); // Thread 2 yields, allowing other threads to run.
    }
                }
                    </code>
                </pre>

                <ul>
                    <li>In this example, we create three threads with different priorities: <b>t1</b> (lowest),
                        <b>t2</b> (highest), and <b>t3</b> (default).
                    </li>
                    <li>Thread <b>t2</b> calls <b>yield()</b>, indicating that it's willing to let other threads run.
                        The scheduler then decides which thread to execute next.</li>
                    <li>The effect of <b>yield()</b> depends on the thread priorities and the specific behavior of the
                        thread scheduler.</li>
                </ul>

                <p>While the <b>yield()</b> method can be used for thread control, it is often better to rely on other
                    synchronization mechanisms and thread management techniques to achieve predictable and robust
                    multithreaded behavior.</p>
            </div>
            <div class="in">
                <h3>stop() and interrupt() Methods in Java (Deprecated and Preferred)</h3>

                <p>The <b>stop()</b> method is a deprecated way of terminating a thread in Java. It forcefully stops a
                    thread's execution without allowing it to finish its current work or clean up resources. However,
                    it's strongly discouraged due to potential issues like thread instability, data corruption, and
                    resource leaks. Instead, Java offers a safer and preferred way of thread termination using the
                    <b>interrupt()</b> method.
                </p>

                <h4>stop() Method (Deprecated)</h4>

                <ul>
                    <li>The <b>stop()</b> method was used to terminate a thread immediately, which often left the thread
                        in an inconsistent state, leading to data corruption and application instability.</li>
                </ul>

                <h4>interrupt() Method (Preferred)</h4>

                <ul>
                    <li>The <b>interrupt()</b> method is the recommended way to gracefully terminate a thread in Java.
                    </li>
                    <li>When a thread is interrupted, it receives an interrupt status but continues to execute unless it
                        periodically checks its interrupt status using <b>isInterrupted()</b> or encounters a blocking
                        operation that throws an <b>InterruptedException</b>.</li>
                    <li>To terminate a thread, you set its interrupt status using <b>interrupt()</b> and handle the
                        interruption within the thread's <b>run()</b> method by checking the interrupt status and
                        exiting gracefully when appropriate.</li>
                </ul>

                <p>Example:</p>

                <pre>
            <code>
class A extends Thread {
    public void run() {
        String threadName = Thread.currentThread().getName();
        for (int i = 1; i <= 3; i++) {
            System.out.println("From " + threadName + ": " + i);
        }
        if (Thread.interrupted()) { // Check for interruption.
            System.out.println("Thread " + threadName + " is interrupted. Exiting gracefully.");
            return;
        }
    }
}

class Test {
    public static void main(String[] args) {
        A t1 = new A();
        A t2 = new A();
        A t3 = new A();

        t1.start();
        t2.start();

        t2.interrupt(); // Interrupt Thread t2.

        t3.start();
    }
}
                </code>
            </pre>

                <p>In this example, we use the <b>interrupt()</b> method to gracefully terminate <b>t2</b>. The thread
                    periodically checks its interrupt status using <b>Thread.interrupted()</b> and exits when
                    interrupted, allowing for proper resource cleanup.</p>

                <p>It's essential to use the <b>interrupt()</b> method and handle thread interruption correctly to
                    ensure that your multithreaded Java applications are stable and reliable.</p>

            </div>
            <div class="in">
                <h3>isAlive() Method in Java</h3>

                <p>The <b>isAlive()</b> method in Java is used to check the current status of a thread. It returns
                    <b>true</b> if the thread is currently running (i.e., it has been started and has not yet completed
                    its execution), and it returns <b>false</b> if the thread has terminated, either by naturally
                    completing its <b>run()</b> method or due to an unhandled exception.
                </p>

                <p>Here's a brief overview of how the <b>isAlive()</b> method works:</p>

                <ul>
                    <li>When you call <b>isAlive()</b> on a thread object, it provides information about whether the
                        thread is actively executing.</li>
                    <li>This method is useful for checking the status of a thread and making decisions based on whether
                        it's still running.</li>
                </ul>

                <p>Example:</p>

                <pre>
                    <code>
class ExampleThread extends Thread {
    public void run() {
        // Simulate some work.
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            System.out.println(e);
        }
    }

    public static void main(String[] args) {
        ExampleThread thread = new ExampleThread();
        System.out.println("Before starting the thread, isAlive: " + thread.isAlive());

        thread.start();
        System.out.println("After starting the thread, isAlive: " + thread.isAlive());

        try {
            thread.join();
        } catch (InterruptedException e) {
            System.out.println(e);
        }

        System.out.println("After the thread has finished, isAlive: " + thread.isAlive());
    }
}
                    </code>
                </pre>

                <p>In this example, we create a thread, start it, and use <b>isAlive()</b> to check its status at
                    different points in the program. The method correctly reflects whether the thread is currently
                    running or has completed its execution.</p>

                <p>The <b>isAlive()</b> method is a valuable tool for managing and monitoring the status of threads in a
                    multithreaded Java application.</p>

            </div>
            <div class="in">
                <h3>Understanding Synchronization in Multithreading</h3>

                <p><b>Why Synchronization is Needed?</b></p>

                <p>Multithreading is a powerful technique for concurrent execution, allowing tasks to be completed
                    efficiently. However, it introduces challenges when multiple threads attempt to access shared
                    resources simultaneously. This can lead to unexpected and incorrect results due to data corruption
                    or race conditions. To address these issues, synchronization mechanisms are essential to ensure
                    orderly and safe access to shared resources in multithreaded programs.</p>

                <p><b>Challenges in Multithreading</b></p>

                <ul>
                    <li>In multithreaded environments, multiple threads may execute concurrently and access shared
                        resources, such as variables or objects, simultaneously.</li>
                    <li>Without proper synchronization, threads can interfere with each other's execution, leading to
                        data inconsistencies and unexpected program behavior.</li>
                </ul>

                <p><b>Example</b></p>

                <p>Consider a simple example to illustrate the need for synchronization:</p>

                <ul>
                    <li>Imagine a bus with only one available seat, and there are three passengers who want to occupy
                        that seat simultaneously.</li>
                    <li>In a multithreading context, this situation parallels when multiple threads attempt to execute
                        the same function or access the same data without synchronization.</li>
                    <li>Without synchronization, all threads might concurrently modify shared data, resulting in data
                        corruption or unpredictable outcomes.</li>
                </ul>

                <p>Here is a basic analogy to the bus example:</p>

                <pre>
                    <code>
class Bus {
    private int availableSeats = 1;

    public void bookSeat() {
        if (availableSeats > 0) {
            // Simulate some booking process.
            availableSeats--;
            System.out.println("Seat booked by " + Thread.currentThread().getName());
        } else {
            System.out.println("No seats available.");
        }
    }
}

class PassengerThread extends Thread {
    private Bus bus;

    public PassengerThread(Bus bus) {
        this.bus = bus;
    }

    public void run() {
        bus.bookSeat();
    }
}

public class BusBookingApp {
    public static void main(String[] args) {
        Bus bus = new Bus();
        PassengerThread passenger1 = new PassengerThread(bus);
        PassengerThread passenger2 = new PassengerThread(bus);
        PassengerThread passenger3 = new PassengerThread(bus);

        passenger1.start();
        passenger2.start();
        passenger3.start();
    }
}
                </code>
            </pre>

                <p>In this example, multiple passenger threads try to book a seat in the bus simultaneously. Without
                    synchronization, it's possible for more than one passenger to book the same seat, leading to
                    incorrect results.</p>

                <p>To address these issues and ensure orderly access to shared resources, synchronization mechanisms
                    like locks, mutexes, and synchronized blocks are used in multithreaded programming.</p>
                <p><b>What is Synchronization?</b></p>

                <p>Synchronization is a crucial technique in multithreading that enables controlled access to shared
                    resources among multiple threads. It ensures that only one thread can enter a synchronized block or
                    method at a time, preventing concurrent and potentially problematic access to shared data.</p>

                <p><b>Purpose of Synchronization</b></p>

                <p>The primary purpose of synchronization is to address the challenges that arise in multithreading when
                    multiple threads simultaneously attempt to access the same shared resource. Without synchronization,
                    these situations can lead to undesirable outcomes, including data corruption and incorrect program
                    behavior.</p>

                <p><b>Types of Synchronization</b></p>

                <p>Synchronization in Java can be broadly classified into two categories:</p>

                <ol>
                    <li><b>Method-Level Synchronization:</b> In method-level synchronization, the entire method is
                        synchronized using the <b>synchronized</b> keyword. Only one thread can execute the
                        synchronized method at a time.</li>
                    <li><b>Block-Level Synchronization:</b> Block-level synchronization allows for finer control.
                        Specific blocks of code within a method can be synchronized using synchronized blocks, denoted
                        by <b>synchronized (object)</b>. This provides better granularity and performance in some
                        scenarios.</li>
                </ol>
                <p><b>Method-Level Synchronization</b></p>

                <p>Method-level synchronization in Java is achieved by using the <b>synchronized</b> keyword to
                    declare a method. When a method is marked as synchronized, only one thread can execute that method
                    on the same object instance at a time. This ensures that the critical section of code within the
                    synchronized method is protected from concurrent access by multiple threads, preventing race
                    conditions and data corruption.</p>

                <p>Here's an example of method-level synchronization:</p>

                <pre>
                    <code>
class Hotel {
    private int guests = 0;

    public synchronized void checkIn() {
        // Synchronized method.
        guests++;
        System.out.println("Guest checked in. Total guests: " + guests);
    }

    public synchronized void checkOut() {
        // Synchronized method.
        guests--;
        System.out.println("Guest checked out. Total guests: " + guests);
    }
}
                    </code>
                </pre>

                <p>In this example, the <b>checkIn()</b> and <b>checkOut()</b> methods are declared as
                    synchronized. This means that only one guest can check in or check out at a time, preventing
                    conflicts and ensuring the <b>guests</b> variable is accessed safely.</p>

                <p>Method-level synchronization is suitable when you want to protect an entire method or when the entire
                    method needs to be atomic and thread-safe. However, it can lead to contention if multiple threads
                    frequently access the synchronized methods concurrently, potentially causing performance
                    bottlenecks.</p>

                <p>It's important to choose the appropriate level of synchronization based on your application's
                    requirements. In some cases, block-level synchronization may offer better performance and
                    flexibility.</p>

                <p><b>Block-Level Synchronization</b></p>
                <p>Block-level synchronization in Java allows for more fine-grained control over synchronization
                    compared to method-level synchronization. Instead of synchronizing entire methods, you can
                    synchronize specific blocks of code using the <b>synchronized</b> keyword with an object as a
                    monitor. This approach provides greater flexibility and can lead to improved performance by reducing
                    contention in multithreaded applications.</p>

                <p>Here's an example of block-level synchronization:</p>

                <pre>
                    <code>
class Account {
    private double balance = 1000;
    private Object lock = new Object(); // Monitor object for synchronization.

    public void withdraw(double amount) {
        synchronized (lock) { // Synchronized block.
            if (balance >= amount) {
                balance -= amount;
                System.out.println("Withdrawal of $" + amount + " successful. New balance: $" + balance);
            } else {
                System.out.println("Insufficient funds for withdrawal.");
            }
        }
    }

    public void deposit(double amount) {
        synchronized (lock) { // Synchronized block.
            balance += amount;
            System.out.println("Deposit of $" + amount + " successful. New balance: $" + balance);
        }
    }
}
                    </code>
                </pre>
                <p>In this example, we have an <b>Account</b> class with <b>withdraw()</b> and
                    <b>deposit()</b> methods. Instead of synchronizing the entire methods, we use synchronized
                    blocks to protect critical sections of code within those methods. The <b>lock</b> object
                    serves as a monitor for synchronization.
                </p>

                <p>Block-level synchronization is preferred in scenarios where you want to synchronize specific code
                    sections, allowing other parts of the methods to execute concurrently. It provides better
                    granularity and can lead to reduced contention and improved performance.</p>

                <p>When choosing between method-level and block-level synchronization, consider the synchronization
                    requirements of your application to ensure both correctness and efficiency in your multithreaded
                    code.</p>

            </div>
            <div class="in">
                <h3>Static Synchronization in Java</h3>

                <p><b>Introduction to Static Synchronization</b></p>

                <p>In Java, static synchronization is a synchronization mechanism that allows you to control access to
                    static methods or static data members of a class by multiple threads. It ensures that only one
                    thread can execute a synchronized static method or access synchronized static data at a time,
                    preventing data corruption and race conditions in a multithreaded environment.</p>

                <p><b>The Need for Static Synchronization</b></p>

                <p>Static synchronization was introduced to address a specific problem associated with synchronization
                    in Java:</p>

                <ul>
                    <li>In multithreaded applications, it's common for multiple threads to need access to shared
                        resources, including static methods and static data members of a class.</li>
                    <li>Without synchronization, concurrent access to shared static resources can lead to race
                        conditions and unpredictable program behavior.</li>
                </ul>

                <p>Static synchronization was introduced to provide a mechanism for coordinating access to static
                    resources across multiple threads, ensuring data integrity and preventing issues associated with
                    unsynchronized access.</p>

                <p><b>Example:</b></p>

                <p>Here's an example of static synchronization:</p>

                <pre>
            <code>
class SharedResource {
    private static int counter = 0;

    public static synchronized void incrementCounter() {
        // Synchronized static method.
        counter++;
    }
}

public class StaticSynchronizationExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                SharedResource.incrementCounter();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                SharedResource.incrementCounter();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            System.out.println(e);
        }

        System.out.println("Final counter value: " + SharedResource.getCounter());
    }
}
            </code>
            </pre>

                <p>In this example, the <b>incrementCounter()</b> method of the <b>SharedResource</b> class is
                    synchronized as a static method. This ensures that only one thread can increment the counter at a
                    time, even though multiple threads are accessing it concurrently.</p>

                <p>Static synchronization is a valuable tool for managing concurrent access to shared static resources
                    and is commonly used in multithreaded Java applications.</p>

            </div>
        </div>
    </div>
    <div class="content-box" id="tpyq">
        <h2>Previous Year Questions</h2>
        <div class="in">
            <h3>With illustrations explain multithreading, interrupting threads, thread states and thread properties.
                Write a code snapshot to show the used of yield(), stop() and sleep() methods.</h3>
        </div>
        <div class="in">
            <h3>Discuss the following:
                <br>(i) Thread Synchronization
                <br>(ii) Runnable interface
            </h3>
        </div>
        <div class="in">
            <h3>Illustrate the usage of throw and throws by using suitable example.</h3>
        </div>
        <div class="in">
            <h3>Define Exceptions in Java. Write a Java code to show the imiplementation of
                ArrayIndexOutOfBoundsExceptions and ArithmeticException.</h3>
        </div>
        <div class="in">
            <h3>Define Multithreading in Java? Explain life cycle thread? State the programme which shows the difference
                between Runnable and Thread class.</h3>
        </div>
        <div class="in">
            <h3>Define Arrays in Java and its classification. Write a programme to show the Exception
                ArrayIndexOutOfBoundsException.</h3>
        </div>
        <div class="in">
            <h3>Define Exception Explain the use of try and multiple catch in Java. Illustrate the difference between
                throw and throws in Java.</h3>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/playlist?list=PLqleLpAMfxGARB5Xa4Baa0lpRlUvZVJH8" target="_blank"
                    class="ba">Multithreading playlist &neArr;</a></li>
        </ul>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
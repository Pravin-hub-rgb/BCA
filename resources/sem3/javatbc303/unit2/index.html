<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exception Handling & Multithread Programming</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body>
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#" class="link"></a>
        <div class="botbut">
            <a href="" class="link">Next Topic &rarr;</a>
            <a href="" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Exception Handling & Multithread Programming</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Exception Handling & Multithread Programming</h1>
        <div class="wh">
            <h2>Exceptions in Java</h2>
            <p>
                In Java, exceptions are events that occur during the execution of a program that disrupt the normal flow
                of instructions. Exceptions can occur for various reasons, such as division by zero, trying to access an
                array element that doesn't exist, or attempting to open a file that doesn't exist.
                <br>
                In Java, exceptions are a vital concept used to manage and handle runtime errors gracefully. They play a
                crucial role in achieving the goal of a robust programming language. Let's delve deeper into the world
                of exceptions:
            </p>
            <ul>
                <li><strong>Runtime Error Management:</strong> Exceptions are primarily used to tackle runtime errors.
                    These errors can occur during program execution and might disrupt the normal flow of the
                    application.</li>
                <li><strong>Robust Language:</strong> Java's exception handling mechanism is one of the reasons it's
                    considered a robust language. It allows programs to continue running smoothly even in the presence
                    of errors.</li>
                <li><strong>Flow Control:</strong> Exception handling helps maintain the flow of a program. It ensures
                    that the program doesn't terminate abruptly when errors occur but instead gracefully handles them.
                </li>
                <li><strong>General Errors:</strong> In a broader sense, exceptions represent various types of runtime
                    errors, making it easier to identify and address issues.</li>
            </ul>
        </div>

        <div class="wh">
            <h2>Exception Handling</h2>
            <p>
                Exception handling is a fundamental aspect of Java programming that empowers developers to deal with
                runtime errors systematically. Java provides built-in support for exception handling, making it easier
                to write robust and reliable code. Here's a closer look at exception handling in Java:
            </p>
            <ul>
                <li><strong>Automatic Handling:</strong> Java has a built-in mechanism for handling exceptions. When an
                    exception occurs, Java automatically looks for an appropriate handler to manage the situation.</li>
                <li><strong>Example:</strong> Consider this example where an attempt to divide by zero results in an
                    exception. Java's automatic handling ensures that the program doesn't crash but rather reports the
                    issue.</li>
            </ul>
            <pre>
                <code>
int x = 10; 
int ans = x / 0; // Automatically handled by Java
String s1 = null; // also an exception
                </code>
            </pre>
            <ul>
                <li><strong>Preventing Abnormal Termination:</strong> Exception handling prevents programs from
                    abnormally terminating due to runtime errors. This is especially crucial when creating software, as
                    unhandled exceptions can lead to unpredictable outcomes, including system crashes.</li>
                <li><strong>Essential OOP Feature:</strong> Exception handling is a fundamental feature of
                    object-oriented programming (OOP). It allows developers to encapsulate error-handling logic and
                    maintain clean and modular code.</li>
                <li><strong>Respective Handlers:</strong> In Java, exceptions are handled by methods or classes
                    specifically designed for that purpose. These handlers determine how different types of errors are
                    managed and what error messages to display.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Exception Hierarchy in Java</h2>

            <p>In Java, exceptions are organized into a hierarchy of classes through inheritance. The
                <code>java.lang.Throwable</code> class serves as the root of this hierarchy.
            </p>
            <img src="../../images/exceptioninjava.svg" alt="" class="wb">
            <h3>Throwable (Root Class)</h3>
            <p>The <code>Throwable</code> class is the root class of the exception hierarchy in Java. It has two main
                subclasses:</p>

            <div class="in">
                <h3>Error</h3>
                <p><strong>Error</strong> represents serious, unrecoverable system-level errors, often caused by the JVM
                    or
                    underlying hardware. Developers usually don't handle these exceptions, and they typically lead to
                    program termination.</p>
                <ul>
                    <li><strong>StackOverflowError:</strong> Occurs when the call stack (method call history) exceeds
                        its
                        limit.</li>
                    <li><strong>OutOfMemoryError:</strong> Indicates that the JVM has exhausted available memory.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Exception</h3>
                <p><strong>Exception</strong> represents exceptions that can be caught and handled by application code.
                    It's further divided into two subcategories:</p>

                <div class="wh">
                    <h3>RuntimeException</h3>
                    <p><strong>RuntimeException</strong> represents exceptions that occur at runtime and are typically
                        caused by programming errors. These exceptions don't require explicit handling.</p>
                    <p>Runtime exceptions, also known as unchecked exceptions, are exceptions that occur at runtime and
                        are typically caused by programming errors. These exceptions don't require explicit handling and
                        can be considered bugs in the code. They are subclasses of the RuntimeException class.</p>
                    <p>Various runtime exceptions include:</p>
                    <ul>
                        <li>NullPointerException: Raised when trying to access or manipulate an object reference that is
                            null.</li>
                        <li>IndexOutOfBoundsException:
                            <ul>
                                <li>ArrayIndexOutOfBoundsException: Occurs when attempting to access an array element
                                    with an invalid index.</li>
                                <li>StringIndexOutOfBoundsException: Happens when trying to access a character in a
                                    string with an invalid index.</li>
                            </ul>
                        </li>
                        <li>ArithmeticException: Occurs during mathematical operations like division by zero.</li>
                        <li>NumberFormatException: Raised when trying to convert a string to a numeric type, but the
                            string does not represent a valid numeric value.</li>
                    </ul>
                    <p>Runtime exceptions are typically raised when there are programming errors, such as trying to
                        access null objects, accessing arrays or strings out of bounds, or performing invalid arithmetic
                        operations.</p>
                </div>

                <div class="wh">
                    <h3>Checked Exceptions</h3>
                    <p><strong>Checked Exceptions</strong> represent exceptions that must be explicitly declared and
                        handled in code. These exceptions occur due to external factors and often require actions like
                        input validation or dealing with I/O operations.</p>
                    <p>Checked exceptions are exceptions that must be explicitly declared and handled in code. They are
                        usually subclasses of the Exception class and are typically caused by external factors.</p>
                    <p>Examples of checked exceptions include:</p>
                    <ul>
                        <li>IOException: Raised when an I/O operation (e.g., file reading/writing) encounters an issue.
                        </li>
                        <li>FileNotFoundException: Occurs when trying to access a file that does not exist.</li>
                        <li>SQLException: Raised in database operations when a SQL query or connection fails.</li>
                        <li>ClassNotFoundException: Thrown when a required class is not found at runtime, often related
                            to class loading issues.</li>
                    </ul>
                    <p>Checked exceptions often require explicit handling in code, such as using try-catch blocks, to
                        deal with issues like file not found, database connection problems, or class loading failures.
                    </p>
                </div>
            </div>

            <p>The <code>Throwable</code> class, along with its subclasses <code>Error</code> and
                <code>Exception</code>, forms the foundation of Java's exception handling system. Developers can create
                their custom exceptions by extending the <code>Exception</code> class or one of its subclasses.
            </p>

            <p>When handling exceptions in Java, it's essential to catch specific exceptions based on the situation,
                which allows for more precise error handling and recovery.</p>
        </div>

        <div class="wh">
            <h2>Try & Catch Blocks in Exception Handling</h2>
            <p>
                Exception handling in Java involves several essential keywords, including try, catch, finally, throw,
                and throws. Let's dive into the details of how these keywords play a crucial role in managing
                exceptions:
            </p>
            <ul>
                <li><strong>Keywords Overview:</strong> Exception handling in Java is facilitated by specific keywords:
                    <ul>
                        <li>try</li>
                        <li>catch</li>
                        <li>finally</li>
                        <li>throw</li>
                        <li>throws</li>
                    </ul>
                    These keywords allow programmers to handle exceptions manually, providing more control over the
                    error-handling process.
                </li>
                <li><strong>Optionality of Keywords:</strong> Among these keywords, finally, throw, and throws are
                    optional. You can choose to use them based on the specific requirements of your code.
                    <ul>
                        <li>finally: This block contains code that executes regardless of whether an exception occurs.
                            It's often used for cleanup operations.</li>
                        <li>throw: It's used to explicitly throw an exception within your code when certain conditions
                            are met.</li>
                        <li>throws: This keyword is used in method declarations to indicate that the method may throw a
                            particular type of exception. It's particularly useful when defining custom exception
                            classes.</li>
                    </ul>
                </li>
                <li><strong>Levels of Exception Handling:</strong> Exception handling can be categorized into different
                    levels:
                    <ul>
                        <li><strong>Level 1:</strong> At this level, Java's default error-handling mechanisms come into
                            play. The JVM handles these exceptions without programmer intervention.</li>
                        <li><strong>Level 2:</strong> The try and catch blocks are used by programmers to handle
                            exceptions more specifically. It allows developers to define their own logic for dealing
                            with exceptions.</li>
                        <li><strong>Level 3:</strong> Finally, throw, and throws come into play at this level. The
                            finally block ensures essential cleanup code is executed, throw is used to explicitly raise
                            exceptions, and throws is employed for specifying potential exceptions that a method may
                            throw.</li>
                    </ul>
                </li>
                <li><strong>Effectiveness of Try, Catch, and Throws:</strong> In practice, approximately 90% of
                    exceptions are effectively handled using try, catch, and throws blocks. These mechanisms offer a
                    robust approach to exception management.</li>
                <li><strong>Best Practice:</strong> Handling exceptions with 'throws' is considered a best practice,
                    especially in situations where a programmer possesses in-depth knowledge of Java. It allows for more
                    precise and controlled exception handling, particularly when dealing with user-defined exceptions.
                </li>
                <li><strong>Usage of 'throws':</strong> The 'throws' keyword is primarily used for declaring
                    user-defined exceptions in method signatures. It indicates that a method may throw specific types of
                    exceptions, providing valuable information to other developers using the method.</li>
            </ul>
            <div class="in">
                <h3>Handling Exceptions by the User Using Try and Catch Blocks</h3>
                <p>Example &darr;</p>
                <pre><code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        try {
            ans = v1 / v2;
            System.out.println(ans);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        }
    }
}
                </code></pre>
                <ul>
                    <li>In the above code, when we provide v2 = 0, we will get a 'DivideByZero' error, which is
                        correctly handled by Java.</li>
                    <li>As we can see, the program is correct, but when v2 = 0, the code after that won't get executed
                        because Java doesn't handle it, and that's why it gets terminated.</li>
                    <li>Now, if we want to handle it by the user, we will use the try-catch block.
                        <ul>
                            <li>Try block: Used for handling exceptions by the user. In the try block, we put the code
                                that might generate an exception. If an exception is generated by the try block, it
                                switches to the catch block, which is the exception handler.</li>
                        </ul>
                    </li>
                    <li>If we are not sure which part will give an exception, then put the whole code inside the try
                        block. Only the content that might generate an exception will be part of the try block, not any
                        method.</li>
                </ul>
                <pre><code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        try {
            Scanner sc = new Scanner(System.in);
            int v1, v2, ans;
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();
            ans = v1 / v2;
            System.out.println(ans);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        }
    }
}
                </code></pre>
                <ul>
                    <li>Remember, try without catch won't work.</li>
                    <li>If we want to find which line caused the error and get its name, we can do the following:</li>
                </ul>
                <pre><code>
catch (Exception e) {
    System.out.println("Error occurred at line: " + e.getStackTrace()[0].getLineNumber());
    System.out.println("Error message: " + e.getMessage());
}
// This provides full details about the error.
                </code></pre>

            </div>
            <div class="in">
                <h3>Try with Multiple Catch Blocks</h3>
                <ul>
                    <li>We can even put a try block inside another try block.</li>
                </ul>
                <pre>
                    <code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        try {
            ans = v1 / v2;
            System.out.println(ans);
        }
        catch (NumberFormatException e1) {
            System.out.println("Exception due to wrong input datatype");
        }
        catch (ArithmeticException e2) {
            System.out.println("Exception due to dividing by zero");
        }
        catch (Exception e) { // Default, if we don't exactly know what can be the exception.
            System.out.println("Error: " + e);
        }
    }
}
                    </code>
                </pre>

            </div>
            <div class="in">
                <h3>Multiple Try with Multiple Catch</h3>
                <p>Exception handling in Java is a critical aspect of ensuring that your programs can gracefully handle
                    unexpected situations. Java provides several mechanisms for handling exceptions, including:</p>
                <ul>
                    <li>Automatic handling by the Java Virtual Machine (JVM)</li>
                    <li>Using the <code>try/catch</code> block</li>
                    <li>Using <code>try</code> with multiple <code>catch</code> blocks</li>
                </ul>
                <p>Let's dive deeper into the concept of multiple <code>try</code> with multiple <code>catch</code>
                    blocks.</p>

                <h4>Objectives of Try and Catch Blocks:</h4>
                <p>When dealing with exceptions, <code>try</code> and <code>catch</code> blocks serve two main
                    objectives:</p>
                <ol>
                    <li>Provide user-defined error messages for better diagnostics.</li>
                    <li>Allow the continuation of code execution even in the presence of exceptions. This ensures that
                        other parts of the code can still run.</li>
                </ol>

                <p>There is no strict limitation on the number of <code>try</code> and <code>catch</code> blocks you can
                    use in your code. However, it's essential to consider code complexity as it may increase with a
                    higher number of exception-handling blocks.</p>

                <h4>Continuation of Program:</h4>
                <ul>
                    <li>Continuation of program flow is achieved using multiple <code>try</code> and <code>catch</code>
                        blocks.</li>
                    <li>This approach is particularly useful when you know the class names of the exceptions you expect
                        to handle.</li>
                    <li>Deciding how many <code>try</code> and <code>catch</code> blocks to use can be based on grouping
                        the code into logical sections. Here are three common groups:</li>
                    <ul>
                        <li>Input processing</li>
                        <li>Calculation</li>
                        <li>Display</li>
                    </ul>
                    <p>Both the input and calculation sections have a higher chance of encountering exceptions, so it's
                        beneficial to place separate <code>try</code> and <code>catch</code> blocks for each group.</p>
                </ul>

                <h4>Example:</h4>
                <pre>
        <code>
import java.util.Scanner;

class ExceptionHandlingExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 
        System.out.println("Enter two numbers: ");
        try { // input
            v1 = sc.nextInt();
            v2 = sc.nextInt();
        } catch (NumberFormatException e1) {
            System.out.println("Error due to wrong input");
        }

        try { // calculation
            ans = v1 / v2;
            System.out.println("Division Result: " + ans);
        } catch (ArithmeticException e2) {
            System.out.println("Error due to division by zero");
        }

        try { // independent calculation
            sub = v1 - v2;
            System.out.println("Subtraction Result: " + sub);
        } catch (ArithmeticException e3) {
            System.out.println("Error due to subtraction");
        }
    }
}
        </code>
    </pre>

                <ul>
                    <li>It's a good practice to declare all variables before the first <code>try</code> block to ensure
                        they have a broader scope.</li>
                    <li>If you don't know the specific exception class name, you can use the generic
                        <code>Exception</code> class to catch and handle exceptions.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Nested Try-Catch Blocks in Java</h3>
                <p>In Java, when dealing with complex situations that involve multiple layers of exception handling,
                    nested `try` and `catch` blocks can be employed. These blocks allow for a finer level of detail in
                    handling exceptions at different levels of your code.</p>

                <h4>Understanding Nested Try-Catch Blocks:</h4>
                <p>Nested `try` and `catch` blocks involve placing one or more `try` blocks inside another. This
                    approach is useful when certain operations within a `try` block can themselves trigger exceptions
                    that need to be handled separately.</p>

                <h4>Example:</h4>
                <pre>
                    <code>
try {
    // Outer try block
    // Perform some operations
    try {
        // Inner try block
        // Perform more specific operations
    } catch (SpecificException e) {
        // Handle the specific exception from the inner block
    }
    // Continue with operations
} catch (GeneralException e) {
    // Handle a more general exception from the outer block
}
                    </code>
                </pre>

                <p>In the example above, the outer `try` block handles more general exceptions, while the inner `try`
                    block handles exceptions specific to its operations. This way, you can provide specialized
                    error-handling for different parts of your code.</p>

                <h4>Nesting for Specificity:</h4>
                <p>The key benefit of nested `try` and `catch` blocks is the ability to address specific exceptions
                    without affecting the entire code block. It allows you to provide more specific error-handling
                    strategies at different levels of your code.</p>

                <h4>Caution:</h4>
                <p>While nesting can be powerful for precise error handling, it can also make your code more complex.
                    It's essential to strike a balance between specificity and code readability. Avoid excessive
                    nesting, which can lead to code that's challenging to maintain.</p>

                <h4>Best Practices:</h4>
                <ul>
                    <li>Use nested `try` and `catch` blocks when there's a genuine need to handle exceptions at
                        different levels with varying levels of detail.</li>
                    <li>Keep your code organized and maintainable by providing clear comments and documentation.</li>
                    <li>Avoid deeply nested blocks when possible; instead, break down your code into smaller, more
                        manageable functions or methods.</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <button class='ac'>Example program </button>
                    <div class='panel'>
                        <pre>
                            <code>
import java.util.Scanner;

public class NestedTryCatchExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 

        try {
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();

            try {
                ans = v1 / v2;
                System.out.println("Division Result: " + ans);
            } catch (ArithmeticException e2) {
                System.out.println("Error: Division by zero is not allowed.");
            }

            try {
                sub = v1 - v2;
                System.out.println("Subtraction Result: " + sub);
            } catch (ArithmeticException e3) {
                System.out.println("Error: Subtraction operation resulted in an error.");
            }
        } catch (java.util.InputMismatchException e1) {
            System.out.println("Error: Invalid input. Please enter valid numbers.");
        }
    }
}
                            </code>
                        </pre>
                    </div>
                </div>
            </div>
        </div>
        <div class="wh">
            <h2>Understanding the "throw" Keyword in Java</h2>
            <ul>
                <li>In Java, the "throw" keyword is a mechanism used to create and raise custom exceptions during
                    program execution.</li>
                <li>User-Defined Exceptions (UDEs) are exceptions that programmers create to handle specific conditions
                    or situations within their code.</li>
                <li>While Java provides built-in exceptions for common error scenarios (e.g.,
                    ArrayIndexOutOfBoundsException or InputMismatchException), the "throw" keyword allows developers to
                    define and signal custom exceptions tailored to their application's requirements.</li>
                <li>For example, consider a situation where age verification is needed in a program. If a condition like
                    "age < 18" is met, the programmer can use the "throw" keyword to raise a custom exception,
                        specifying how this condition should be handled within the code.</li>
                <li>Similarly, if a program encounters an unexpected odd result that doesn't cause a runtime error but
                    needs special attention, the "throw" keyword can be employed to create a custom exception and define
                    how this unique situation should be managed.</li>
                <li>Essentially, the "throw" statement is used to communicate exceptional conditions or custom-defined
                    situations within the program, enabling developers to implement specific handling procedures for
                    these scenarios.</li>
            </ul>
            <div class="in">
                <h3>Handling the 'Divide by Zero' Exception Using the "throw" Keyword without Try-Catch Blocks</h3>
                <pre>
                    <code>
import java.util.*;

class Test
{
    public static void main(String[] args)
    {
        int ans = 0;
        int v1 = 10;
        int v2 = 0;
        if(v2 == 0)
        {
            throw new ArithmeticException("Division by zero is not allowed.");
            // Alternatively, you can create an ArithmeticException object and then throw it:
            // ArithmeticException obj = new ArithmeticException("Division by zero is not allowed.");
            // throw obj;
        }
        else 
        {
            ans = v1 / v2;
        }
        System.out.println(ans);
    }
}
                </code>
            </pre>
                <p>In the example above, we used the concept of anonymous objects.</p>
                <pre>
                    <code>
class A
{
    public void sum(int v1)
    {
        System.out.println(v1 + 10);
    }
}
public static void main(String[] args) 
{
    (new A()).sum(5);
    // This is similar to the following:
    // A obj = new A();
    // obj.sum(5);
}
                </code>
            </pre>
            </div>
            <div class="in">
                <h3>Throwing Our Own Custom Exception</h3>
                <p>Example: If a number is even, throw a custom exception.</p>
                <pre>
    <code>
class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            throw new MyException("Number is even.");
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
    </code>
</pre>
                <h3>Steps to Create and Throw Our Custom Exception</h3>
                <ol>
                    <li>Inherit from the "Exception" class to create our custom exception class.</li>
                    <li>Create a constructor for the custom exception class.</li>
                </ol>
                <pre>
                    <code>
// Step 1: Inheriting from Exception class to create our custom exception class
class MyException extends Exception
{
    // Step 2: Creating a constructor that takes a custom error message
    MyException(String str)
    {
        super(str);
    }
}

class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            MyException customException = new MyException("Number is even.");
            System.out.println(customException.getMessage());
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
                    </code>
                </pre>
                <ul>
                    <li>the getMessage method is a standard method provided by the Throwable class in Java, which is the
                        superclass of all exceptions, including custom exceptions. This method allows you to retrieve
                        the error message associated with an exception.
                        <br>we could also simply do the following &darr;
                    </li>
                </ul>
                <pre>
        <code>
System.out.println(customException);
        </code>
    </pre>

            </div>
            <div class="in">
                <h3>Understanding the 'super' Keyword in Java</h3>
                <p><strong>Definition of the 'super' Keyword:</strong></p>

                <p>In Java, the 'super' keyword is a special word used to refer to the <em>superclass</em> or the
                    <em>parent
                        class</em> of the current class. It helps you access members (like variables or methods) from
                    the
                    superclass, especially when there are similarly named members in both the superclass and the
                    subclass.
                    The 'super' keyword is primarily used to handle conflicts and interact with superclass members in an
                    inheritance hierarchy.
                </p>

                <p><strong>Simple Example for Beginners:</strong></p>

                <p>Let's illustrate the 'super' keyword with a straightforward example involving two classes: a
                    superclass
                    called <code>Animal</code> and a subclass called <code>Dog</code>. We'll show how 'super' can be
                    used to
                    access the constructor and method of the superclass.</p>

                <pre>
                <code>
<!-- Superclass -->
class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void sound() {
        System.out.println("Animal makes a sound");
    }
}

<!-- Subclass -->
class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        <!-- Using 'super' to call the superclass constructor -->
        super(name);
        this.breed = breed;
    }

    void sound() {
        <!-- Using 'super' to call the superclass method -->
        super.sound();
        System.out.println("Dog barks");
    }
}

<!-- Main Program -->
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Labrador");
        System.out.println("Name: " + myDog.name);
        System.out.println("Breed: " + myDog.breed);
        myDog.sound();
    }
}
            </code>
        </pre>

                <p>In this example, 'super' is used within the <code>Dog</code> constructor to call the constructor of
                    the
                    <code>Animal</code> superclass, passing the <code>name</code> parameter. It's also used within the
                    <code>sound</code> method of the <code>Dog</code> class to call the <code>sound</code> method of the
                    <code>Animal</code> class before adding specific behavior for the <code>Dog</code> class.
                </p>

                <p>When you run this program, it demonstrates how 'super' allows you to use and extend functionality
                    from
                    the superclass when creating subclasses, promoting code reusability and organization in
                    object-oriented
                    programming.</p>
            </div>
        </div>
        <div class="wh">
            <h2>throws keyword</h2>
            <ul>
                <li><strong>Proper Definition:</strong> The 'throws' keyword is used to indicate exceptions that may
                    occur in a program. For example, we know that the 'public static void main()' function might throw
                    'ArrayIndexOutOfBoundsException' and 'NullPointerException'.</li>
                <li><strong>'throws' Usage:</strong> 'throws' is used along with a method when we are defining it.</li>
                <li><strong>Benefits:</strong> It makes our exception handling easier.</li>
                <li><strong>Usage with Any Method:</strong> It can be used with any method, including 'main'.</li>
                <li><strong>Usage in the Thread Class:</strong> It is also used in the 'Thread' class (we will learn
                    more about this later).
                    <br><code>Thread.sleep(1000);</code> might throw 'IOException'. If we use this, we will get an error
                    because Java gives warnings before many classes and suggests good exception handling practices. So,
                    only those who are familiar with exception handling should use these classes.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
    <code>
public void myMethod() throws ExceptionType1, ExceptionType2 
{
    // Method body
}
    </code>
</pre>
            <ul>
                <li><strong>Expertise and Diagnosis:</strong> If we do not specify all the exception classes, it
                    indicates that we may not be experts, and our error diagnosis skills may be weak.</li>
                <li><strong>Efficiency in Searching:</strong> Mentioning all the exception classes helps save time in
                    Java error handling.</li>
            </ul>
            <pre>
                <code>
public void myMethod() throws Exception // Parent class; mentioning this may consume more memory.
{
    // Method implementation
}
                </code>
            </pre>
            <ul>
                <li><strong>Throwing an Exception Outside the Method:</strong> The 'throws' clause is used to indicate
                    that a method may throw an exception.</li>
                <li><strong>'throws' Clause Usage:</strong> The 'throws' clause is used when declaring a method.</li>
            </ul>
            <div class="in">
                <h3>throw vs. throws</h3>
                <ol>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is used to explicitly throw an exception
                                object
                                within a method. This means that when a specific exceptional condition is encountered
                                within the
                                method, you can use 'throw' to create and throw an exception object, indicating that
                                something
                                has gone wrong.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() {
    throw new ArithmeticException();
}
                                    </code>
                                </pre>
                                In this example, we throw an 'ArithmeticException' explicitly, signaling that an
                                arithmetic
                                error has occurred.
                            </li>
                            <li><strong>throws:</strong> The 'throws' keyword, on the other hand, is used in a method's
                                signature to declare that the method may potentially throw one or more specific
                                exceptions. This
                                declaration allows the method to pass the responsibility of handling these exceptions to
                                its
                                caller. When a method is declared with 'throws,' it means that the method is warning the
                                caller
                                that it might encounter certain exceptions during execution, and the caller needs to
                                handle
                                them.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() throws ArithmeticException {
    // Method code
}
                                    </code>
                                </pre>
                                Here, 'throws' indicates that this method may throw an 'ArithmeticException,' and it's
                                the
                                caller's responsibility to handle it if necessary.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is always used inside the method body to
                                explicitly
                                throw an exception. It is typically used when an exceptional condition is detected
                                within the
                                method, and you want to trigger an exception immediately.
                            </li>
                            <li><strong>throws:</strong> In contrast, the 'throws' keyword is always used in the
                                method's
                                signature to declare exceptions that the method might propagate to the caller. It
                                doesn't create
                                or throw exception instances within the method but rather specifies the potential
                                exceptions the
                                method can raise.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> With 'throw,' you can throw only one exception at a time. Each
                                'throw'
                                statement is responsible for throwing a specific exception.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
throw new ArithmeticException();
                                    </code>
                                </pre>
                                This line throws an 'ArithmeticException.'
                            </li>
                            <li><strong>throws:</strong> With 'throws,' you can declare and handle multiple exceptions
                                simultaneously. This is especially useful when a method can potentially encounter
                                different
                                types of exceptions.
                                <br><strong>Example:</strong>
                                <pre>
                                    <code>
void m1() throws ArithmeticException, ArrayIndexOutOfBoundsException {
    // Method code
}
                                    </code>
                                </pre>
                                Here, the 'throws' keyword declares that 'm1' may throw either an 'ArithmeticException'
                                or an
                                'ArrayIndexOutOfBoundsException.'
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul>
                            <li><strong>throw:</strong> The 'throw' keyword is followed by an instance of an exception
                                class,
                                indicating that you are creating and throwing a specific exception object. This allows
                                you to
                                customize the exception with details about the error.
                            </li>
                            <li><strong>throws:</strong> In contrast, the 'throws' keyword is followed by the names of
                                exception
                                classes. It doesn't create or throw exception instances directly but rather informs the
                                caller
                                of the potential exceptions that may be thrown by the method. The caller is then
                                responsible for
                                handling these exceptions as needed.
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>
        <div class="wh">
            <h2>finally Block</h2>
            <ul>
                <li><strong>Optional:</strong> The <code>finally</code> block is an optional part of Java's exception
                    handling mechanism.</li>
                <li><strong>Mandatory Execution:</strong> It contains code that needs to be executed regardless of
                    whether an exception was thrown or not. This makes it suitable for tasks like resource cleanup,
                    closing files, or releasing system resources.</li>
                <li><strong>Always a Part of Try and Catch Blocks:</strong> The <code>finally</code> block should always
                    be associated with a <code>try</code> and <code>catch</code> block. It ensures that the code within
                    the <code>finally</code> block is executed after the <code>try</code> block, and potentially the
                    <code>catch</code> block, no matter what happens in the preceding code.
                </li>
                <li><strong>Cannot Be Used Without Try and Catch:</strong> You cannot use the <code>finally</code> block
                    on its own; it must be used in conjunction with a <code>try</code> and <code>catch</code> block.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
                <code>
try {
    // Code that may throw exceptions
}
catch (Exception e) {
    // Exception handling code
}
finally {
    // Code that always executes, whether or not an exception was thrown
}
                </code>
            </pre>

        </div>
        <div class="wh">
            <h2>Checked and Unchecked Exceptions</h2>
            <p>In Java, exceptions are classified into two main categories: checked exceptions and unchecked exceptions.
                These distinctions help developers handle and manage exceptions effectively in their code.</p>

            <h3>Checked Exceptions</h3>
            <ul>
                <li><strong>Definition:</strong> Checked exceptions, also known as compile-time exceptions, are
                    exceptions that the Java compiler mandates to be caught or declared in the code. This means that if
                    a method can potentially throw a checked exception, it must be either caught using a try-catch block
                    or declared using the 'throws' keyword in the method signature.</li>
                <li><strong>Examples:</strong> Common checked exceptions include 'IOException', 'FileNotFoundException',
                    and 'SQLException'. These exceptions typically occur in situations where external resources or
                    external systems are involved, and the developer needs to handle potential issues gracefully.</li>
                <li><strong>Handling:</strong> Developers are required to handle checked exceptions explicitly in their
                    code, either by using try-catch blocks to catch and process the exception or by declaring the
                    exception using 'throws' in the method signature.</li>
            </ul>

            <h3>Unchecked Exceptions</h3>
            <ul>
                <li><strong>Definition:</strong> Unchecked exceptions, also known as runtime exceptions, are exceptions
                    that do not require explicit handling using try-catch blocks or 'throws' declarations. These
                    exceptions can be caught and handled, but it's not mandatory by the compiler.</li>
                <li><strong>Examples:</strong> Common unchecked exceptions include 'NullPointerException',
                    'ArrayIndexOutOfBoundsException', and 'ArithmeticException'. These exceptions usually result from
                    programming errors or invalid operations and are not related to external factors.</li>
                <li><strong>Handling:</strong> While unchecked exceptions can be caught and handled if desired,
                    developers are not required to do so. It is often recommended to address the root cause of these
                    exceptions during development and not rely solely on catching them in code.</li>
            </ul>

            <p>Understanding the difference between checked and unchecked exceptions is crucial for effective exception
                handling in Java. Checked exceptions help ensure that developers handle potential issues that may arise
                when interacting with external resources, while unchecked exceptions primarily address programming
                errors and invalid operations.</p>
        </div>
        <div class="wh">
            <h2>Multithreading in Java</h2>
            <p>Before delving into multithreading, it's essential to understand the concept of multitasking in
                computing.</p>

            <ul>
                <li><strong>Multitasking:</strong> Multitasking is the concurrent execution of multiple tasks or
                    processes by a computer's operating system. It allows a computer to perform multiple activities
                    simultaneously.</li>
                <li><strong>Types of Multitasking:</strong> Multitasking can be categorized into two main types:</li>
                <ol>
                    <li><strong>Process-Based Multitasking:</strong> In process-based multitasking, multiple independent
                        processes run concurrently. Each process has its own memory space and resources, and they can
                        communicate with each other through inter-process communication (IPC) mechanisms.
                        <br><strong>Example:</strong> Imagine a computer running a web browser, a word processor, and a
                        music player as separate processes. These processes can run concurrently, allowing the user to
                        browse the web, edit documents, and listen to music simultaneously.
                    </li>
                    <li><strong>Thread-Based Multitasking:</strong> In thread-based multitasking, multiple threads of a
                        single process run concurrently. Threads within the same process share the same memory space and
                        resources, which makes communication between them easier but also requires careful
                        synchronization to avoid conflicts.
                        <br><strong>Example:</strong> Consider a word processing application that uses threads to
                        simultaneously check for spelling errors, format text, and save the document in the background
                        while the user continues typing. These threads work together to enhance the user experience
                        without creating separate processes.
                    </li>
                </ol>
            </ul>

            <p>Now, let's explore the concept of a "thread" in more detail:</p>

            <h3>Threads in Computing</h3>
            <p>A thread is the smallest unit of execution within a program. It represents a sequence of instructions
                that can be scheduled and executed independently by the computer's CPU. Threads within a process share
                the same memory space and resources, allowing them to work together to accomplish tasks concurrently.
            </p>

            <p>Threads are commonly used to perform multiple operations simultaneously, enhance program responsiveness,
                and efficiently utilize modern multi-core processors.</p>

            <p>Java provides extensive support for thread-based multitasking through its multithreading capabilities.
                Understanding threads and multithreading is crucial for building responsive and efficient Java
                applications that can perform multiple tasks concurrently.</p>


            <p>Java provides extensive support for thread-based multitasking through its multithreading capabilities.
                Understanding multithreading is crucial for building responsive and efficient Java applications that can
                perform multiple tasks concurrently.</p>

            <div class="in">
                <h3>What is Multithreading?</h3>
                <p>Multithreading is a concurrent execution process where multiple threads run independently at the same
                    time without dependency on each other. In Java, it allows you to execute multiple threads within a
                    single process, enhancing program performance and responsiveness by making efficient use of the CPU.
                </p>
                <ul>
                    <li>Multithreading Saves Time and Enhances Performance:</li>
                    <p>Multithreading is used to save time and increase the performance of Java applications. By
                        dividing tasks into multiple threads, a program can execute multiple operations simultaneously,
                        taking advantage of modern multi-core processors.</p>

                    <li>Applications in Animation and Game Development:</li>
                    <p>Java is commonly used in animation and game development, where multithreading allows multiple
                        animated characters or game elements to appear on the screen simultaneously. Each character or
                        element can be controlled by a separate thread, enabling concurrent and independent actions.</p>
                </ul>
            </div>

            <div class="in">
                <h3>What is a Thread?</h3>
                <p>A thread is a fundamental unit of execution in a program. It represents a sequence of instructions
                    that can run independently and concurrently with other threads. In Java, threads are instances of
                    the pre-defined `Thread` class, available in the `java.lang` package.</p>
                <ul>
                    <li>Basic Unit of CPU and Independent Execution:</li>
                    <p>Threads are often referred to as the basic units of a CPU because they can be scheduled and
                        executed independently. Each thread shares the same memory space and resources within a process,
                        enabling them to perform tasks simultaneously.</p>
                </ul>
            </div>

            <div class="in">
                <h3>How to Create Threads in Java?</h3>
                <p>In Java, you can create threads in two main ways:</p>
                <ol>
                    <li>By Extending the Thread Class:</li>
                    <p>You can create a new thread by extending the `Thread` class and overriding its `run()` method.
                        This approach allows you to define the thread's behavior within the `run()` method.</p>
                    <li>By Implementing the Runnable Interface:</li>
                    <p>Another way to create threads is by implementing the `Runnable` interface. This approach
                        separates the thread's behavior from the thread object itself. You need to provide the
                        implementation of the `run()` method in a separate class that implements `Runnable` and then
                        create a `Thread` object that executes the `Runnable` instance.</p>
                </ol>
            </div>

            <div class="in">
                <h3>Multitasking vs. Multithreading</h3>
                <p>It's important to distinguish between multitasking and multithreading:</p>
                <ul>
                    <li>Multitasking:</li>
                    <p>Multitasking refers to the concurrent execution of multiple processes or applications by the
                        operating system. These processes can be entirely independent and may or may not share
                        resources.</p>
                    <li>Multithreading:</li>
                    <p>Multithreading, on the other hand, involves concurrent execution within a single process.
                        Multiple threads within the same process share the same memory space and resources, allowing
                        them to work together to achieve parallelism and perform tasks simultaneously.</p>
                </ul>
            </div>
            <div class="in">
                <h3>Defining Threads by Extending the Thread Class</h3>
                <ul>
                    <li><strong>Introduction:</strong></li>
                    <p>In Java, you can create threads by extending the `Thread` class. This approach allows you to
                        define your thread's behavior by overriding the `run()` method. Threads created using this
                        method are also known as "child threads," and they run concurrently with the main thread of the
                        program.</p>
                </ul>

                <pre>
                    <code>
class A extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}

class B {
    public static void main(String[] args) {
        A t = new A();
        t.start(); // Starting the child thread

        // Code below is part of the main thread, while the code above is part of the child thread
        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}
                    </code>
                </pre>

                <ul>
                    <li><strong>The `run` Method in Thread Class:</strong></li>
                    <p>The `run` method is already defined in the `Thread` class, but you can override it to provide
                        your custom implementation. When you start a thread, the JVM automatically calls its `run`
                        method.</p>

                    <li><strong>Concurrency:</strong></li>
                    <p>When you run the program, the order in which the threads run is not guaranteed. Each time you
                        execute the program, the output sequence may differ. However, what is certain is that both the
                        main thread and the child thread run concurrently.</p>
                </ul>

                <p>If you want to introduce a delay between the output, you can use the `Thread.sleep(1000)` method.
                    However, you need to handle exceptions since `Thread.sleep()` can throw an `InterruptedException`.
                    Here's an example:</p>

                <pre>
                    <code>
class A extends Thread {
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Hello");
                Thread.sleep(1000); // Pause for 1 second
            }
        } catch (InterruptedException e) {
            // Handle the interrupted exception
        }
    }
}

class B {
    public static void main(String[] args) throws InterruptedException {
        A t = new A();
        t.start(); // Starting the child thread

        for (int i = 1; i <= 5; i++) {
            System.out.println("Hello");
        }
    }
}
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Defining Threads Using the Runnable Interface</h3>
                <ul>
                    <li><strong>Introduction:</strong></li>
                    <p>In Java, you can create threads by implementing the `Runnable` interface. This approach provides
                        more flexibility compared to extending the `Thread` class because it allows you to separate the
                        thread's behavior from the thread object. Threads created using the `Runnable` interface are
                        also known as "runnable threads."</p>
                </ul>

                <p><strong>Syntax to Define a Thread:</strong></p>
                <pre>
    <code>
class A implements Runnable {
    public void run() {
        // Define the thread's job or task here
    }
}

class B {
    public static void main(String[] args) {
        A obj = new A();
        // obj.start(); // This won't work because we need a Thread object to start a thread
        Thread t = new Thread(obj); // Create a Thread object with obj as a reference
        t.start(); // Now the thread will execute the run() method defined in class A
    }
}
    </code>
</pre>

                <p><strong>Example:</strong></p>
                <pre>
    <code>
class A implements Runnable {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("My child Thread");
        }
    }
}

class B {
    public static void main(String[] args) {
        A r = new A(); // Create an instance of class A, which implements Runnable

        Thread t = new Thread(r); // Create a Thread object with the Runnable instance r
        t.start(); // Start the child thread

        // The main thread is responsible for running the following code
        for (int i = 1; i <= 5; i++) {
            System.out.println("My main Thread");
        }
    }
}
    </code>
</pre>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Reference</p>
        <ul>
            <li><a href="https://www.youtube.com/playlist?list=PLqleLpAMfxGARB5Xa4Baa0lpRlUvZVJH8" target="_blank"
                    class="ba">Multithreading playlist &neArr;</a></li>
        </ul>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
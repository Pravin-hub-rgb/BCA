<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exception Handling & Multithread Programming</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
    <style>
        body {
            background: #0f0c29;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* Chrome 10-25, Safari 5.1-6 */
            background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
            color: white;
        }
    </style>
</head>

<body>
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#" class="link"></a>
        <div class="botbut">
            <a href="" class="link">Next Topic &rarr;</a>
            <a href="" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Exception Handling & Multithread Programming</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Exception Handling & Multithread Programming</h1>
        <div class="wh">
            <h2>Exceptions in Java</h2>
            <p>
                In Java, exceptions are events that occur during the execution of a program that disrupt the normal flow
                of instructions. Exceptions can occur for various reasons, such as division by zero, trying to access an
                array element that doesn't exist, or attempting to open a file that doesn't exist.
                <br>
                In Java, exceptions are a vital concept used to manage and handle runtime errors gracefully. They play a
                crucial role in achieving the goal of a robust programming language. Let's delve deeper into the world
                of exceptions:
            </p>
            <ul>
                <li><strong>Runtime Error Management:</strong> Exceptions are primarily used to tackle runtime errors.
                    These errors can occur during program execution and might disrupt the normal flow of the
                    application.</li>
                <li><strong>Robust Language:</strong> Java's exception handling mechanism is one of the reasons it's
                    considered a robust language. It allows programs to continue running smoothly even in the presence
                    of errors.</li>
                <li><strong>Flow Control:</strong> Exception handling helps maintain the flow of a program. It ensures
                    that the program doesn't terminate abruptly when errors occur but instead gracefully handles them.
                </li>
                <li><strong>General Errors:</strong> In a broader sense, exceptions represent various types of runtime
                    errors, making it easier to identify and address issues.</li>
            </ul>
        </div>

        <div class="wh">
            <h2>Exception Handling</h2>
            <p>
                Exception handling is a fundamental aspect of Java programming that empowers developers to deal with
                runtime errors systematically. Java provides built-in support for exception handling, making it easier
                to write robust and reliable code. Here's a closer look at exception handling in Java:
            </p>
            <ul>
                <li><strong>Automatic Handling:</strong> Java has a built-in mechanism for handling exceptions. When an
                    exception occurs, Java automatically looks for an appropriate handler to manage the situation.</li>
                <li><strong>Example:</strong> Consider this example where an attempt to divide by zero results in an
                    exception. Java's automatic handling ensures that the program doesn't crash but rather reports the
                    issue.</li>
            </ul>
            <pre>
                <code>
int x = 10; 
int ans = x / 0; // Automatically handled by Java
String s1 = null; // also an exception
                </code>
            </pre>
            <ul>
                <li><strong>Preventing Abnormal Termination:</strong> Exception handling prevents programs from
                    abnormally terminating due to runtime errors. This is especially crucial when creating software, as
                    unhandled exceptions can lead to unpredictable outcomes, including system crashes.</li>
                <li><strong>Essential OOP Feature:</strong> Exception handling is a fundamental feature of
                    object-oriented programming (OOP). It allows developers to encapsulate error-handling logic and
                    maintain clean and modular code.</li>
                <li><strong>Respective Handlers:</strong> In Java, exceptions are handled by methods or classes
                    specifically designed for that purpose. These handlers determine how different types of errors are
                    managed and what error messages to display.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Exception Hierarchy in Java</h2>

            <p>In Java, exceptions are organized into a hierarchy of classes through inheritance. The
                <code>java.lang.Throwable</code> class serves as the root of this hierarchy.
            </p>
            <img src="../../images/exceptioninjava.svg" alt="" class="wb">
            <h3>Throwable (Root Class)</h3>
            <p>The <code>Throwable</code> class is the root class of the exception hierarchy in Java. It has two main
                subclasses:</p>

            <div class="in">
                <h3>Error</h3>
                <p><strong>Error</strong> represents serious, unrecoverable system-level errors, often caused by the JVM
                    or
                    underlying hardware. Developers usually don't handle these exceptions, and they typically lead to
                    program termination.</p>
                <ul>
                    <li><strong>StackOverflowError:</strong> Occurs when the call stack (method call history) exceeds
                        its
                        limit.</li>
                    <li><strong>OutOfMemoryError:</strong> Indicates that the JVM has exhausted available memory.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Exception</h3>
                <p><strong>Exception</strong> represents exceptions that can be caught and handled by application code.
                    It's further divided into two subcategories:</p>

                <div class="wh">
                    <h3>RuntimeException</h3>
                    <p><strong>RuntimeException</strong> represents exceptions that occur at runtime and are typically
                        caused by programming errors. These exceptions don't require explicit handling.</p>
                    <p>Runtime exceptions, also known as unchecked exceptions, are exceptions that occur at runtime and
                        are typically caused by programming errors. These exceptions don't require explicit handling and
                        can be considered bugs in the code. They are subclasses of the RuntimeException class.</p>
                    <p>Various runtime exceptions include:</p>
                    <ul>
                        <li>NullPointerException: Raised when trying to access or manipulate an object reference that is
                            null.</li>
                        <li>IndexOutOfBoundsException:
                            <ul>
                                <li>ArrayIndexOutOfBoundsException: Occurs when attempting to access an array element
                                    with an invalid index.</li>
                                <li>StringIndexOutOfBoundsException: Happens when trying to access a character in a
                                    string with an invalid index.</li>
                            </ul>
                        </li>
                        <li>ArithmeticException: Occurs during mathematical operations like division by zero.</li>
                        <li>NumberFormatException: Raised when trying to convert a string to a numeric type, but the
                            string does not represent a valid numeric value.</li>
                    </ul>
                    <p>Runtime exceptions are typically raised when there are programming errors, such as trying to
                        access null objects, accessing arrays or strings out of bounds, or performing invalid arithmetic
                        operations.</p>
                </div>

                <div class="wh">
                    <h3>Checked Exceptions</h3>
                    <p><strong>Checked Exceptions</strong> represent exceptions that must be explicitly declared and
                        handled in code. These exceptions occur due to external factors and often require actions like
                        input validation or dealing with I/O operations.</p>
                    <p>Checked exceptions are exceptions that must be explicitly declared and handled in code. They are
                        usually subclasses of the Exception class and are typically caused by external factors.</p>
                    <p>Examples of checked exceptions include:</p>
                    <ul>
                        <li>IOException: Raised when an I/O operation (e.g., file reading/writing) encounters an issue.
                        </li>
                        <li>FileNotFoundException: Occurs when trying to access a file that does not exist.</li>
                        <li>SQLException: Raised in database operations when a SQL query or connection fails.</li>
                        <li>ClassNotFoundException: Thrown when a required class is not found at runtime, often related
                            to class loading issues.</li>
                    </ul>
                    <p>Checked exceptions often require explicit handling in code, such as using try-catch blocks, to
                        deal with issues like file not found, database connection problems, or class loading failures.
                    </p>
                </div>
            </div>

            <p>The <code>Throwable</code> class, along with its subclasses <code>Error</code> and
                <code>Exception</code>, forms the foundation of Java's exception handling system. Developers can create
                their custom exceptions by extending the <code>Exception</code> class or one of its subclasses.
            </p>

            <p>When handling exceptions in Java, it's essential to catch specific exceptions based on the situation,
                which allows for more precise error handling and recovery.</p>
        </div>

        <div class="wh">
            <h2>Try & Catch Blocks in Exception Handling</h2>
            <p>
                Exception handling in Java involves several essential keywords, including try, catch, finally, throw,
                and throws. Let's dive into the details of how these keywords play a crucial role in managing
                exceptions:
            </p>
            <ul>
                <li><strong>Keywords Overview:</strong> Exception handling in Java is facilitated by specific keywords:
                    <ul>
                        <li>try</li>
                        <li>catch</li>
                        <li>finally</li>
                        <li>throw</li>
                        <li>throws</li>
                    </ul>
                    These keywords allow programmers to handle exceptions manually, providing more control over the
                    error-handling process.
                </li>
                <li><strong>Optionality of Keywords:</strong> Among these keywords, finally, throw, and throws are
                    optional. You can choose to use them based on the specific requirements of your code.
                    <ul>
                        <li>finally: This block contains code that executes regardless of whether an exception occurs.
                            It's often used for cleanup operations.</li>
                        <li>throw: It's used to explicitly throw an exception within your code when certain conditions
                            are met.</li>
                        <li>throws: This keyword is used in method declarations to indicate that the method may throw a
                            particular type of exception. It's particularly useful when defining custom exception
                            classes.</li>
                    </ul>
                </li>
                <li><strong>Levels of Exception Handling:</strong> Exception handling can be categorized into different
                    levels:
                    <ul>
                        <li><strong>Level 1:</strong> At this level, Java's default error-handling mechanisms come into
                            play. The JVM handles these exceptions without programmer intervention.</li>
                        <li><strong>Level 2:</strong> The try and catch blocks are used by programmers to handle
                            exceptions more specifically. It allows developers to define their own logic for dealing
                            with exceptions.</li>
                        <li><strong>Level 3:</strong> Finally, throw, and throws come into play at this level. The
                            finally block ensures essential cleanup code is executed, throw is used to explicitly raise
                            exceptions, and throws is employed for specifying potential exceptions that a method may
                            throw.</li>
                    </ul>
                </li>
                <li><strong>Effectiveness of Try, Catch, and Throws:</strong> In practice, approximately 90% of
                    exceptions are effectively handled using try, catch, and throws blocks. These mechanisms offer a
                    robust approach to exception management.</li>
                <li><strong>Best Practice:</strong> Handling exceptions with 'throws' is considered a best practice,
                    especially in situations where a programmer possesses in-depth knowledge of Java. It allows for more
                    precise and controlled exception handling, particularly when dealing with user-defined exceptions.
                </li>
                <li><strong>Usage of 'throws':</strong> The 'throws' keyword is primarily used for declaring
                    user-defined exceptions in method signatures. It indicates that a method may throw specific types of
                    exceptions, providing valuable information to other developers using the method.</li>
            </ul>
            <div class="in">
                <h3>Handling Exceptions by the User Using Try and Catch Blocks</h3>
                <p>Example &darr;</p>
                <pre><code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        try {
            ans = v1 / v2;
            System.out.println(ans);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        }
    }
}
                </code></pre>
                <ul>
                    <li>In the above code, when we provide v2 = 0, we will get a 'DivideByZero' error, which is
                        correctly handled by Java.</li>
                    <li>As we can see, the program is correct, but when v2 = 0, the code after that won't get executed
                        because Java doesn't handle it, and that's why it gets terminated.</li>
                    <li>Now, if we want to handle it by the user, we will use the try-catch block.
                        <ul>
                            <li>Try block: Used for handling exceptions by the user. In the try block, we put the code
                                that might generate an exception. If an exception is generated by the try block, it
                                switches to the catch block, which is the exception handler.</li>
                        </ul>
                    </li>
                    <li>If we are not sure which part will give an exception, then put the whole code inside the try
                        block. Only the content that might generate an exception will be part of the try block, not any
                        method.</li>
                </ul>
                <pre><code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        try {
            Scanner sc = new Scanner(System.in);
            int v1, v2, ans;
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();
            ans = v1 / v2;
            System.out.println(ans);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        }
    }
}
                </code></pre>
                <ul>
                    <li>Remember, try without catch won't work.</li>
                    <li>If we want to find which line caused the error and get its name, we can do the following:</li>
                </ul>
                <pre><code>
catch (Exception e) {
    System.out.println("Error occurred at line: " + e.getStackTrace()[0].getLineNumber());
    System.out.println("Error message: " + e.getMessage());
}
// This provides full details about the error.
                </code></pre>

            </div>
            <div class="in">
                <h3>Try with Multiple Catch Blocks</h3>
                <ul>
                    <li>We can even put a try block inside another try block.</li>
                </ul>
                <pre>
                    <code>
import java.util.Scanner;

class Exp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans;
        System.out.println("Enter two numbers: ");
        v1 = sc.nextInt();
        v2 = sc.nextInt();
        try {
            ans = v1 / v2;
            System.out.println(ans);
        }
        catch (NumberFormatException e1) {
            System.out.println("Exception due to wrong input datatype");
        }
        catch (ArithmeticException e2) {
            System.out.println("Exception due to dividing by zero");
        }
        catch (Exception e) { // Default, if we don't exactly know what can be the exception.
            System.out.println("Error: " + e);
        }
    }
}
                    </code>
                </pre>

            </div>
            <div class="in">
                <h3>Multiple Try with Multiple Catch</h3>
                <p>Exception handling in Java is a critical aspect of ensuring that your programs can gracefully handle
                    unexpected situations. Java provides several mechanisms for handling exceptions, including:</p>
                <ul>
                    <li>Automatic handling by the Java Virtual Machine (JVM)</li>
                    <li>Using the <code>try/catch</code> block</li>
                    <li>Using <code>try</code> with multiple <code>catch</code> blocks</li>
                </ul>
                <p>Let's dive deeper into the concept of multiple <code>try</code> with multiple <code>catch</code>
                    blocks.</p>

                <h4>Objectives of Try and Catch Blocks:</h4>
                <p>When dealing with exceptions, <code>try</code> and <code>catch</code> blocks serve two main
                    objectives:</p>
                <ol>
                    <li>Provide user-defined error messages for better diagnostics.</li>
                    <li>Allow the continuation of code execution even in the presence of exceptions. This ensures that
                        other parts of the code can still run.</li>
                </ol>

                <p>There is no strict limitation on the number of <code>try</code> and <code>catch</code> blocks you can
                    use in your code. However, it's essential to consider code complexity as it may increase with a
                    higher number of exception-handling blocks.</p>

                <h4>Continuation of Program:</h4>
                <ul>
                    <li>Continuation of program flow is achieved using multiple <code>try</code> and <code>catch</code>
                        blocks.</li>
                    <li>This approach is particularly useful when you know the class names of the exceptions you expect
                        to handle.</li>
                    <li>Deciding how many <code>try</code> and <code>catch</code> blocks to use can be based on grouping
                        the code into logical sections. Here are three common groups:</li>
                    <ul>
                        <li>Input processing</li>
                        <li>Calculation</li>
                        <li>Display</li>
                    </ul>
                    <p>Both the input and calculation sections have a higher chance of encountering exceptions, so it's
                        beneficial to place separate <code>try</code> and <code>catch</code> blocks for each group.</p>
                </ul>

                <h4>Example:</h4>
                <pre>
        <code>
import java.util.Scanner;

class ExceptionHandlingExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 
        System.out.println("Enter two numbers: ");
        try { // input
            v1 = sc.nextInt();
            v2 = sc.nextInt();
        } catch (NumberFormatException e1) {
            System.out.println("Error due to wrong input");
        }

        try { // calculation
            ans = v1 / v2;
            System.out.println("Division Result: " + ans);
        } catch (ArithmeticException e2) {
            System.out.println("Error due to division by zero");
        }

        try { // independent calculation
            sub = v1 - v2;
            System.out.println("Subtraction Result: " + sub);
        } catch (ArithmeticException e3) {
            System.out.println("Error due to subtraction");
        }
    }
}
        </code>
    </pre>

                <ul>
                    <li>It's a good practice to declare all variables before the first <code>try</code> block to ensure
                        they have a broader scope.</li>
                    <li>If you don't know the specific exception class name, you can use the generic
                        <code>Exception</code> class to catch and handle exceptions.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Nested Try-Catch Blocks in Java</h3>
                <p>In Java, when dealing with complex situations that involve multiple layers of exception handling,
                    nested `try` and `catch` blocks can be employed. These blocks allow for a finer level of detail in
                    handling exceptions at different levels of your code.</p>

                <h4>Understanding Nested Try-Catch Blocks:</h4>
                <p>Nested `try` and `catch` blocks involve placing one or more `try` blocks inside another. This
                    approach is useful when certain operations within a `try` block can themselves trigger exceptions
                    that need to be handled separately.</p>

                <h4>Example:</h4>
                <pre>
                    <code>
try {
    // Outer try block
    // Perform some operations
    try {
        // Inner try block
        // Perform more specific operations
    } catch (SpecificException e) {
        // Handle the specific exception from the inner block
    }
    // Continue with operations
} catch (GeneralException e) {
    // Handle a more general exception from the outer block
}
                    </code>
                </pre>

                <p>In the example above, the outer `try` block handles more general exceptions, while the inner `try`
                    block handles exceptions specific to its operations. This way, you can provide specialized
                    error-handling for different parts of your code.</p>

                <h4>Nesting for Specificity:</h4>
                <p>The key benefit of nested `try` and `catch` blocks is the ability to address specific exceptions
                    without affecting the entire code block. It allows you to provide more specific error-handling
                    strategies at different levels of your code.</p>

                <h4>Caution:</h4>
                <p>While nesting can be powerful for precise error handling, it can also make your code more complex.
                    It's essential to strike a balance between specificity and code readability. Avoid excessive
                    nesting, which can lead to code that's challenging to maintain.</p>

                <h4>Best Practices:</h4>
                <ul>
                    <li>Use nested `try` and `catch` blocks when there's a genuine need to handle exceptions at
                        different levels with varying levels of detail.</li>
                    <li>Keep your code organized and maintainable by providing clear comments and documentation.</li>
                    <li>Avoid deeply nested blocks when possible; instead, break down your code into smaller, more
                        manageable functions or methods.</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <button class='ac'>Example program </button>
                    <div class='panel'>
                        <pre>
                            <code>
import java.util.Scanner;

public class NestedTryCatchExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1, v2, ans, sub; 

        try {
            System.out.println("Enter two numbers: ");
            v1 = sc.nextInt();
            v2 = sc.nextInt();

            try {
                ans = v1 / v2;
                System.out.println("Division Result: " + ans);
            } catch (ArithmeticException e2) {
                System.out.println("Error: Division by zero is not allowed.");
            }

            try {
                sub = v1 - v2;
                System.out.println("Subtraction Result: " + sub);
            } catch (ArithmeticException e3) {
                System.out.println("Error: Subtraction operation resulted in an error.");
            }
        } catch (java.util.InputMismatchException e1) {
            System.out.println("Error: Invalid input. Please enter valid numbers.");
        }
    }
}
                            </code>
                        </pre>
                    </div>
                </div>
            </div>
        </div>
        <div class="wh">
            <h2>Understanding the "throw" Keyword in Java</h2>
            <ul>
                <li>In Java, the "throw" keyword is a mechanism used to create and raise custom exceptions during
                    program execution.</li>
                <li>User-Defined Exceptions (UDEs) are exceptions that programmers create to handle specific conditions
                    or situations within their code.</li>
                <li>While Java provides built-in exceptions for common error scenarios (e.g.,
                    ArrayIndexOutOfBoundsException or InputMismatchException), the "throw" keyword allows developers to
                    define and signal custom exceptions tailored to their application's requirements.</li>
                <li>For example, consider a situation where age verification is needed in a program. If a condition like
                    "age < 18" is met, the programmer can use the "throw" keyword to raise a custom exception,
                        specifying how this condition should be handled within the code.</li>
                <li>Similarly, if a program encounters an unexpected odd result that doesn't cause a runtime error but
                    needs special attention, the "throw" keyword can be employed to create a custom exception and define
                    how this unique situation should be managed.</li>
                <li>Essentially, the "throw" statement is used to communicate exceptional conditions or custom-defined
                    situations within the program, enabling developers to implement specific handling procedures for
                    these scenarios.</li>
            </ul>
            <div class="in">
                <h3>Handling the 'Divide by Zero' Exception Using the "throw" Keyword without Try-Catch Blocks</h3>
                <pre>
                    <code>
import java.util.*;

class Test
{
    public static void main(String[] args)
    {
        int ans = 0;
        int v1 = 10;
        int v2 = 0;
        if(v2 == 0)
        {
            throw new ArithmeticException("Division by zero is not allowed.");
            // Alternatively, you can create an ArithmeticException object and then throw it:
            // ArithmeticException obj = new ArithmeticException("Division by zero is not allowed.");
            // throw obj;
        }
        else 
        {
            ans = v1 / v2;
        }
        System.out.println(ans);
    }
}
                </code>
            </pre>
                <p>In the example above, we used the concept of anonymous objects.</p>
                <pre>
                    <code>
class A
{
    public void sum(int v1)
    {
        System.out.println(v1 + 10);
    }
}
public static void main(String[] args) 
{
    (new A()).sum(5);
    // This is similar to the following:
    // A obj = new A();
    // obj.sum(5);
}
                </code>
            </pre>
            </div>
            <div class="in">
                <h3>Throwing Our Own Custom Exception</h3>
                <p>Example: If a number is even, throw a custom exception.</p>
                <pre>
    <code>
class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            throw new MyException("Number is even.");
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
    </code>
</pre>
                <h3>Steps to Create and Throw Our Custom Exception</h3>
                <ol>
                    <li>Inherit from the "Exception" class to create our custom exception class.</li>
                    <li>Create a constructor for the custom exception class.</li>
                </ol>
                <pre>
                    <code>
// Step 1: Inheriting from Exception class to create our custom exception class
class MyException extends Exception
{
    // Step 2: Creating a constructor that takes a custom error message
    MyException(String str)
    {
        super(str);
    }
}

class Test
{
    public static void main(String[] args)
    {
        int n1 = 10;
        if(n1 % 2 == 0)
        {
            MyException customException = new MyException("Number is even.");
            System.out.println(customException.getMessage());
        }
        else
        {
            System.out.println("Nothing is wrong");
        }
    }
}
                    </code>
                </pre>
                <ul>
                    <li>the getMessage method is a standard method provided by the Throwable class in Java, which is the
                        superclass of all exceptions, including custom exceptions. This method allows you to retrieve
                        the error message associated with an exception.
                        <br>we could also simply do the following &darr;
                    </li>
                </ul>
                <pre>
        <code>
System.out.println(customException);
        </code>
    </pre>

            </div>
            <div class="in">
                <h3>Understanding the 'super' Keyword in Java</h3>
                <p><strong>Definition of the 'super' Keyword:</strong></p>

                <p>In Java, the 'super' keyword is a special word used to refer to the <em>superclass</em> or the
                    <em>parent
                        class</em> of the current class. It helps you access members (like variables or methods) from
                    the
                    superclass, especially when there are similarly named members in both the superclass and the
                    subclass.
                    The 'super' keyword is primarily used to handle conflicts and interact with superclass members in an
                    inheritance hierarchy.
                </p>

                <p><strong>Simple Example for Beginners:</strong></p>

                <p>Let's illustrate the 'super' keyword with a straightforward example involving two classes: a
                    superclass
                    called <code>Animal</code> and a subclass called <code>Dog</code>. We'll show how 'super' can be
                    used to
                    access the constructor and method of the superclass.</p>

                <pre>
                <code>
<!-- Superclass -->
class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void sound() {
        System.out.println("Animal makes a sound");
    }
}

<!-- Subclass -->
class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        <!-- Using 'super' to call the superclass constructor -->
        super(name);
        this.breed = breed;
    }

    void sound() {
        <!-- Using 'super' to call the superclass method -->
        super.sound();
        System.out.println("Dog barks");
    }
}

<!-- Main Program -->
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Labrador");
        System.out.println("Name: " + myDog.name);
        System.out.println("Breed: " + myDog.breed);
        myDog.sound();
    }
}
            </code>
        </pre>

                <p>In this example, 'super' is used within the <code>Dog</code> constructor to call the constructor of
                    the
                    <code>Animal</code> superclass, passing the <code>name</code> parameter. It's also used within the
                    <code>sound</code> method of the <code>Dog</code> class to call the <code>sound</code> method of the
                    <code>Animal</code> class before adding specific behavior for the <code>Dog</code> class.
                </p>

                <p>When you run this program, it demonstrates how 'super' allows you to use and extend functionality
                    from
                    the superclass when creating subclasses, promoting code reusability and organization in
                    object-oriented
                    programming.</p>
            </div>
        </div>
        <div class="wh">
            <h2>throws keyword</h2>
            <ul>
                <li><strong>Proper Definition:</strong> The 'throws' keyword is used to indicate exceptions that may
                    occur in a program. For example, we know that the 'public static void main()' function might throw
                    'ArrayIndexOutOfBoundsException' and 'NullPointerException'.</li>
                <li><strong>'throws' Usage:</strong> 'throws' is used along with a method when we are defining it.</li>
                <li><strong>Benefits:</strong> It makes our exception handling easier.</li>
                <li><strong>Usage with Any Method:</strong> It can be used with any method, including 'main'.</li>
                <li><strong>Usage in the Thread Class:</strong> It is also used in the 'Thread' class (we will learn
                    more about this later).
                    <br><code>Thread.sleep(1000);</code> might throw 'IOException'. If we use this, we will get an error
                    because Java gives warnings before many classes and suggests good exception handling practices. So,
                    only those who are familiar with exception handling should use these classes.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
    <code>
public void myMethod() throws ExceptionType1, ExceptionType2 
{
    // Method body
}
    </code>
</pre>
            <ul>
                <li><strong>Expertise and Diagnosis:</strong> If we do not specify all the exception classes, it
                    indicates that we may not be experts, and our error diagnosis skills may be weak.</li>
                <li><strong>Efficiency in Searching:</strong> Mentioning all the exception classes helps save time in
                    Java error handling.</li>
            </ul>
            <pre>
                <code>
public void myMethod() throws Exception // Parent class; mentioning this may consume more memory.
{
    // Method implementation
}
                </code>
            </pre>
            <ul>
                <li><strong>Throwing an Exception Outside the Method:</strong> The 'throws' clause is used to indicate
                    that a method may throw an exception.</li>
                <li><strong>'throws' Clause Usage:</strong> The 'throws' clause is used when declaring a method.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>finally Block</h2>
            <ul>
                <li><strong>Optional:</strong> The <code>finally</code> block is an optional part of Java's exception
                    handling mechanism.</li>
                <li><strong>Mandatory Execution:</strong> It contains code that needs to be executed regardless of
                    whether an exception was thrown or not. This makes it suitable for tasks like resource cleanup,
                    closing files, or releasing system resources.</li>
                <li><strong>Always a Part of Try and Catch Blocks:</strong> The <code>finally</code> block should always
                    be associated with a <code>try</code> and <code>catch</code> block. It ensures that the code within
                    the <code>finally</code> block is executed after the <code>try</code> block, and potentially the
                    <code>catch</code> block, no matter what happens in the preceding code.
                </li>
                <li><strong>Cannot Be Used Without Try and Catch:</strong> You cannot use the <code>finally</code> block
                    on its own; it must be used in conjunction with a <code>try</code> and <code>catch</code> block.
                </li>
            </ul>
            <p><strong>Syntax:</strong></p>
            <pre>
                <code>
try {
    // Code that may throw exceptions
}
catch (Exception e) {
    // Exception handling code
}
finally {
    // Code that always executes, whether or not an exception was thrown
}
                </code>
            </pre>

        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>
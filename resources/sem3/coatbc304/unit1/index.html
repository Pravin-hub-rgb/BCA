<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA&rArr;Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key concepts Computer Organization and Architecture</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <style>
        body {
            background: #0f0c29;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* Chrome 10-25, Safari 5.1-6 */
            background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
            /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
            color: white;
        }
    </style>
</head>

<body>
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">RTL</a>
        <a href="#t2" class="link">Register definition</a>
        <a href="#t3" class="link">Designation of a register</a>
        <a href="#t4" class="link">Register transfer</a>
        <a href="#t5" class="link">Bus and memory transfer</a>
        <a href="#t6" class="link">Memory transfer in detail</a>
        <a href="#t7" class="link">Micro operation</a>
        <a href="#t8" class="link">Computer instruction</a>
        <a href="#t9" class="link">Instruction cycle</a>
        <a href="#t10" class="link">Memory reference instruction</a>
        <a href="#t11" class="link">Input/output and interrupts</a>
        <div class="botbut">
            <a href="" class="link">Next Topic &rarr;</a>
            <a href="" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Key concepts of Computer Organization and Architecture</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Key concepts of Computer Organization and Architecture</h1>
        <ul>
            <li><b>About Computer Organization and Architecture:</b>
                <ul>
                    <li>Computer Organization and Architecture is a fundamental field in computer science that deals
                        with the design and structure of computer systems, including the internal components and their
                        interactions. It focuses on how computers are structured and organized at both the hardware and
                        system levels, ensuring that they can efficiently execute programs and perform tasks.</li>
                </ul>
            </li>
            <li>Importance of Learning Computer Organization and Architecture:
                <ul>
                    <li>Efficient Program Execution: Understanding computer organization helps programmers write code
                        that can make the best use of a computer's resources, resulting in faster and more efficient
                        programs.</li>
                    <li>Hardware-Software Interface: It bridges the gap between software and hardware. Knowing how
                        software instructions are executed in hardware guides developers in optimizing code.</li>
                    <li>System Design: For computer engineers, understanding architecture is crucial for designing
                        efficient and powerful computer systems, from microcontrollers to supercomputers.</li>
                    <li>Troubleshooting and Performance Optimization: Proficiency in architecture aids in diagnosing
                        hardware and software performance issues and optimizing system performance.</li>
                    <li>Innovation and Advancement: Knowledge of computer architecture enables the creation of new
                        technologies, architectures, and computing paradigms, driving technological advancements.</li>
                    <li>Career Opportunities: Many roles in the tech industry, from software development to system
                        administration, benefit from a strong understanding of computer organization and architecture.
                    </li>
                    <li>In essence, computer organization and architecture lay the foundation for developing robust,
                        high-performance, and innovative computing systems that drive various industries and impact our
                        daily lives.</li>
                </ul>
            </li>
        </ul>
        <div id="t1" class="wh">
            <h2>Register Transfer Language (RTL)</h2>
            <p><b>What is register?</b></p>
            <ul>
                <li>Register is a very fast computer memory, used to store data/instruction in-execution.
                    <ul>
                        <li>A Register is a group of flip-flops with each flip-flop capable of storing one bit of
                            information.</li>
                        <li>An <b>n-bit register</b> has a group of n flip-flops and is capable of storing binary
                            information of n-bits.</li>
                    </ul>
                </li>
                <li>Hence, a register consists of a group of flip-flops and gates.</li>
                <li>Use of flip flop: Flip flop holds the binary information and gates control when when and how new
                    information is transferred into a register.</li>
            </ul>
            <p><b>Before learning Register Transfer Language we should know what are registers and why we are learning
                    them? What is its significane in digital machine?</b></p>
            <ul>
                <li>We know that digital machine work with digital circuits.</li>
                <li>There are two types of digital circuits:
                    <ol>
                        <li>Combinational circuits</li>
                        <li>Sequential circuits</li>
                    </ol>
                </li>
                <li>We came accross flip flop in digital circuits and we know that a register is a group of flip-flop
                    which can store bit of information.</li>
                <li>Simple digital systems are frequently characterized in terms of:
                    <ol>
                        <li>The register they contain.
                            <ul>
                                <li>When we say our computer if of 64 bit, we mean that the size of register which we is
                                    used to pass instruction to the machine is of size 64 bits.</li>
                                <li>The resistor can store larger amounts of data.</li>
                                <li>Instructions and data can be processed more efficiently.</li>
                                <li>That's why we are learning about registers.</li>
                            </ul>
                        </li>
                        <li>The operations that are performed on data stored in them.</li>
                    </ol>
                </li>
                <li>The operations executed on the data in registers are called micro-operations e.g. shit, count, clear
                    and load.</li>
            </ul>
            <p><b>Some of the commonly used register are:</b></p>
            <ul>
                <li><b>Accumulator</b> : This is the most common register, used to store data taken out from the memory.
                </li>
                <li><b>General Purpose Registers</b> : This is used to store data intermediate results during program
                    execution. It can be accessed via assembly programming.</li>
            </ul>
            <p><b>Special purpose registers:</b> Users do not access these registers. These registers are for computer
                system.</p>
            <ul>
                <li><b>MAR</b> : Memory Address Register are those registers that holds the address for memory unit.
                </li>
                <li><b>MBR</b> : Memory Buffer Register stores instruction and data received from the memory and sent
                    from the memory.</li>
                <li><b>PC</b> : Program Counter points to the next instruction to be executed.</li>
                <li><b>IR</b> : Instruction Register holds the instruction to be executed.</li>
            </ul>
            <img src="../../images/register1.svg" alt="" class="wb">
            <div class="in">
                <h3>Internal hardware organization of a digital computer</h3>
                <ul>
                    <li>Internal hardware organization of a digital computer can be orgaized in 3 format.</li>
                </ul>
                <ol>
                    <li>Set of register it contains and their function.
                        <ul>
                            <li>How many general purpose register are there.</li>
                            <li>Size of instruction register.</li>
                        </ul>
                    </li>
                    <li>Sequence of microoperations performed on binary information stored in registers.</li>
                    <li>Control signals that initiate the sequence of microoperations that we want to perform.
                        <ul>
                            <li>Suppose if we want to add two numbers (A + B), they will not be directly added, there
                                must be some control function will be used which will be contolling the value of A and
                                B, and which will also control this operation to happen.</li>
                        </ul>
                    </li>
                </ol>
            </div>
            <div class="in">
                <h3>What is RTL?</h3>
                <ul>
                    <li>The symbolic notation used to describe the microoperation transfers among registers is called
                        <b>Register Transfer Language.</b>
                    </li>
                    <li>It is basically a language and we know that a language have its own syntax and rules and RTL is
                        used while we are working with computer organization and its design.</li>
                </ul>
                <p><b>Key points for RTL</b></p>
                <ul>
                    <li>A symbolic language.</li>
                    <li>A convenient tool for describing the internal organization of digital computers in
                        consice/precise manner.</li>
                    <li>Can also be used to facilitate the design process of digital systems.</li>
                </ul>
                <p><b>Rules of RTL</b></p>
                <ul>
                    <li>Registers are designated by capital letters, some time followed by numbers (e.g. A, R1, IR)</li>
                    <li>Often the name indicate function:
                        <ul>
                            <li>MAR : Memory Address Regsiter</li>
                            <li>PC : Program Counter</li>
                            <li>IR : Instruction Register</li>
                        </ul>
                    </li>
                </ul>
                <div class="wh">
                    <p><b>Register Transfer</b></h>
                    <p>Register transfer involves transferring data between registers using microoperations.</p>
                    <ul>
                        <li>Hardware logic circuits perform microoperations.</li>
                        <li>Transfers results between registers.</li>
                        <li>Control signals can conditionally affect transfers.</li>
                    </ul>
                </div>
            </div>
        </div>
        <div id="t2" class="wh">
            <h2>Some register definition</h2>
            <div class="in">
                <h3>Address registers</h3>
                <ul>
                    <li>We know CPU reads and write data on memory. So this address register is used to store memory
                        address of
                        data for CPU.</li>
                    <li>It picks data from memory like addresses, addresses stored in address register, AR gives the
                        addres to memory, memory then decodes the addresses and then fetches the data from RAM.</li>
                    <li>Size = 12 bits.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Memory Data Register</h3>
                <ul>
                    <li>The Memory Data Register (MDR) is a component of a computer's CPU that temporarily holds data
                        fetched from or destined for the computer's memory. When the CPU reads data from memory, it's
                        stored in the MDR before being processed. Similarly, when the CPU writes data to memory, it
                        places the data in the MDR before sending it to the memory. The MDR essentially acts as a
                        temporary storage location for data during memory read and write operations.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Memory Buffer Register (MBR)</h3>
                <ul>
                    <li>The Memory Buffer Register (MBR) is used in input/output (I/O) operations in computer systems.
                        It holds data that is being transferred between the CPU and an I/O device, such as a hard drive
                        or network interface. The MBR helps in coordinating data transfers between the CPU and I/O
                        devices, ensuring efficient communication and minimizing bottlenecks. It serves as a temporary
                        buffer to hold data that is moving between the CPU and external devices.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Accumulator</h3>
                <ul>
                    <li>It stores intermediate results from ALU to RAM and temoporary information of operands.</li>
                    <li>It is also called Processor Register.</li>
                    <li>The accumulator register retrieves data from memory and temporarily stores it before
                        transferring it to the ALU. This intermediate step allows data to be efficiently accessed by the
                        ALU for various arithmetic and logical operations. By doing so, the processor optimizes
                        performance by minimizing direct memory access during calculations.</li>
                    <li></li>
                </ul>
            </div>
            <div class="in">
                <h3>Instruction Register</h3>
                <ul>
                    <li>Stores instruction that needs to be executed.</li>
                </ul>
                <img src="../../images/opcode.svg" alt="" class="wb">
                <p>Instruction basically consists of 3 parts</p>
                <ol>
                    <li><b>I</b> &rarr; It is the MSB
                        <ul>
                            <li>Could be 0 or 1.</li>
                            <li>It I = 0 it means direct address.</li>
                            <li>It I = 1 then it shows indirect addressing.</li>
                            <li>If value is 0 then directly go on that location to fetch data and give to accumulator.
                            </li>
                            <li>If the value is 1, it indicates indirect addressing. In this case, the system follows a
                                sequence where it moves to the 1st location, which then directs it to the 2nd location,
                                and from there, to the 3rd location where the data is located.</li>
                        </ul>
                    </li>
                    <li><b>Op code</b> &rarr; Operation to be performed like addition, sutraction, multiplication or
                        division.</li>
                    <li><b>Operands</b> &rarr; Data on which operation has to be performed.
                        <ul>
                            <li>Operand part has the address of data on which we have to perform operation.</li>
                        </ul>
                    </li>
                </ol>
                <ul>
                    <li>Instruction Register would be of 16 bit, in which operands will be of 12 bits then 3 bits is for
                        OP code and 1 bit for I.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Program Counter</h3>
                <ul>
                    <li>Definition: The Program Counter (PC) register is a special-purpose processor register that holds
                        the memory address of the next instruction to be fetched and executed.</li>
                </ul>
            </div>
        </div>
        <div id="t3" class="wh">
            <h2>Designation of a Register</h2>
            <ul>
                <li>Means how we can demonstrate that it is a :
                    <ul>
                        <li>Register</li>
                        <li>Portion of register</li>
                        <li>A bit of a register</li>
                    </ul>
                </li>
            </ul>
            <img src="../../images/register2.svg" alt="" class="wb">
        </div>
        <div id="t4" class="wh">
            <h2>Register Transfer</h2>
            <ul>
                <li>Register Transfer refers to the movement of data between registers within a computer's central
                    processing unit (CPU) as part of executing instructions. It involves the controlled transfer of
                    binary data from one register to another, often through arithmetic or logic operations, forming
                    the fundamental basis for instruction execution and data manipulation in a computer's
                    microarchitecture.</li>
                <li>Basically it is copying contents of one register to another.</li>
                <li>A register transfer is indicated as &darr;<br>
                    R2 &larr; R1
                    <ul>
                        <li>R1 is source register and R2 is destination register</li>
                        <li>In this case the contents of register R1 are copied (loaded into) register R2.</li>
                        <li>A simultaneous transfer of all bit from the source R1 to the destination register R2, during
                            one clock pulse.</li>
                        <li>Note that this is non-destructive, i.e. the contents of R1 are not altered by copying
                            (loading) them to R2.</li>
                        <li>The data is tranfered parallely.</li>
                        <li>Any microoperation that is performed on the register will always be controlled by the
                            control function.</li>
                    </ul>
                </li>
            </ul>
            <div class="in">
                <h3>Control functions</h3>
                <ul>
                    <li>Often actions need to only occur if a certain condition is true.</li>
                    <li>This is similar to an "if" statement in a programming language. In digital systems this is often
                        done via control signal called a <b>control function.</b></li>
                    <li>If the signal is 1, then the action takes place. </li>
                    <li>This is represented as:
                        <br>P: R2 &larr; R1
                        <br>Which means "If p = 1, then load the content of register R1 into register R2" i.e. if (P =
                        1) the (R2 &larr; R1)
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Hardware implementation of controlled transfers</h3>
                <img src="../../images/transfer1.svg" alt="" class="wb">
                <p>1- Content of register R1 and R6 are added & result is transfered into register MDR only when P + Q =
                    1. &darr;</p>
                <img src="../../images/transfer2.svg" alt="" class="wb">
                <p>2- The difference of two register R2 and R4 is to be stored in register IR wen either P or Q is 1.
                    &darr;</p>
                <img src="../../images/transfer3.svg" alt="" class="wb">
            </div>
            <ul>
                <li>The same clock controls the circuits that generate the control function and the designated register.
                </li>
                <li>Registers are assumed to use positive edge triggered flip-flops.</li>
            </ul>
            <div class="in">
                <h3>Basic Symbols used for Register Transfer</h3>
                <img src="../../images/resgister3.svg" alt="" class="wb">
            </div>
            <div class="in">
                <h3>Examples:</h3>
                <ul>
                    <li>If(P = 1) then (R2 &larr; R1)
                        <br>Symbol - P : R2 &larr; R1
                    </li>
                    <li>Q&rArr; The data of register R5 & R9 is transfered to R3 & R10 respectively only T = 1
                        <br> A&rArr; T : R3 &larr; R5, R10 &larr; R9
                    </li>
                    <li>Q&rArr; The content of register R1 & R6 are added & result is transfered into register MDR only
                        when
                        P + Q = 1
                        <br>A&rArr; P + Q : MDR &larr; R1 + R6
                    </li>
                    <li>Q&rArr; The difference of 2 register R2 & R4 is to be stored in register IR when either P or Q
                        is 1
                        <br>A&rArr; P &oplus; Q : IR &larr; (R2 - R4)
                    </li>
                </ul>
            </div>
        </div>
        <div id="t5" class="wh">
            <h2>Bus and memory transfer</h2>
            <p><b>Q-</b> Why there is a need to have a bus.
            <ul>
                <li>In a digital system with multiple registers, it's not feasible to create direct connections for data
                    and control lines between each pair of registers to allow them to directly load content from any
                    other register. This is why computer systems use a bus—a shared communication pathway—allowing
                    efficient data transfer among various components.</li>
                <li>A bus structure consists of set of common lines, one for each bit of a register through which binary
                    information is transfered one at a time. It have a control circuits to select which register is the
                    source, and which is the destination.</li>
                <li>This is how we are designing the bus systems from register to bus. Bus &larr; R
                    <br><img src="../../images/busline.svg" alt="" class="wb">
                </li>
            </ul>
            </p>
            <ul>
                <li>Bus Transfer is the most efficient way to transfer data. The transfer of data from the Bus lines to
                    the outside environment and vice versa is known as Bus transfer. Similarly, the transfer of data
                    from the memory unit to the outside environment and vice versa is known as memory transfer.</li>
            </ul>
            <div class="in">
                <h3>Bus Transfer</h3>
                <ul>
                    <li>In a digital system of registers, a path must be provided to move information.</li>
                    <li>A bus is made up of a collection of common lines, one for each bit of a register, that are used
                        to transfer binary data.</li>
                    <li>There are two methods in bus transfer:
                        <ul>
                            <li>Bus transfer using Multiplexer</li>
                            <li>Bus transfer using Three states bus buffer</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Bus transfer using multiplexer</h3>
                <ul>
                    <li>Multiplexer selects the source register whose binary information is kept on the bus.</li>
                    <li>Key terms to understand before desinging a bus system using multiplexer.</li>
                    <li>There would always be a scnerio given.</li>
                    <li>Example question scenerio : Construct a bus system of 8 register with 16 bits.</li>
                    <img src="../../images/busline2.svg" alt="" class="wb">
                    <li>Now according to the scenerio.
                        <ol>
                            <li>How many multiplexer are required.</li>
                            <li>What would be the size of each multiplexer.</li>
                            <li>How many selection lines?</li>
                        </ol>
                    </li>
                    <img src="../../images/busline3.svg" alt="" class="wb">
                    <ul>
                        <li>In the above scenerio of 8 registers with 16 bits
                            <ul>
                                <li>Number of multiplexer = 16</li>
                                <li>Size of each multiplexer = k x 1 = 8 x 1</li>
                                <li>And we know that for 8 x 1 multiplexer there are 3 selection lines.</li>
                            </ul>
                        </li>
                    </ul>
                </ul>
            </div>
            <div class="in">
                <p><b>Construct a bus system for 4 register and each bit = 4</b></p>
                <img src="../../images/busline4.svg" alt="" class="wb">
                <p><b>Construct a bus system for eight 4 bit register</b></p>
                <p><b>Design a bus system for four 8 bit register</b></p>
            </div>
            <div class="in">
                <h3>Bys system using three state buffer</h3>
                <ul>
                    <li>A three state gate is a digital circuit that exhibits tree states in which two fo the states are
                        signals equivalent to logic 0 and 1 as in a conventional gate, the third gate is the high
                        impedance state (which will restrict the flow of input towards the output).</li>
                    <li>The high impedence state behaves like an open circuit, which means that output is disconnected
                        and does not have logic significance.</li>
                    <li>A three state bus buffer has a control input that determines the output state. When the control
                        input is equal to 1, the output is enabled and the gate behaves like a conventional buffer with
                        the output equal to the normal input. When the control input is 0 the output is disabled and the
                        date goes to high impedence state, regardless of the value in the normal input.</li>
                </ul>
                <img src="../../images/busline5.svg" alt="" class="wb">
                <ul>
                    <li>Normally in buffer the input deleivered = output generated, but in 3 state buffer second input
                        is control input.</li>
                    <li>When C = 1 only in that case A will be transfered as the circuit is close. If C = 0, state =
                        high impedance as it is open circuit.</li>
                </ul>
                <img src="../../images/busline6.svg" alt="" class="wb">
            </div>
        </div>
        <div id="t6" class="wh">
            <h2>Memory Transfer</h2>
            <ul>
                <li>A memory unit is a collection of storage cells. The memory stores binary information in groups of
                    bits called words. A memory word is a group of l’s and 0’s. A group of eight bits is called a byte.
                    Thus a 16-bit word contains two bytes, and a 32-bit word is made up of four bytes. </li>
                <li>Memory transfer means reading data from memory or writing data into memory.</li>
                <li>The transfer of information from a memory unit to the user end is called a <b>Read</b> operation.
                </li>
                <li>The transfer of new information to be stored in the memory is called a <b>Write</b> operation.</li>
                <li>A memory word is designated by the letter M.</li>
                <li>We must specify the address of memory word while writing the memory transfer operations.</li>
                <li>The address register is designated by AR and the data register by DR.</li>
                <li>Thus, a read operation can be stated as:
                    <br>Read: DR &larr; M [AR]
                </li>
                <li>The Read statement causes a transfer of information into the data register (DR) from the memory
                    word (M) selected by the address register (AR).</li>
            </ul>
            <img src="../../images/mar.svg" alt="" class="wb">
        </div>
        <div id="t7" class="wh">
            <h2>Mirco operation</h2>
            <ul>
                <li>A micro-operation is a simple operation performed on the data stored in one or more registers. They
                    transfer the data between registers. There are four types of micro-operaitons:
                    <ol>
                        <li><b>Register transfer microoperations</b> transfer binary information from one register to
                            another.</li>
                        <li><b>Arithmetic mircooperations</b> perform arithmetic operation on numberic data stored in
                            registers.</li>
                        <li><b>Logic mircrooperations</b> perform bit manipulation operations on non0-numeric data
                            stored in registers.</li>
                        <li><b>Shift microoperations</b> perform shift operations on data stored in registers.</li>
                    </ol>
                </li>
            </ul>
            <h2>Types of microoperation</h2>
            <div class="in">
                <h3>Arithmetic microoperation</h3>
                <ul>
                    <li>The basic arithmetic operation are addition, subtraction, complement, increment and decrement.
                    </li>
                    <li>some symbolic representaion of arithmetic microoperation are &darr;</li>
                </ul>
                <img src="../../images/register4.svg" alt="" class="wb">
                <ul>
                    <li>Multiplication and division are valid operation but they are not basic microoperation</li>
                </ul>
            </div>
            <div class="in">
                <h3>Logic microoperation</h3>
                <ul>
                    <li>Logic micro-operaitons consider each bit of the register separately and treat them as binary
                        variables.</li>
                    <li>Example &darr;</li>
                </ul>
                <img src="../../images/logic1.svg" alt="" class="wb">
                <p><b>Selective set</b>: The selective-set operation sets bit to 1 in register A where there are
                    corresponding 1 in register B.</p>
                <img src="../../images/selectiveset1.svg" alt="" class="wb">
                <ul>
                    <li>The two leftmost bits of B are 1’s, so the corresponding bits of A are set to 1.The two bits of
                        A with corresponding 0’s in B remain unchanged. The OR microoperation can be used to selectively
                        set bits of a register. </li>
                </ul>
                <P><b>Selective complement</b>: The selective-complement operation complements bits in A where there are
                    corresponding 1 in B. It does not affect bit positions that have 0’s in B. For example: </P>
                <img src="../../images/selectiveset2.svg" alt="" class="wb">
                <ul>
                    <li>Again the two leftmost bits of B are 1’s, so the corresponding bits of A are complemented. The
                        exclusive-OR microoperation can be used to selectively complement. </li>
                </ul>
                <p><b>Selective-clear</b>: The selective clear operatons clears to 0 the bits in A only where there are
                    corresponding 1 in B. For example &darr;</p>
                <img src="../../images/selectiveset3.svg" alt="" class="wb">
                <ul>
                    <li>Again the two leftmost bits of B are 1’s, so the corresponding bits of A are cleared to 0. </li>
                </ul>
                <p><b>Mask operation</b>: The mask operation is similar to the selective-clear operation except that the
                    bits of A are cleared only where there are corresponding 0’s in B. The mask operation is an AND
                    micro operation as seen from the following numerical example:</p>
                <img src="../../images/mask1.svg" alt="" class="wb">
                <ul>
                    <li>The two rightmost bits of A are cleared because the corresponding bits of B are 0’s. The two
                        leftmost bits are left unchanged because the corresponding bits of B are 1’s. </li>
                </ul>
                <p><b>Insertion operation</b>: The insert operation inserts a new value into a group of bits. This is
                    done by first masking the bits and then ORing them with the required value. For example, suppose
                    that an A register contains eight bits, 0110 1010. To replace the four leftmost bits by the value
                    1001 we first mask the four unwanted bits: </p>
                <img src="../../images/mask2.svg" alt="" class="wb">
                <ul>
                    <li>The mask operation is an AND microoperation and the insert operation is an OR microoperation.
                    </li>
                </ul>
                <p><b>Clear operation</b>: The clear operation compares the words in A and B and produces an all 0’s
                    result if the two numbers are equal. This operation is achieved by an exclusive-OR microoperation as
                    shown by the following example: </p>
                <img src="../../images/mask3.svg" alt="" class="wb">
                <ul>
                    <li>When A and B are equal, the two corresponding bits are either both 0 or both 1. In either case
                        the exclusive-OR operation produces a 0. The all-0’s result is then checked to determine if the
                        two numbers were equal</li>
                </ul>
            </div>
            <div class="in">
                <h3>Shift mirco-operations</h3>
                <ul>
                    <li>Shift microoperations are used for serial transfer of data. The contents of a register can be
                        shifted to the left or the right. There are three types of shifts: logical, circular and
                        arithmetic.</li>
                    <li><b>A logical shift</b> is one that transfers 0 through the serial input. They symbols <b>shl</b>
                        and
                        <b>shr</b> are used to show logical shift-left and shift-right microoperations. For example
                        &darr;
                    </li>
                    <img src="../../images/shl.svg" alt="" class="wb">
                    <li><b>The circular shift</b> (also known as a rotate operation) circulates the bits of the register
                        around the two ends without loss of information. This is accomplished by connecting the serial
                        output of the shift register to its serial input. We will use the symbols <b>cil</b> and
                        <b>cir</b> for the circular shift left and right, respectively.
                    </li>
                    <img src="../../images/circularshift.svg" alt="" class="wb">
                    <li><b>An arithmetic shift</b>, shifts a signed binary number to the left or right. An arithmetic
                        shift-left multiplies a signed binary number by 2. An arithmetic shift-right divides the number
                        by 2. Arithmetic shifts must leave the sign bit unchanged because the sign of the number remains
                        the same when it is multiplied or divided by 2.
                        <ul>
                            <li>The arithmetic shift-right leaves the sign bit unchanged and shifts the number to the
                                right. Thus Rn-1 remains the same, Rn -2 receives the bit from Rn -1. The bit in R0 is
                                lost. The arithmetic shift-left inserts a 0 into R0, and shifts all other bits to the
                                left. The initial bit of Rn-1 is lost and replaced by the bit from Rn-2. </li>
                        </ul>
                    </li>
                    <img src="../../images/asr.svg" alt="" class="wb">
                    <ul>
                        <li>The symbolic notation for the shift mircrooperations is shown in Table</li>
                    </ul>
                    <img src="../../images/arithtable.svg" alt="" class="wb">
                </ul>
            </div>
        </div>
        <div id="t8" class="wh">
            <h2>Computer Instructions</h2>
            <div class="in">
                <h3>Basic FUNDA</h3>
                <ul>
                    <li><a class="ba" href="https://www.youtube.com/watch?v=oADINwRQbAQ" target="_blank">Video lecture
                            &nearr;</a></li>
                </ul>
                <ul>
                    <li>First we should know the basic modules out of which our computer is made out of &darr;</li>
                </ul>
                <img src="../../images/module1.svg" alt="" class="wb">
                <ul>
                    <li><b>Processor &rarr; </b> It is a module where all instructions of program are executed.
                        <ul>
                            <li>Here all calucation occurs.</li>
                        </ul>
                    </li>
                    <li><b>Memory &rarr; </b> Module where data is stored.</li>
                    <li><b>I/O</b> &rarr; Module by which data is brought into the machine and result is given out.</li>
                </ul>
                <p>Using these basic 3 modules a computer is build.</p>
                <ul>
                    <li>We have learned about the operations that are performed by ALU (Arithmetic Logical Unit) module
                        of processor like
                        shift operation, arithmetic, logic, etc.</li>
                    <li>ALU basically perform operation when data and instructions(add, sub) are given to it and then it
                        generates result.</li>
                    <li>The ALU by itself can't finish the job, as it needs the right instructions for calculating
                        results in a specific time. This is why another part inside the processor, called the control
                        unit, is necessary. The control unit makes sure the timing and control signals are all set.</li>
                </ul>
                <p><b>Why CU is important?</b></p>
                <ul>
                    <li>The Control Unit (CU) plays a vital role in the computer's operation.</li>
                    <li>When data arrives for processing, it can't directly enter the Arithmetic Logic Unit (ALU) as the
                        ALU doesn't have the ability to understand what to do with the data without instructions.</li>
                    <li>This is how it functions: Initially, the data is stored in registers, which act as temporary
                        holding areas. Following that, the Control Unit (CU) becomes active.</li>
                    <li>The Control Unit generates instructions that guide the ALU's actions:</li>
                    <ul>
                        <li>Retrieving data from the registers</li>
                        <li>Activating specific circuits within the ALU for precise time intervals, facilitating
                            calculations</li>
                        <li>Providing the final calculated result once the computations are finished.</li>
                    </ul>
                    </li>
                    <li>Basically CU is that module of a processor which controls all the operations happening inside
                        the processor.</li>
                </ul>
                <p><b>Exploring the core components of a computer highlights a vital fact: INSTRUCTIONS are the backbone
                        of its functioning. Without instructions, the Arithmetic Logic Unit (ALU) is directionless,
                        unable to perform tasks.</b></p>
            </div>
            <ul>
                <li>Instructions are the part of the program. Basically a program is a group of instructions. </li>
            </ul>
            <div class="in">
                <h3>Instruction format</h3>
                <img src="../../images/instruction1.svg" alt="" class="wb">
                <ul>
                    <li>This format is stored inside memory, these are brought to processor from memory.</li>
                    <li>This format provides a consistent way for the processor to understand and execute a wide range
                        of instructions.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Types of instructions format</h3>
                <ul>
                    <li><a class="ba" href="https://youtu.be/706aFmWa9ME?si=SiaH5kZD_3C200tF" target="_blank">Video
                            lecture &neArr;</a>
                    </li>
                </ul>
                <img src="../../images/instruction2.svg" alt="" class="wb">
                <ul>
                    <li><b>Memory Reference Instructions:</b> These instructions involve operations that require data to
                        be fetched from or stored into memory. They often include fields specifying memory addresses or
                        offsets to locate the desired data. Memory reference instructions are essential for tasks like
                        loading data into registers, storing results back to memory, and data manipulation.</li>
                    <li><b>Register Reference Instructions:</b> In these instructions, the operations are performed
                        directly using data stored within the CPU's registers. These instructions typically include
                        fields indicating the registers involved and the operation to be executed. Register reference
                        instructions are commonly used for arithmetic, logic, and data manipulation tasks.</li>
                    <li>
                        <b>Input/Output (I/O) Reference Instructions:</b> I/O reference instructions manage
                        communication between the computer and external devices. These instructions facilitate input
                        (receiving data from external sources) and output (sending data to external devices) operations.
                        They often include fields specifying the device or port to interact with and the data to be
                        transferred.
                    </li>
                </ul>
            </div>
        </div>
        <div id="t9" class="wh">
            <h2>Instruction Cycle</h2>
            <ul>
                <li><a class="ba" href="https://youtu.be/5jIg-D5gKtY?si=k93tkZYGS8JLTp3R" target="_blank">Video Lecture
                        &neArr;</a></li>
                <li><a class="ba" href="https://youtu.be/SFsnysyVhzA?si=--dyYaPZtNrmBBTH" target="_blank">Video Lecture
                        &neArr;</a></li>
            </ul>
            <ul>
                <li>We know that every program is a collection of instructions, where each instruction is executed with
                    the help of instruction cycle.</li>
                <ul>
                    <li>Instruction cycle is divided into 4 phases.
                        <ol>
                            <li>Fetch the instruction from the memory.</li>
                            <li>Decode the instruction</li>
                            <li>Read effective address</li>
                            <li>Execute the instruction.</li>
                        </ol>
                    </li>
                </ul>
            </ul>
            <p>After going through each phases for the first instructon, the CPU again start from the phase 1 for
                the second instruction and so on. This way all the program are to be executed. The last instruction
                of any program is HALT (program execution is over).</p>
            <ul>
                <li>What is program counter (PC)?
                    <ul>
                        <li>PC is a register which always contains instruction of next instruction to be executed.</li>
                    </ul>
                </li>
                <li>What is Sequence Counter (SC)?
                    <ul>
                        <li>If we apply the clock pulse in sequence counter for the first time we will get timing signal
                            called T<sub>0</sub>. If we apply another clock pulse we will another timing signal
                            (T<sub>1</sub>) and so on.</li>
                    </ul>
                </li>
            </ul>
            <div class="in">
                <h3>Phase 1 - Fetch </h3>
                <ul>
                    <li>We will see the register transfer state for fetch.</li>
                    <li>During T<sub>0</sub> AR &larr; PC. Initially PC contains address of next instruction to be
                        executed, that address will loaded into Address Register during first clock pulse.
                        <br>During T<sub>1</sub> IR &larr; M[AR], PC &larr; PC + 1. Here we have to read instruction
                        from the memory and that instruction should be loaded into instruction register (IR stores the
                        instruction), now for the next instruction to be executed we have to increment the PC.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Phase 2 - Decode</h3>
                <ul>
                    <li>T<sub>2</sub> AR &larr; IR[0-11], D<sub>7</sub> D<sub>6</sub> ... D<sub>0</sub> IR[12, 14], I
                        &larr; IR[15].
                        <ul>
                            <li>I is the direct or indirect address bit.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>FLow chart</h3>
                <img src="../../images/flowchartcycle1.svg" alt="" class="wb">
            </div>
        </div>
        <div id="t10" class="wh">
            <h2>Memory-Reference Instruction</h2>
            <ul>
                <li><a href="https://youtu.be/gJwINX2wgFA?si=G_gNMOyQE-x0IrBe" target="_blank">Video Lecture &neArr;</a>
                </li>
                <li><a href="https://youtu.be/3GVIyBt-50w?si=buXqMBbe2ksfaqit" target="_blank">Video Lecture &neArr;</a>
                </li>
            </ul>
            <ul>
                <li>There are seven memory-reference instructions and it depend on the value of D (op code).</li>
                <li>D<sub>7</sub> is for register reference and D<sub>0</sub> to D<sub>6</sub> are memory reference
                    instructions.</li>
                <li>Now if The I (direct or indirect bit) is = 0 then less time is consumed and is I = 1 then it will
                    take more time.</li>
            </ul>
            <img src="../../images/memoryinstructiontable.svg" alt="" class="wb">
            <div class="in">
                <h3>AND</h3>
                <ul>
                    <li>It performs the AND logic operation between AC and the data stored at address given by AR. The
                        result transferred into AC. The microoperations that execute this instruction are: <br>
                        DR &larr; M[AR]
                        <br>
                        AC &larr; AC &and; DR
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>ADD to AC</h3>
                <ul>
                    <li>It performs the addition of AC and the data which is stored at address given by AR. The sum is
                        transferred into AC and the output carry C<sub>out</sub> is transferred to the E flip-flop. The
                        microoperations needed to execute this instruction are: <br>
                        DR &larr; M[AR] <br>
                        AC &larr; AC + DR, E &larr; C<sub>out</sub>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>LDA: Load to AC</h3>
                <ul>
                    <li>This instruction transfers the data which is stored at address given by AR into AC. The
                        microoperations needed to execute this instruction are: <br>
                        DR &larr; M[AR] <br>
                        AC &larr; DR

                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>STA: Store AC</h3>
                <ul>
                    <li>This instruction stores the content of AC at the address given by AR. We can execute this
                        instruction with one microoperation: <br>
                        M[AR] &larr; AC
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>BUN: Branch Unconditionally</h3>
                <ul>
                    <li>It is used when a program has a branch instruction. In this control of a program goes to the
                        address given by AR (without checking any condition) and execute the instructions. <br>
                        PC &larr; AR
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>BSA: Branch and Save Return Address</h3>
                <ul>
                    <li>It is also used when a program has a branch instruction but when it moves to another program, it
                        stores the address of current instruction. When it come back, it starts from the stored address.
                        <br>
                        M[AR] &larr; PC, PC &larr; AR + 1
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>ISZ: Increment and Skip if Zero</h3>
                <ul>
                    <li>This instruction increments the word stored in AR, and if the incremented value is equal to 0,
                        PC is incremented by 1. </li>
                </ul>
            </div>
        </div>
        <div id="t11" class="wh">
            <h2>Input/Output and Interrupts</h2>
            <ul>
                <li><a href="https://youtu.be/k2Z7EsUe7o0?si=FgD7hFQDILO7v4IS" target="_blank">Video lecture &neArr;</a>
                </li>
            </ul>
            <ul>
                <li>Instruction and data stored in memory must come from some input device.</li>
                <li>Computational results must be transmitted to the user through some output devices.</li>
            </ul>
            <div class="in">
                <h3>I/O configuration</h3>
                <ul>
                    <li>The terminal sends and receives serial information. Each quantity of information has eight bits
                        of an alphanumeric code.</li>
                    <li>The serial information for the input device is shifted into the input register INPR.</li>
                    <li>The serial information for the output device is stored in the output register OUTR.</li>
                    <li>There two register communitcate with a communication interface serially and with the AC in
                        parallel.</li>
                </ul>
                <img src="../../images/ioconfig.svg" alt="" class="wb">
            </div>
            <div class="in">
                <ul>
                    <li><b>INPR &rarr;</b> Input Register - consists eight bits and holds an alphanumeric I/P
                        information.</li>
                    <li><b>FGI &rarr;</b> 1-bit I/P flag is a control flip-flop.
                        <ul>
                            <li>1 when new information is available in the I/P device.</li>
                            <li>0 when the information is accepted by the computer.</li>
                        </ul>
                    </li>
                    <li>Initially FGI is cleared to 0.</li>
                    <li>WHen a key is struct in the keyboard, an 8-bit alphanumeric code is shifted into INPR and the
                        input flag FGI is set to 1.</li>
                    <li>As long as the flag is set, the information in INPR cannot be changed by striking another key.
                    </li>
                    <li>The computer checks the flag bit, if it is 1, the information from INPR is tranferred in
                        parallel into AC and FGI is cleared to 0.</li>
                    <li>Once the flag is cleared, new information can be shifted into INPR by striking another key.</li>
                </ul>
            </div>
            <div class="in">
                <ul>
                    <li><b>OUTR &rarr; </b> Output Register - consists eight bits.</li>
                    <li><b>FGO &rarr; </b> 1-bit o/p flag is a control flip-flop.
                        <ul>
                            <li>0 do not load new thing.</li>
                            <li>1 information from AC is transferred in parallel to OUTR.</li>
                        </ul>
                    </li>
                    <li>Initially FGO = 1, information from AC is transferred in parallel to OUTR and FGO is cleared to
                        0.</li>
                    <li>O/p device accepts the coded information, prints the corresponding character and when the
                        operation is completed, it set FGO = 1.</li>
                    <li>The computer does not load a new character into OUTR when FGO = 0, it indicates the output
                        device is busy.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Interrupts</h3>
                <ul>
                    <li><a class="ba" href="https://youtu.be/L5XDJPAlz9s?si=xWQwIk8TFU3Yu7Lq" target="_blank">Video
                            lecture
                            &neArr;</a></li>
                </ul>
                <ul>
                    <li><b>Definition &rarr; </b> It is a mechanism by which modules like I/O or memory may interrupt
                        the normal processing of CPU.</li>
                    <li>Interrupt is required to improve the processing efficiency of CPU.</li>
                    <li>How does it happen?
                        <ul>
                            <li>CPUs are designed to execute instructions at a very high speed, often measured in
                                gigahertz (GHz), which means they can perform a large number of operations per second.
                                On the other hand, many external devices, such as keyboards, hard drives, or network
                                interfaces, operate at significantly slower speeds. For instance, hard drives might
                                transfer data at rates of megabytes per second, which is much slower compared to the
                                billions of instructions the CPU can execute in the same amount of time.</li>
                            <li>Without Interrupts: Imagine a scenario where the CPU is executing a program and needs to
                                read data from a slow external device. If interrupts were not used, the CPU would need
                                to continuously poll (check) the external device to see if it has data ready for
                                processing. This polling would involve the CPU repeatedly asking the device, "Are you
                                ready yet?" and waiting for a response.</li>
                            <li>Wasted CPU Time: During this waiting period, the CPU would not be doing anything
                                productive. It would spend a significant portion of its time repeatedly checking the
                                device's status instead of executing useful instructions from the program it's supposed
                                to run. This results in a wastage of CPU processing power and efficiency.</li>
                            <li>Interrupt Solution: Here's where interrupts come into play. When an external device has
                                data ready for processing or an event occurs that requires CPU attention, the device
                                sends an interrupt signal to the CPU. The CPU then temporarily suspends its current
                                activities, saves its current state, and switches to the appropriate interrupt handler
                                routine to deal with the event.

                                This allows the CPU to efficiently manage its time. It doesn't need to constantly poll
                                devices. Instead, it can continue executing other tasks or programs until an interrupt
                                occurs. When an interrupt happens, the CPU switches to handling that interrupt,
                                processes the required data or event, and then resumes its previous activities.</li>
                        </ul>
                    </li>
                    <li>In essence, interrupts allow the CPU to be more productive by not wasting time waiting for
                        slower devices. Instead, it can work on multiple tasks in parallel, efficiently responding to
                        external events and data availability as needed.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Interrupt Request & Interrupt Handler</h3>
                <ul>
                    <li><a class="ba" href="https://youtu.be/IrSQWHgscfY?si=wNApvyWgYpqWsNLl" target="_blank">Video
                            Lecture
                            &neArr;</a></li>
                </ul>
                <img src="../../images/interrupt1.svg" alt="" class="wb">
                <ul>
                    <li>CPU is executing some task.</li>
                    <li>User uses the keyboard to issue a high-priority command.</li>
                    <li>This issues an interrupt request to the CPU.</li>
                    <li>CPU suspends the current execution of the task.</li>
                    <li>CPU executes the code written to handle / implement this command.</li>
                    <li>CPU resumes its previous execution.</li>
                    <li><b>Advantage &rarr; </b> Efficiency of CPU improves.</li>
                    <li><b>Disadvantage &rarr; </b> Overhead required to serice the interrupt request.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Types of interrupts</h3>
                <ol>
                    <li>Program interrupt:
                        <ul>
                            <li>It occurs when some instruction within the program creates a condition that leads to an
                                interrupt.</li>
                            <li>Eg &rarr; divide by 0, arithmetic overflow (memory size is 8 bits but after addition 9
                                bits memory size is required.).</li>
                        </ul>
                    </li>
                    <li>Timer interrupt:
                        <ul>
                            <li>It is generated by the timer present with in the processor.</li>
                            <li>OS sets the time to perform certain operation on regular basis.</li>
                        </ul>
                    </li>
                    <li>Input-output interrupt:
                        <ul>
                            <li>Generated by I/O devices.</li>
                            <li>Signal successful task completion or error.</li>
                        </ul>
                    </li>
                    <li>Hardware interrupt:
                        <ul>
                            <li>cause &rarr; failures related to hardware.</li>
                        </ul>
                    </li>
                </ol>
            </div>
            <div class="in">
                <h3>How to handle single interrupt?</h3>
                <ul>
                    <li><a href="https://youtu.be/GvoNH4NLWw0?si=yzsGS2iVVYLfk7KC" target="_blank" class="ba">Video
                            lecture &neArr;</a></li>
                </ul>
                <ul>
                    <li>Add interrupt cycle to instruction cycle.</li>
                    <li>If interrupt occurs:
                        <ol>
                            <li>Suspend the execution of program</li>
                            <li>Saving the context i.e. current contents of PC, register values, stack contents.</li>
                            <li>Determine the interrupt handler.</li>
                            <li>Set PC to the starting address of the handler.</li>
                            <li>Fetch & execute the instruction handler completion, resume processing of the interrpted
                                code.</li>
                        </ol>
                    </li>
                    <li>If no interrupt
                        <ul>
                            <li>CPU proceeds to fetch - execute cycle.</li>
                        </ul>
                    </li>
                </ul>
                <img src="../../images/interrupt2.svg" alt="" class="wb">
            </div>
            <div class="in">
                <h3>How to handle multiple interrupts</h3>
                <ul>
                    <li><a href="https://youtu.be/NMQG-cRPpmg?si=zx1WhVcefdvxVVEZ" target="_blank" class="ba">Video
                            lecture &neArr;</a></li>
                </ul>
                <p><b>Method 1 : Disable multiple interrupts</b></p>
                <ul>
                    <li>is a technique used in interrupt handling to temporarily prevent the CPU from responding to
                        additional interrupts while it is already processing an interrupt. This approach ensures that
                        the CPU completes the current interrupt handling routine without being interrupted by other
                        interrupt requests. Once the current interrupt is fully handled, the CPU re-enables interrupts,
                        allowing it to respond to new interrupt requests.</li>
                    <li>Here sequential execution of interrupt occurs &darr;</li>
                </ul>
                <img src="../../images/interrupt3.svg" alt="" class="wb">
                <ul>
                    <li><b>Advantages : </b>
                        <ul>
                            <li>Predictable Handling: Disabling multiple interrupts ensures that the CPU completes the
                                current interrupt handling routine without being interrupted by other interrupts. This
                                can lead to more predictable and deterministic behavior in critical tasks.</li>
                            <li>Simplicity: This approach can simplify the interrupt handling process, making it easier
                                to manage and debug interrupt-related code.</li>
                            <li>Avoids Race Conditions: By preventing multiple interrupts from occurring simultaneously,
                                the CPU avoids potential race conditions where multiple interrupts might interact in
                                unexpected ways.</li>
                        </ul>
                    </li>
                    <li><b>Disadvantages : </b>
                        <ul>
                            <li>Interrupt Latency: While the CPU is handling an interrupt with interrupts disabled, it
                                cannot respond to other interrupts, potentially causing a delay in handling
                                time-sensitive events.</li>
                            <li>Unresponsiveness: If an interrupt with high priority occurs while interrupts are
                                disabled, the system might not be able to promptly respond, leading to reduced system
                                responsiveness.</li>
                            <li>Interrupt Priority: Disabling multiple interrupts can prevent lower-priority interrupts
                                from being serviced during the execution of a higher-priority interrupt, potentially
                                affecting the overall system performance.</li>
                        </ul>
                    </li>
                </ul>
                <p><b>Method 2 : Give priority to interrupt</b></p>
                <ul>
                    <li>The "give priority to interrupt" technique is an interrupt handling strategy in computer systems
                        where different interrupts are assigned different priority levels. When multiple interrupts
                        occur simultaneously or in quick succession, the system responds to the interrupt with the
                        highest priority first. This approach ensures that critical or time-sensitive events are
                        addressed promptly, even if other interrupts are pending.</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>Resources &darr;</p>
        <ul>
            <li><a href="https://youtu.be/aIqd4rK0SX4" target="_blank">RTL intro &neArr;</a></li>
            <li><a href="https://youtu.be/8YwYycuGIys" target="_blank">Bus and Memory Transfer &neArr;</a></li>
            <li><a href="https://www.youtube.com/playlist?list=PLXj4XH7LcRfDXDRzSLv1FfZ-SSA38SiC0"
                    target="_blank">Playlist &neArr;</a></li>
            <li><a href="https://www.youtube.com/watch?v=mNNywW00eEc" target="_blank">1.1 Register Transfer Language and
                    Microoperations || Explained in Hindi Morris Mano Computer Organi &neArr;</a></li>
            <li><a href="https://youtu.be/oADINwRQbAQ" target="_blank">Control unit: Instruction format &neArr;</a></li>
            <li><a href="https://youtu.be/uoFr0f7lh4M" target="_blank">Types of Instructions in Computer Architecture

                    &neArr;</a></li>
        </ul>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>